
Irrigation_System.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004fdc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000044  00800060  00004fdc  00005070  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000056b  008000a4  008000a4  000050b4  2**0
                  ALLOC
  3 .stab         00006a80  00000000  00000000  000050b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003a35  00000000  00000000  0000bb34  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000f569  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000f6a9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000f819  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00011462  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0001234d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  000130fc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0001325c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  000134e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00013cb7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 91 19 	jmp	0x3322	; 0x3322 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 36 0c 	jmp	0x186c	; 0x186c <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec ed       	ldi	r30, 0xDC	; 220
      68:	ff e4       	ldi	r31, 0x4F	; 79
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 3a       	cpi	r26, 0xA4	; 164
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	16 e0       	ldi	r17, 0x06	; 6
      78:	a4 ea       	ldi	r26, 0xA4	; 164
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 30       	cpi	r26, 0x0F	; 15
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 9f 26 	call	0x4d3e	; 0x4d3e <main>
      8a:	0c 94 ec 27 	jmp	0x4fd8	; 0x4fd8 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 96 27 	jmp	0x4f2c	; 0x4f2c <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	aa e9       	ldi	r26, 0x9A	; 154
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 b2 27 	jmp	0x4f64	; 0x4f64 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 a2 27 	jmp	0x4f44	; 0x4f44 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 be 27 	jmp	0x4f7c	; 0x4f7c <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 a2 27 	jmp	0x4f44	; 0x4f44 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 be 27 	jmp	0x4f7c	; 0x4f7c <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 96 27 	jmp	0x4f2c	; 0x4f2c <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8a e9       	ldi	r24, 0x9A	; 154
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 b2 27 	jmp	0x4f64	; 0x4f64 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 a2 27 	jmp	0x4f44	; 0x4f44 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 be 27 	jmp	0x4f7c	; 0x4f7c <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 a2 27 	jmp	0x4f44	; 0x4f44 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 be 27 	jmp	0x4f7c	; 0x4f7c <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 a2 27 	jmp	0x4f44	; 0x4f44 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 be 27 	jmp	0x4f7c	; 0x4f7c <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 a6 27 	jmp	0x4f4c	; 0x4f4c <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 c2 27 	jmp	0x4f84	; 0x4f84 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <soil_moisture_sensor_ISR>:
#include "../FreeRTOS/task.h"
#include "Tasks_Interface.h"
#include "avr/delay.h"

void soil_moisture_sensor_ISR(void)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	0f 92       	push	r0
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
	/*	Local Variable for new value of Global_Soil_percent	*/
	u8 Local_NewData=0;
     b50:	19 82       	std	Y+1, r1	; 0x01

	/*	ADC Channel Select for soil_moisture_sensor	*/
	ADC_voidChannelSellect(5);
     b52:	85 e0       	ldi	r24, 0x05	; 5
     b54:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <ADC_voidChannelSellect>

	Global_Soil_percent=(Global_SoilMoisture_Data*100)/700;
     b58:	20 91 0b 06 	lds	r18, 0x060B
     b5c:	30 91 0c 06 	lds	r19, 0x060C
     b60:	84 e6       	ldi	r24, 0x64	; 100
     b62:	90 e0       	ldi	r25, 0x00	; 0
     b64:	ac 01       	movw	r20, r24
     b66:	24 9f       	mul	r18, r20
     b68:	c0 01       	movw	r24, r0
     b6a:	25 9f       	mul	r18, r21
     b6c:	90 0d       	add	r25, r0
     b6e:	34 9f       	mul	r19, r20
     b70:	90 0d       	add	r25, r0
     b72:	11 24       	eor	r1, r1
     b74:	2c eb       	ldi	r18, 0xBC	; 188
     b76:	32 e0       	ldi	r19, 0x02	; 2
     b78:	b9 01       	movw	r22, r18
     b7a:	0e 94 60 27 	call	0x4ec0	; 0x4ec0 <__udivmodhi4>
     b7e:	cb 01       	movw	r24, r22
     b80:	80 93 07 06 	sts	0x0607, r24
	/*	Display Soil Moisture value in LCD	*/
	if(Global_Soil_percent<10)
     b84:	80 91 07 06 	lds	r24, 0x0607
     b88:	8a 30       	cpi	r24, 0x0A	; 10
     b8a:	e8 f4       	brcc	.+58     	; 0xbc6 <soil_moisture_sensor_ISR+0x80>
	{
		LCD_SetCursor(0,9);
     b8c:	80 e0       	ldi	r24, 0x00	; 0
     b8e:	69 e0       	ldi	r22, 0x09	; 9
     b90:	0e 94 a3 11 	call	0x2346	; 0x2346 <LCD_SetCursor>
		LCD_voidWriteNumber(Global_Soil_percent);
     b94:	80 91 07 06 	lds	r24, 0x0607
     b98:	88 2f       	mov	r24, r24
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a0 e0       	ldi	r26, 0x00	; 0
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	bc 01       	movw	r22, r24
     ba2:	cd 01       	movw	r24, r26
     ba4:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <LCD_voidWriteNumber>
		LCD_SetCursor(0,10);
     ba8:	80 e0       	ldi	r24, 0x00	; 0
     baa:	6a e0       	ldi	r22, 0x0A	; 10
     bac:	0e 94 a3 11 	call	0x2346	; 0x2346 <LCD_SetCursor>
		LCD_voidWriteChar('%');
     bb0:	85 e2       	ldi	r24, 0x25	; 37
     bb2:	0e 94 96 11 	call	0x232c	; 0x232c <LCD_voidWriteChar>
		LCD_SetCursor(0,11);
     bb6:	80 e0       	ldi	r24, 0x00	; 0
     bb8:	6b e0       	ldi	r22, 0x0B	; 11
     bba:	0e 94 a3 11 	call	0x2346	; 0x2346 <LCD_SetCursor>
		LCD_voidWriteChar(' ');
     bbe:	80 e2       	ldi	r24, 0x20	; 32
     bc0:	0e 94 96 11 	call	0x232c	; 0x232c <LCD_voidWriteChar>
     bc4:	19 c0       	rjmp	.+50     	; 0xbf8 <soil_moisture_sensor_ISR+0xb2>
	}
	else if(Global_Soil_percent<100)
     bc6:	80 91 07 06 	lds	r24, 0x0607
     bca:	84 36       	cpi	r24, 0x64	; 100
     bcc:	a8 f4       	brcc	.+42     	; 0xbf8 <soil_moisture_sensor_ISR+0xb2>
	{
		LCD_SetCursor(0,9);
     bce:	80 e0       	ldi	r24, 0x00	; 0
     bd0:	69 e0       	ldi	r22, 0x09	; 9
     bd2:	0e 94 a3 11 	call	0x2346	; 0x2346 <LCD_SetCursor>
		LCD_voidWriteNumber(Global_Soil_percent);
     bd6:	80 91 07 06 	lds	r24, 0x0607
     bda:	88 2f       	mov	r24, r24
     bdc:	90 e0       	ldi	r25, 0x00	; 0
     bde:	a0 e0       	ldi	r26, 0x00	; 0
     be0:	b0 e0       	ldi	r27, 0x00	; 0
     be2:	bc 01       	movw	r22, r24
     be4:	cd 01       	movw	r24, r26
     be6:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <LCD_voidWriteNumber>
		LCD_SetCursor(0,11);
     bea:	80 e0       	ldi	r24, 0x00	; 0
     bec:	6b e0       	ldi	r22, 0x0B	; 11
     bee:	0e 94 a3 11 	call	0x2346	; 0x2346 <LCD_SetCursor>
		LCD_voidWriteChar('%');
     bf2:	85 e2       	ldi	r24, 0x25	; 37
     bf4:	0e 94 96 11 	call	0x232c	; 0x232c <LCD_voidWriteChar>
	}

	/*	Set the MSB	*/
	Local_NewData = (Global_Soil_percent | 128);
     bf8:	80 91 07 06 	lds	r24, 0x0607
     bfc:	80 68       	ori	r24, 0x80	; 128
     bfe:	89 83       	std	Y+1, r24	; 0x01

	/*	Send the Data to Gateway	*/
	USART_Transmitter(Local_NewData);
     c00:	89 81       	ldd	r24, Y+1	; 0x01
     c02:	0e 94 bc 07 	call	0xf78	; 0xf78 <USART_Transmitter>

		/*	Turn the sensor off	*/
	DIO_SETPinValue(PORTA_ID,PIN4_ID,LOW);
     c06:	80 e0       	ldi	r24, 0x00	; 0
     c08:	64 e0       	ldi	r22, 0x04	; 4
     c0a:	40 e0       	ldi	r20, 0x00	; 0
     c0c:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>

	/*	Give the Semaphore	*/
	(void)xSemaphoreGive(Sem);
     c10:	80 91 0d 06 	lds	r24, 0x060D
     c14:	90 91 0e 06 	lds	r25, 0x060E
     c18:	60 e0       	ldi	r22, 0x00	; 0
     c1a:	70 e0       	ldi	r23, 0x00	; 0
     c1c:	40 e0       	ldi	r20, 0x00	; 0
     c1e:	50 e0       	ldi	r21, 0x00	; 0
     c20:	20 e0       	ldi	r18, 0x00	; 0
     c22:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <xQueueGenericSend>
}
     c26:	0f 90       	pop	r0
     c28:	cf 91       	pop	r28
     c2a:	df 91       	pop	r29
     c2c:	08 95       	ret

00000c2e <soil_moisture_sensor>:

void soil_moisture_sensor(void)
{
     c2e:	df 93       	push	r29
     c30:	cf 93       	push	r28
     c32:	0f 92       	push	r0
     c34:	cd b7       	in	r28, 0x3d	; 61
     c36:	de b7       	in	r29, 0x3e	; 62
	u8 SemState ;

	while(1)
	{
		SemState=xSemaphoreTake(Sem,10);
     c38:	80 91 0d 06 	lds	r24, 0x060D
     c3c:	90 91 0e 06 	lds	r25, 0x060E
     c40:	60 e0       	ldi	r22, 0x00	; 0
     c42:	70 e0       	ldi	r23, 0x00	; 0
     c44:	4a e0       	ldi	r20, 0x0A	; 10
     c46:	50 e0       	ldi	r21, 0x00	; 0
     c48:	20 e0       	ldi	r18, 0x00	; 0
     c4a:	0e 94 47 1b 	call	0x368e	; 0x368e <xQueueGenericReceive>
     c4e:	89 83       	std	Y+1, r24	; 0x01
		if(SemState==pdPASS)
     c50:	89 81       	ldd	r24, Y+1	; 0x01
     c52:	81 30       	cpi	r24, 0x01	; 1
     c54:	69 f4       	brne	.+26     	; 0xc70 <soil_moisture_sensor+0x42>
		{
			/*	Turn the Soil Moisture sensor on	*/
			DIO_SETPinValue(PORTA_ID,PIN4_ID,HIGH);
     c56:	80 e0       	ldi	r24, 0x00	; 0
     c58:	64 e0       	ldi	r22, 0x04	; 4
     c5a:	41 e0       	ldi	r20, 0x01	; 1
     c5c:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>

			/*	Start Conversion of Soil Moisture sensor	*/
			ADC_StartConversion(&Global_SoilMoisture_Data);
     c60:	8b e0       	ldi	r24, 0x0B	; 11
     c62:	96 e0       	ldi	r25, 0x06	; 6
     c64:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <ADC_StartConversion>

			/*	ADC Call ISR	*/
			ADC_voidSetCallBack(soil_moisture_sensor_ISR);
     c68:	83 ea       	ldi	r24, 0xA3	; 163
     c6a:	95 e0       	ldi	r25, 0x05	; 5
     c6c:	0e 94 20 0c 	call	0x1840	; 0x1840 <ADC_voidSetCallBack>
		else
		{
			/* Do nothing */
		}

		vTaskDelay(3000);
     c70:	88 eb       	ldi	r24, 0xB8	; 184
     c72:	9b e0       	ldi	r25, 0x0B	; 11
     c74:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <vTaskDelay>
     c78:	df cf       	rjmp	.-66     	; 0xc38 <soil_moisture_sensor+0xa>

00000c7a <water_level_sensor>:
	}
}

void water_level_sensor(void)
{
     c7a:	df 93       	push	r29
     c7c:	cf 93       	push	r28
     c7e:	0f 92       	push	r0
     c80:	cd b7       	in	r28, 0x3d	; 61
     c82:	de b7       	in	r29, 0x3e	; 62
	u8 SemState ;
	while(1)
	{
		SemState=xSemaphoreTake(Sem,10);
     c84:	80 91 0d 06 	lds	r24, 0x060D
     c88:	90 91 0e 06 	lds	r25, 0x060E
     c8c:	60 e0       	ldi	r22, 0x00	; 0
     c8e:	70 e0       	ldi	r23, 0x00	; 0
     c90:	4a e0       	ldi	r20, 0x0A	; 10
     c92:	50 e0       	ldi	r21, 0x00	; 0
     c94:	20 e0       	ldi	r18, 0x00	; 0
     c96:	0e 94 47 1b 	call	0x368e	; 0x368e <xQueueGenericReceive>
     c9a:	89 83       	std	Y+1, r24	; 0x01
		if(SemState==pdPASS)
     c9c:	89 81       	ldd	r24, Y+1	; 0x01
     c9e:	81 30       	cpi	r24, 0x01	; 1
     ca0:	69 f4       	brne	.+26     	; 0xcbc <water_level_sensor+0x42>
		{
			/*	Turn the Soil Moisture sensor on	*/
			DIO_SETPinValue(PORTA_ID,PIN6_ID,HIGH);
     ca2:	80 e0       	ldi	r24, 0x00	; 0
     ca4:	66 e0       	ldi	r22, 0x06	; 6
     ca6:	41 e0       	ldi	r20, 0x01	; 1
     ca8:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>

			/*	Start Conversion of Soil Moisture sensor	*/
			ADC_StartConversion(&Global_WaterLevel_Data);
     cac:	89 e0       	ldi	r24, 0x09	; 9
     cae:	96 e0       	ldi	r25, 0x06	; 6
     cb0:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <ADC_StartConversion>

			/*	ADC Call ISR	*/
			ADC_voidSetCallBack(water_level_sensor_ISR);
     cb4:	83 e6       	ldi	r24, 0x63	; 99
     cb6:	96 e0       	ldi	r25, 0x06	; 6
     cb8:	0e 94 20 0c 	call	0x1840	; 0x1840 <ADC_voidSetCallBack>
		else
		{
			/* Do nothing */
		}

		vTaskDelay(3000);
     cbc:	88 eb       	ldi	r24, 0xB8	; 184
     cbe:	9b e0       	ldi	r25, 0x0B	; 11
     cc0:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <vTaskDelay>
     cc4:	df cf       	rjmp	.-66     	; 0xc84 <water_level_sensor+0xa>

00000cc6 <water_level_sensor_ISR>:
	}
}

void water_level_sensor_ISR(void)
{
     cc6:	df 93       	push	r29
     cc8:	cf 93       	push	r28
     cca:	0f 92       	push	r0
     ccc:	cd b7       	in	r28, 0x3d	; 61
     cce:	de b7       	in	r29, 0x3e	; 62
	/*	Local Variable for new value of Global_Soil_percent	*/
	u8 Local_NewData=0;
     cd0:	19 82       	std	Y+1, r1	; 0x01

	/*	ADC Channel Select for water_leve_sensor	*/
	ADC_voidChannelSellect(7);
     cd2:	87 e0       	ldi	r24, 0x07	; 7
     cd4:	0e 94 e1 0b 	call	0x17c2	; 0x17c2 <ADC_voidChannelSellect>

	Global_WaterLevel_percent=(Global_WaterLevel_Data*100)/700;
     cd8:	20 91 09 06 	lds	r18, 0x0609
     cdc:	30 91 0a 06 	lds	r19, 0x060A
     ce0:	84 e6       	ldi	r24, 0x64	; 100
     ce2:	90 e0       	ldi	r25, 0x00	; 0
     ce4:	ac 01       	movw	r20, r24
     ce6:	24 9f       	mul	r18, r20
     ce8:	c0 01       	movw	r24, r0
     cea:	25 9f       	mul	r18, r21
     cec:	90 0d       	add	r25, r0
     cee:	34 9f       	mul	r19, r20
     cf0:	90 0d       	add	r25, r0
     cf2:	11 24       	eor	r1, r1
     cf4:	2c eb       	ldi	r18, 0xBC	; 188
     cf6:	32 e0       	ldi	r19, 0x02	; 2
     cf8:	b9 01       	movw	r22, r18
     cfa:	0e 94 60 27 	call	0x4ec0	; 0x4ec0 <__udivmodhi4>
     cfe:	cb 01       	movw	r24, r22
     d00:	80 93 08 06 	sts	0x0608, r24

		/*	Display Soil Moisture value in LCD	*/
	if(Global_WaterLevel_percent<10)
     d04:	80 91 08 06 	lds	r24, 0x0608
     d08:	8a 30       	cpi	r24, 0x0A	; 10
     d0a:	e8 f4       	brcc	.+58     	; 0xd46 <water_level_sensor_ISR+0x80>
	{
		LCD_SetCursor(1,12);
     d0c:	81 e0       	ldi	r24, 0x01	; 1
     d0e:	6c e0       	ldi	r22, 0x0C	; 12
     d10:	0e 94 a3 11 	call	0x2346	; 0x2346 <LCD_SetCursor>
		LCD_voidWriteNumber(Global_WaterLevel_percent);
     d14:	80 91 08 06 	lds	r24, 0x0608
     d18:	88 2f       	mov	r24, r24
     d1a:	90 e0       	ldi	r25, 0x00	; 0
     d1c:	a0 e0       	ldi	r26, 0x00	; 0
     d1e:	b0 e0       	ldi	r27, 0x00	; 0
     d20:	bc 01       	movw	r22, r24
     d22:	cd 01       	movw	r24, r26
     d24:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <LCD_voidWriteNumber>
		LCD_SetCursor(1,13);
     d28:	81 e0       	ldi	r24, 0x01	; 1
     d2a:	6d e0       	ldi	r22, 0x0D	; 13
     d2c:	0e 94 a3 11 	call	0x2346	; 0x2346 <LCD_SetCursor>
		LCD_voidWriteChar('%');
     d30:	85 e2       	ldi	r24, 0x25	; 37
     d32:	0e 94 96 11 	call	0x232c	; 0x232c <LCD_voidWriteChar>
		LCD_SetCursor(1,14);
     d36:	81 e0       	ldi	r24, 0x01	; 1
     d38:	6e e0       	ldi	r22, 0x0E	; 14
     d3a:	0e 94 a3 11 	call	0x2346	; 0x2346 <LCD_SetCursor>
		LCD_voidWriteChar(' ');
     d3e:	80 e2       	ldi	r24, 0x20	; 32
     d40:	0e 94 96 11 	call	0x232c	; 0x232c <LCD_voidWriteChar>
     d44:	19 c0       	rjmp	.+50     	; 0xd78 <water_level_sensor_ISR+0xb2>
	}
	else if(Global_WaterLevel_percent<100)
     d46:	80 91 08 06 	lds	r24, 0x0608
     d4a:	84 36       	cpi	r24, 0x64	; 100
     d4c:	a8 f4       	brcc	.+42     	; 0xd78 <water_level_sensor_ISR+0xb2>
	{
		LCD_SetCursor(1,12);
     d4e:	81 e0       	ldi	r24, 0x01	; 1
     d50:	6c e0       	ldi	r22, 0x0C	; 12
     d52:	0e 94 a3 11 	call	0x2346	; 0x2346 <LCD_SetCursor>
		LCD_voidWriteNumber(Global_WaterLevel_percent);
     d56:	80 91 08 06 	lds	r24, 0x0608
     d5a:	88 2f       	mov	r24, r24
     d5c:	90 e0       	ldi	r25, 0x00	; 0
     d5e:	a0 e0       	ldi	r26, 0x00	; 0
     d60:	b0 e0       	ldi	r27, 0x00	; 0
     d62:	bc 01       	movw	r22, r24
     d64:	cd 01       	movw	r24, r26
     d66:	0e 94 d4 11 	call	0x23a8	; 0x23a8 <LCD_voidWriteNumber>
		LCD_SetCursor(1,14);
     d6a:	81 e0       	ldi	r24, 0x01	; 1
     d6c:	6e e0       	ldi	r22, 0x0E	; 14
     d6e:	0e 94 a3 11 	call	0x2346	; 0x2346 <LCD_SetCursor>
		LCD_voidWriteChar('%');
     d72:	85 e2       	ldi	r24, 0x25	; 37
     d74:	0e 94 96 11 	call	0x232c	; 0x232c <LCD_voidWriteChar>
	}

	/*	Clear the MSB	*/
	Local_NewData = (Global_WaterLevel_percent & 127);
     d78:	80 91 08 06 	lds	r24, 0x0608
     d7c:	8f 77       	andi	r24, 0x7F	; 127
     d7e:	89 83       	std	Y+1, r24	; 0x01

	/*	Send the Data to Gateway	*/
	USART_Transmitter(Local_NewData);
     d80:	89 81       	ldd	r24, Y+1	; 0x01
     d82:	0e 94 bc 07 	call	0xf78	; 0xf78 <USART_Transmitter>

		/*	Turn the sensor off	*/
	DIO_SETPinValue(PORTA_ID,PIN6_ID,LOW);
     d86:	80 e0       	ldi	r24, 0x00	; 0
     d88:	66 e0       	ldi	r22, 0x06	; 6
     d8a:	40 e0       	ldi	r20, 0x00	; 0
     d8c:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>

	/*	Give the Semaphore	*/
	(void)xSemaphoreGive(Sem);
     d90:	80 91 0d 06 	lds	r24, 0x060D
     d94:	90 91 0e 06 	lds	r25, 0x060E
     d98:	60 e0       	ldi	r22, 0x00	; 0
     d9a:	70 e0       	ldi	r23, 0x00	; 0
     d9c:	40 e0       	ldi	r20, 0x00	; 0
     d9e:	50 e0       	ldi	r21, 0x00	; 0
     da0:	20 e0       	ldi	r18, 0x00	; 0
     da2:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <xQueueGenericSend>
}
     da6:	0f 90       	pop	r0
     da8:	cf 91       	pop	r28
     daa:	df 91       	pop	r29
     dac:	08 95       	ret

00000dae <Pump>:


void Pump(void)
{
     dae:	df 93       	push	r29
     db0:	cf 93       	push	r28
     db2:	0f 92       	push	r0
     db4:	cd b7       	in	r28, 0x3d	; 61
     db6:	de b7       	in	r29, 0x3e	; 62
	u8 SemState ;

	while(1)
	{
		SemState=xSemaphoreTake(Sem,10);
     db8:	80 91 0d 06 	lds	r24, 0x060D
     dbc:	90 91 0e 06 	lds	r25, 0x060E
     dc0:	60 e0       	ldi	r22, 0x00	; 0
     dc2:	70 e0       	ldi	r23, 0x00	; 0
     dc4:	4a e0       	ldi	r20, 0x0A	; 10
     dc6:	50 e0       	ldi	r21, 0x00	; 0
     dc8:	20 e0       	ldi	r18, 0x00	; 0
     dca:	0e 94 47 1b 	call	0x368e	; 0x368e <xQueueGenericReceive>
     dce:	89 83       	std	Y+1, r24	; 0x01
		if(SemState==pdPASS)
     dd0:	89 81       	ldd	r24, Y+1	; 0x01
     dd2:	81 30       	cpi	r24, 0x01	; 1
     dd4:	79 f4       	brne	.+30     	; 0xdf4 <Pump+0x46>
		{
			/********	Motor Status	********/
			if(Global_Soil_percent>=70)
     dd6:	80 91 07 06 	lds	r24, 0x0607
     dda:	86 34       	cpi	r24, 0x46	; 70
     ddc:	30 f0       	brcs	.+12     	; 0xdea <Pump+0x3c>
			{
				DIO_SETPinValue(PORTC_ID,PIN7_ID,HIGH);
     dde:	82 e0       	ldi	r24, 0x02	; 2
     de0:	67 e0       	ldi	r22, 0x07	; 7
     de2:	41 e0       	ldi	r20, 0x01	; 1
     de4:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
     de8:	05 c0       	rjmp	.+10     	; 0xdf4 <Pump+0x46>
			}
			else
			{
				DIO_SETPinValue(PORTC_ID,PIN7_ID,LOW);
     dea:	82 e0       	ldi	r24, 0x02	; 2
     dec:	67 e0       	ldi	r22, 0x07	; 7
     dee:	40 e0       	ldi	r20, 0x00	; 0
     df0:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
		else
		{
			/* Do nothing */
		}
		/*	Give the Semaphore	*/
		(void)xSemaphoreGive(Sem);
     df4:	80 91 0d 06 	lds	r24, 0x060D
     df8:	90 91 0e 06 	lds	r25, 0x060E
     dfc:	60 e0       	ldi	r22, 0x00	; 0
     dfe:	70 e0       	ldi	r23, 0x00	; 0
     e00:	40 e0       	ldi	r20, 0x00	; 0
     e02:	50 e0       	ldi	r21, 0x00	; 0
     e04:	20 e0       	ldi	r18, 0x00	; 0
     e06:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <xQueueGenericSend>

		vTaskDelay(4000);
     e0a:	80 ea       	ldi	r24, 0xA0	; 160
     e0c:	9f e0       	ldi	r25, 0x0F	; 15
     e0e:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <vTaskDelay>
     e12:	d2 cf       	rjmp	.-92     	; 0xdb8 <Pump+0xa>

00000e14 <Buzzer>:
	}
}

void Buzzer(void)
{
     e14:	df 93       	push	r29
     e16:	cf 93       	push	r28
     e18:	0f 92       	push	r0
     e1a:	cd b7       	in	r28, 0x3d	; 61
     e1c:	de b7       	in	r29, 0x3e	; 62
	u8 SemState ;

	while(1)
	{
		SemState=xSemaphoreTake(Sem,10);
     e1e:	80 91 0d 06 	lds	r24, 0x060D
     e22:	90 91 0e 06 	lds	r25, 0x060E
     e26:	60 e0       	ldi	r22, 0x00	; 0
     e28:	70 e0       	ldi	r23, 0x00	; 0
     e2a:	4a e0       	ldi	r20, 0x0A	; 10
     e2c:	50 e0       	ldi	r21, 0x00	; 0
     e2e:	20 e0       	ldi	r18, 0x00	; 0
     e30:	0e 94 47 1b 	call	0x368e	; 0x368e <xQueueGenericReceive>
     e34:	89 83       	std	Y+1, r24	; 0x01
		if(SemState==pdPASS)
     e36:	89 81       	ldd	r24, Y+1	; 0x01
     e38:	81 30       	cpi	r24, 0x01	; 1
     e3a:	79 f4       	brne	.+30     	; 0xe5a <Buzzer+0x46>
		{
			/*	Buzzer Status	*/
			if(15 >= Global_WaterLevel_percent)
     e3c:	80 91 08 06 	lds	r24, 0x0608
     e40:	80 31       	cpi	r24, 0x10	; 16
     e42:	30 f4       	brcc	.+12     	; 0xe50 <Buzzer+0x3c>
			{
				DIO_SETPinValue(PORTC_ID,PIN6_ID,HIGH);
     e44:	82 e0       	ldi	r24, 0x02	; 2
     e46:	66 e0       	ldi	r22, 0x06	; 6
     e48:	41 e0       	ldi	r20, 0x01	; 1
     e4a:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
     e4e:	05 c0       	rjmp	.+10     	; 0xe5a <Buzzer+0x46>
			}
			else
			{
				DIO_SETPinValue(PORTC_ID,PIN6_ID,LOW);
     e50:	82 e0       	ldi	r24, 0x02	; 2
     e52:	66 e0       	ldi	r22, 0x06	; 6
     e54:	40 e0       	ldi	r20, 0x00	; 0
     e56:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
		else
		{
			/* Do nothing */
		}
		/*	Give the Semaphore	*/
		(void)xSemaphoreGive(Sem);
     e5a:	80 91 0d 06 	lds	r24, 0x060D
     e5e:	90 91 0e 06 	lds	r25, 0x060E
     e62:	60 e0       	ldi	r22, 0x00	; 0
     e64:	70 e0       	ldi	r23, 0x00	; 0
     e66:	40 e0       	ldi	r20, 0x00	; 0
     e68:	50 e0       	ldi	r21, 0x00	; 0
     e6a:	20 e0       	ldi	r18, 0x00	; 0
     e6c:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <xQueueGenericSend>

		vTaskDelay(4000);
     e70:	80 ea       	ldi	r24, 0xA0	; 160
     e72:	9f e0       	ldi	r25, 0x0F	; 15
     e74:	0e 94 f8 1f 	call	0x3ff0	; 0x3ff0 <vTaskDelay>
     e78:	d2 cf       	rjmp	.-92     	; 0xe1e <Buzzer+0xa>

00000e7a <USART_INIT>:
#include "../../LIB/STD_TYPES.h"
#include "USRT_Interface.h"
#include "USAR_Private.h"

void USART_INIT(u16 baud)
{
     e7a:	0f 93       	push	r16
     e7c:	1f 93       	push	r17
     e7e:	df 93       	push	r29
     e80:	cf 93       	push	r28
     e82:	00 d0       	rcall	.+0      	; 0xe84 <USART_INIT+0xa>
     e84:	0f 92       	push	r0
     e86:	cd b7       	in	r28, 0x3d	; 61
     e88:	de b7       	in	r29, 0x3e	; 62
     e8a:	9b 83       	std	Y+3, r25	; 0x03
     e8c:	8a 83       	std	Y+2, r24	; 0x02
	/*Atomic access (must to set or reset the bits then = to register)*/
	u8 local_UCSRC ;

	/* Set baud rate */
	UBRRH = (u8)(BAUD_PRESCALE>>8);
     e8e:	00 e4       	ldi	r16, 0x40	; 64
     e90:	10 e0       	ldi	r17, 0x00	; 0
     e92:	8a 81       	ldd	r24, Y+2	; 0x02
     e94:	9b 81       	ldd	r25, Y+3	; 0x03
     e96:	cc 01       	movw	r24, r24
     e98:	a0 e0       	ldi	r26, 0x00	; 0
     e9a:	b0 e0       	ldi	r27, 0x00	; 0
     e9c:	88 0f       	add	r24, r24
     e9e:	99 1f       	adc	r25, r25
     ea0:	aa 1f       	adc	r26, r26
     ea2:	bb 1f       	adc	r27, r27
     ea4:	88 0f       	add	r24, r24
     ea6:	99 1f       	adc	r25, r25
     ea8:	aa 1f       	adc	r26, r26
     eaa:	bb 1f       	adc	r27, r27
     eac:	88 0f       	add	r24, r24
     eae:	99 1f       	adc	r25, r25
     eb0:	aa 1f       	adc	r26, r26
     eb2:	bb 1f       	adc	r27, r27
     eb4:	88 0f       	add	r24, r24
     eb6:	99 1f       	adc	r25, r25
     eb8:	aa 1f       	adc	r26, r26
     eba:	bb 1f       	adc	r27, r27
     ebc:	9c 01       	movw	r18, r24
     ebe:	ad 01       	movw	r20, r26
     ec0:	80 e0       	ldi	r24, 0x00	; 0
     ec2:	94 e2       	ldi	r25, 0x24	; 36
     ec4:	a4 ef       	ldi	r26, 0xF4	; 244
     ec6:	b0 e0       	ldi	r27, 0x00	; 0
     ec8:	bc 01       	movw	r22, r24
     eca:	cd 01       	movw	r24, r26
     ecc:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <__udivmodsi4>
     ed0:	da 01       	movw	r26, r20
     ed2:	c9 01       	movw	r24, r18
     ed4:	01 97       	sbiw	r24, 0x01	; 1
     ed6:	a1 09       	sbc	r26, r1
     ed8:	b1 09       	sbc	r27, r1
     eda:	89 2f       	mov	r24, r25
     edc:	9a 2f       	mov	r25, r26
     ede:	ab 2f       	mov	r26, r27
     ee0:	bb 27       	eor	r27, r27
     ee2:	f8 01       	movw	r30, r16
     ee4:	80 83       	st	Z, r24
	UBRRL = (u8)BAUD_PRESCALE;
     ee6:	09 e2       	ldi	r16, 0x29	; 41
     ee8:	10 e0       	ldi	r17, 0x00	; 0
     eea:	8a 81       	ldd	r24, Y+2	; 0x02
     eec:	9b 81       	ldd	r25, Y+3	; 0x03
     eee:	cc 01       	movw	r24, r24
     ef0:	a0 e0       	ldi	r26, 0x00	; 0
     ef2:	b0 e0       	ldi	r27, 0x00	; 0
     ef4:	88 0f       	add	r24, r24
     ef6:	99 1f       	adc	r25, r25
     ef8:	aa 1f       	adc	r26, r26
     efa:	bb 1f       	adc	r27, r27
     efc:	88 0f       	add	r24, r24
     efe:	99 1f       	adc	r25, r25
     f00:	aa 1f       	adc	r26, r26
     f02:	bb 1f       	adc	r27, r27
     f04:	88 0f       	add	r24, r24
     f06:	99 1f       	adc	r25, r25
     f08:	aa 1f       	adc	r26, r26
     f0a:	bb 1f       	adc	r27, r27
     f0c:	88 0f       	add	r24, r24
     f0e:	99 1f       	adc	r25, r25
     f10:	aa 1f       	adc	r26, r26
     f12:	bb 1f       	adc	r27, r27
     f14:	9c 01       	movw	r18, r24
     f16:	ad 01       	movw	r20, r26
     f18:	80 e0       	ldi	r24, 0x00	; 0
     f1a:	94 e2       	ldi	r25, 0x24	; 36
     f1c:	a4 ef       	ldi	r26, 0xF4	; 244
     f1e:	b0 e0       	ldi	r27, 0x00	; 0
     f20:	bc 01       	movw	r22, r24
     f22:	cd 01       	movw	r24, r26
     f24:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <__udivmodsi4>
     f28:	da 01       	movw	r26, r20
     f2a:	c9 01       	movw	r24, r18
     f2c:	81 50       	subi	r24, 0x01	; 1
     f2e:	f8 01       	movw	r30, r16
     f30:	80 83       	st	Z, r24

	/* Enable receiver and transmitter */
	SET_BIT(UCSRB,UCSRB_RXEN);
     f32:	aa e2       	ldi	r26, 0x2A	; 42
     f34:	b0 e0       	ldi	r27, 0x00	; 0
     f36:	ea e2       	ldi	r30, 0x2A	; 42
     f38:	f0 e0       	ldi	r31, 0x00	; 0
     f3a:	80 81       	ld	r24, Z
     f3c:	80 61       	ori	r24, 0x10	; 16
     f3e:	8c 93       	st	X, r24
	SET_BIT(UCSRB,UCSRB_TXEN);
     f40:	aa e2       	ldi	r26, 0x2A	; 42
     f42:	b0 e0       	ldi	r27, 0x00	; 0
     f44:	ea e2       	ldi	r30, 0x2A	; 42
     f46:	f0 e0       	ldi	r31, 0x00	; 0
     f48:	80 81       	ld	r24, Z
     f4a:	88 60       	ori	r24, 0x08	; 8
     f4c:	8c 93       	st	X, r24

	//UCSRB = (1<<UCSRB_RXEN)|(1<<UCSRB_TXEN);

	/* Set frame format: 8data, 2stop bit */
	SET_BIT(local_UCSRC,UCSRC_URSEL);   //to choice UCSRC register not UBRRH Register
     f4e:	89 81       	ldd	r24, Y+1	; 0x01
     f50:	80 68       	ori	r24, 0x80	; 128
     f52:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(local_UCSRC,UCSRC_UCSZ1);
     f54:	89 81       	ldd	r24, Y+1	; 0x01
     f56:	84 60       	ori	r24, 0x04	; 4
     f58:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(local_UCSRC,UCSRC_UCSZ0);
     f5a:	89 81       	ldd	r24, Y+1	; 0x01
     f5c:	82 60       	ori	r24, 0x02	; 2
     f5e:	89 83       	std	Y+1, r24	; 0x01
	/*atomic access(bytes access) should access the whole register not by bit*/
	UCSRC = local_UCSRC;
     f60:	e0 e4       	ldi	r30, 0x40	; 64
     f62:	f0 e0       	ldi	r31, 0x00	; 0
     f64:	89 81       	ldd	r24, Y+1	; 0x01
     f66:	80 83       	st	Z, r24

}
     f68:	0f 90       	pop	r0
     f6a:	0f 90       	pop	r0
     f6c:	0f 90       	pop	r0
     f6e:	cf 91       	pop	r28
     f70:	df 91       	pop	r29
     f72:	1f 91       	pop	r17
     f74:	0f 91       	pop	r16
     f76:	08 95       	ret

00000f78 <USART_Transmitter>:

void USART_Transmitter(u8 data)
{
     f78:	df 93       	push	r29
     f7a:	cf 93       	push	r28
     f7c:	0f 92       	push	r0
     f7e:	cd b7       	in	r28, 0x3d	; 61
     f80:	de b7       	in	r29, 0x3e	; 62
     f82:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	//pollig on UCSRA_UDRE pin to be sure it is empty
	//while ( !( UCSRA & (1<<UCSRA_UDRE)) );
	while (GET_BIT(UCSRA,UCSRA_UDRE) == 0);
     f84:	eb e2       	ldi	r30, 0x2B	; 43
     f86:	f0 e0       	ldi	r31, 0x00	; 0
     f88:	80 81       	ld	r24, Z
     f8a:	82 95       	swap	r24
     f8c:	86 95       	lsr	r24
     f8e:	87 70       	andi	r24, 0x07	; 7
     f90:	88 2f       	mov	r24, r24
     f92:	90 e0       	ldi	r25, 0x00	; 0
     f94:	81 70       	andi	r24, 0x01	; 1
     f96:	90 70       	andi	r25, 0x00	; 0
     f98:	00 97       	sbiw	r24, 0x00	; 0
     f9a:	a1 f3       	breq	.-24     	; 0xf84 <USART_Transmitter+0xc>

	/* Put data into buffer, sends the data */
	UDR = data;          //TX to write data
     f9c:	ec e2       	ldi	r30, 0x2C	; 44
     f9e:	f0 e0       	ldi	r31, 0x00	; 0
     fa0:	89 81       	ldd	r24, Y+1	; 0x01
     fa2:	80 83       	st	Z, r24

}
     fa4:	0f 90       	pop	r0
     fa6:	cf 91       	pop	r28
     fa8:	df 91       	pop	r29
     faa:	08 95       	ret

00000fac <USART_Receive>:

u8 USART_Receive( void )
{
     fac:	df 93       	push	r29
     fae:	cf 93       	push	r28
     fb0:	cd b7       	in	r28, 0x3d	; 61
     fb2:	de b7       	in	r29, 0x3e	; 62
/* Wait for data to be received */
	//while ( ! (UCSRA & (1<<UCSRA_RXC)) );
	while(GET_BIT(UCSRA,UCSRA_RXC) == 0);
     fb4:	eb e2       	ldi	r30, 0x2B	; 43
     fb6:	f0 e0       	ldi	r31, 0x00	; 0
     fb8:	80 81       	ld	r24, Z
     fba:	88 23       	and	r24, r24
     fbc:	dc f7       	brge	.-10     	; 0xfb4 <USART_Receive+0x8>

/* Get and return received data from buffer */
	return UDR;
     fbe:	ec e2       	ldi	r30, 0x2C	; 44
     fc0:	f0 e0       	ldi	r31, 0x00	; 0
     fc2:	80 81       	ld	r24, Z
}
     fc4:	cf 91       	pop	r28
     fc6:	df 91       	pop	r29
     fc8:	08 95       	ret

00000fca <USART_SendString>:

void USART_SendString(char *str)
{
     fca:	df 93       	push	r29
     fcc:	cf 93       	push	r28
     fce:	00 d0       	rcall	.+0      	; 0xfd0 <USART_SendString+0x6>
     fd0:	0f 92       	push	r0
     fd2:	cd b7       	in	r28, 0x3d	; 61
     fd4:	de b7       	in	r29, 0x3e	; 62
     fd6:	9b 83       	std	Y+3, r25	; 0x03
     fd8:	8a 83       	std	Y+2, r24	; 0x02
	unsigned char j=0;
     fda:	19 82       	std	Y+1, r1	; 0x01
     fdc:	0e c0       	rjmp	.+28     	; 0xffa <USART_SendString+0x30>

	while (str[j]!=0)		/* Send string till null */
	{
		USART_Transmitter(str[j]);
     fde:	89 81       	ldd	r24, Y+1	; 0x01
     fe0:	28 2f       	mov	r18, r24
     fe2:	30 e0       	ldi	r19, 0x00	; 0
     fe4:	8a 81       	ldd	r24, Y+2	; 0x02
     fe6:	9b 81       	ldd	r25, Y+3	; 0x03
     fe8:	fc 01       	movw	r30, r24
     fea:	e2 0f       	add	r30, r18
     fec:	f3 1f       	adc	r31, r19
     fee:	80 81       	ld	r24, Z
     ff0:	0e 94 bc 07 	call	0xf78	; 0xf78 <USART_Transmitter>
		j++;
     ff4:	89 81       	ldd	r24, Y+1	; 0x01
     ff6:	8f 5f       	subi	r24, 0xFF	; 255
     ff8:	89 83       	std	Y+1, r24	; 0x01

void USART_SendString(char *str)
{
	unsigned char j=0;

	while (str[j]!=0)		/* Send string till null */
     ffa:	89 81       	ldd	r24, Y+1	; 0x01
     ffc:	28 2f       	mov	r18, r24
     ffe:	30 e0       	ldi	r19, 0x00	; 0
    1000:	8a 81       	ldd	r24, Y+2	; 0x02
    1002:	9b 81       	ldd	r25, Y+3	; 0x03
    1004:	fc 01       	movw	r30, r24
    1006:	e2 0f       	add	r30, r18
    1008:	f3 1f       	adc	r31, r19
    100a:	80 81       	ld	r24, Z
    100c:	88 23       	and	r24, r24
    100e:	39 f7       	brne	.-50     	; 0xfde <USART_SendString+0x14>
	{
		USART_Transmitter(str[j]);
		j++;
	}
}
    1010:	0f 90       	pop	r0
    1012:	0f 90       	pop	r0
    1014:	0f 90       	pop	r0
    1016:	cf 91       	pop	r28
    1018:	df 91       	pop	r29
    101a:	08 95       	ret

0000101c <GIE_VoidEnable>:
#include "../../LIB/STD_TYPES.h"
#include "../../LIB/BIT_MATH.h"
#include "GIE_Private.h"

void GIE_VoidEnable(void)
{
    101c:	df 93       	push	r29
    101e:	cf 93       	push	r28
    1020:	cd b7       	in	r28, 0x3d	; 61
    1022:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG_REG,I);
    1024:	af e5       	ldi	r26, 0x5F	; 95
    1026:	b0 e0       	ldi	r27, 0x00	; 0
    1028:	ef e5       	ldi	r30, 0x5F	; 95
    102a:	f0 e0       	ldi	r31, 0x00	; 0
    102c:	80 81       	ld	r24, Z
    102e:	80 68       	ori	r24, 0x80	; 128
    1030:	8c 93       	st	X, r24
}
    1032:	cf 91       	pop	r28
    1034:	df 91       	pop	r29
    1036:	08 95       	ret

00001038 <GIE_VoidDisable>:

void GIE_VoidDisable(void)
{
    1038:	df 93       	push	r29
    103a:	cf 93       	push	r28
    103c:	cd b7       	in	r28, 0x3d	; 61
    103e:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG_REG,I);
    1040:	af e5       	ldi	r26, 0x5F	; 95
    1042:	b0 e0       	ldi	r27, 0x00	; 0
    1044:	ef e5       	ldi	r30, 0x5F	; 95
    1046:	f0 e0       	ldi	r31, 0x00	; 0
    1048:	80 81       	ld	r24, Z
    104a:	8f 77       	andi	r24, 0x7F	; 127
    104c:	8c 93       	st	X, r24
}
    104e:	cf 91       	pop	r28
    1050:	df 91       	pop	r29
    1052:	08 95       	ret

00001054 <DIO_SETPinDirection>:
/****************************************************************************************/
/*                                   Functions Definitions                              */
/****************************************************************************************/

void DIO_SETPinDirection(u8 PORT_ID , u8 PIN_ID , u8 PinDirection)
{
    1054:	df 93       	push	r29
    1056:	cf 93       	push	r28
    1058:	cd b7       	in	r28, 0x3d	; 61
    105a:	de b7       	in	r29, 0x3e	; 62
    105c:	27 97       	sbiw	r28, 0x07	; 7
    105e:	0f b6       	in	r0, 0x3f	; 63
    1060:	f8 94       	cli
    1062:	de bf       	out	0x3e, r29	; 62
    1064:	0f be       	out	0x3f, r0	; 63
    1066:	cd bf       	out	0x3d, r28	; 61
    1068:	89 83       	std	Y+1, r24	; 0x01
    106a:	6a 83       	std	Y+2, r22	; 0x02
    106c:	4b 83       	std	Y+3, r20	; 0x03
	if(PinDirection==OUTPUT)
    106e:	8b 81       	ldd	r24, Y+3	; 0x03
    1070:	81 30       	cpi	r24, 0x01	; 1
    1072:	09 f0       	breq	.+2      	; 0x1076 <DIO_SETPinDirection+0x22>
    1074:	6f c0       	rjmp	.+222    	; 0x1154 <DIO_SETPinDirection+0x100>
	{
		switch(PORT_ID)
    1076:	89 81       	ldd	r24, Y+1	; 0x01
    1078:	28 2f       	mov	r18, r24
    107a:	30 e0       	ldi	r19, 0x00	; 0
    107c:	3f 83       	std	Y+7, r19	; 0x07
    107e:	2e 83       	std	Y+6, r18	; 0x06
    1080:	8e 81       	ldd	r24, Y+6	; 0x06
    1082:	9f 81       	ldd	r25, Y+7	; 0x07
    1084:	81 30       	cpi	r24, 0x01	; 1
    1086:	91 05       	cpc	r25, r1
    1088:	49 f1       	breq	.+82     	; 0x10dc <DIO_SETPinDirection+0x88>
    108a:	2e 81       	ldd	r18, Y+6	; 0x06
    108c:	3f 81       	ldd	r19, Y+7	; 0x07
    108e:	22 30       	cpi	r18, 0x02	; 2
    1090:	31 05       	cpc	r19, r1
    1092:	2c f4       	brge	.+10     	; 0x109e <DIO_SETPinDirection+0x4a>
    1094:	8e 81       	ldd	r24, Y+6	; 0x06
    1096:	9f 81       	ldd	r25, Y+7	; 0x07
    1098:	00 97       	sbiw	r24, 0x00	; 0
    109a:	61 f0       	breq	.+24     	; 0x10b4 <DIO_SETPinDirection+0x60>
    109c:	d2 c0       	rjmp	.+420    	; 0x1242 <DIO_SETPinDirection+0x1ee>
    109e:	2e 81       	ldd	r18, Y+6	; 0x06
    10a0:	3f 81       	ldd	r19, Y+7	; 0x07
    10a2:	22 30       	cpi	r18, 0x02	; 2
    10a4:	31 05       	cpc	r19, r1
    10a6:	71 f1       	breq	.+92     	; 0x1104 <DIO_SETPinDirection+0xb0>
    10a8:	8e 81       	ldd	r24, Y+6	; 0x06
    10aa:	9f 81       	ldd	r25, Y+7	; 0x07
    10ac:	83 30       	cpi	r24, 0x03	; 3
    10ae:	91 05       	cpc	r25, r1
    10b0:	e9 f1       	breq	.+122    	; 0x112c <DIO_SETPinDirection+0xd8>
    10b2:	c7 c0       	rjmp	.+398    	; 0x1242 <DIO_SETPinDirection+0x1ee>
		{
			case PORTA_ID : SET_BIT(DDRA_REG,PIN_ID);  break;
    10b4:	aa e3       	ldi	r26, 0x3A	; 58
    10b6:	b0 e0       	ldi	r27, 0x00	; 0
    10b8:	ea e3       	ldi	r30, 0x3A	; 58
    10ba:	f0 e0       	ldi	r31, 0x00	; 0
    10bc:	80 81       	ld	r24, Z
    10be:	48 2f       	mov	r20, r24
    10c0:	8a 81       	ldd	r24, Y+2	; 0x02
    10c2:	28 2f       	mov	r18, r24
    10c4:	30 e0       	ldi	r19, 0x00	; 0
    10c6:	81 e0       	ldi	r24, 0x01	; 1
    10c8:	90 e0       	ldi	r25, 0x00	; 0
    10ca:	02 2e       	mov	r0, r18
    10cc:	02 c0       	rjmp	.+4      	; 0x10d2 <DIO_SETPinDirection+0x7e>
    10ce:	88 0f       	add	r24, r24
    10d0:	99 1f       	adc	r25, r25
    10d2:	0a 94       	dec	r0
    10d4:	e2 f7       	brpl	.-8      	; 0x10ce <DIO_SETPinDirection+0x7a>
    10d6:	84 2b       	or	r24, r20
    10d8:	8c 93       	st	X, r24
    10da:	b3 c0       	rjmp	.+358    	; 0x1242 <DIO_SETPinDirection+0x1ee>
			case PORTB_ID : SET_BIT(DDRB_REG,PIN_ID);  break;
    10dc:	a7 e3       	ldi	r26, 0x37	; 55
    10de:	b0 e0       	ldi	r27, 0x00	; 0
    10e0:	e7 e3       	ldi	r30, 0x37	; 55
    10e2:	f0 e0       	ldi	r31, 0x00	; 0
    10e4:	80 81       	ld	r24, Z
    10e6:	48 2f       	mov	r20, r24
    10e8:	8a 81       	ldd	r24, Y+2	; 0x02
    10ea:	28 2f       	mov	r18, r24
    10ec:	30 e0       	ldi	r19, 0x00	; 0
    10ee:	81 e0       	ldi	r24, 0x01	; 1
    10f0:	90 e0       	ldi	r25, 0x00	; 0
    10f2:	02 2e       	mov	r0, r18
    10f4:	02 c0       	rjmp	.+4      	; 0x10fa <DIO_SETPinDirection+0xa6>
    10f6:	88 0f       	add	r24, r24
    10f8:	99 1f       	adc	r25, r25
    10fa:	0a 94       	dec	r0
    10fc:	e2 f7       	brpl	.-8      	; 0x10f6 <DIO_SETPinDirection+0xa2>
    10fe:	84 2b       	or	r24, r20
    1100:	8c 93       	st	X, r24
    1102:	9f c0       	rjmp	.+318    	; 0x1242 <DIO_SETPinDirection+0x1ee>
			case PORTC_ID : SET_BIT(DDRC_REG,PIN_ID);  break;
    1104:	a4 e3       	ldi	r26, 0x34	; 52
    1106:	b0 e0       	ldi	r27, 0x00	; 0
    1108:	e4 e3       	ldi	r30, 0x34	; 52
    110a:	f0 e0       	ldi	r31, 0x00	; 0
    110c:	80 81       	ld	r24, Z
    110e:	48 2f       	mov	r20, r24
    1110:	8a 81       	ldd	r24, Y+2	; 0x02
    1112:	28 2f       	mov	r18, r24
    1114:	30 e0       	ldi	r19, 0x00	; 0
    1116:	81 e0       	ldi	r24, 0x01	; 1
    1118:	90 e0       	ldi	r25, 0x00	; 0
    111a:	02 2e       	mov	r0, r18
    111c:	02 c0       	rjmp	.+4      	; 0x1122 <DIO_SETPinDirection+0xce>
    111e:	88 0f       	add	r24, r24
    1120:	99 1f       	adc	r25, r25
    1122:	0a 94       	dec	r0
    1124:	e2 f7       	brpl	.-8      	; 0x111e <DIO_SETPinDirection+0xca>
    1126:	84 2b       	or	r24, r20
    1128:	8c 93       	st	X, r24
    112a:	8b c0       	rjmp	.+278    	; 0x1242 <DIO_SETPinDirection+0x1ee>
			case PORTD_ID : SET_BIT(DDRD_REG,PIN_ID);  break;
    112c:	a1 e3       	ldi	r26, 0x31	; 49
    112e:	b0 e0       	ldi	r27, 0x00	; 0
    1130:	e1 e3       	ldi	r30, 0x31	; 49
    1132:	f0 e0       	ldi	r31, 0x00	; 0
    1134:	80 81       	ld	r24, Z
    1136:	48 2f       	mov	r20, r24
    1138:	8a 81       	ldd	r24, Y+2	; 0x02
    113a:	28 2f       	mov	r18, r24
    113c:	30 e0       	ldi	r19, 0x00	; 0
    113e:	81 e0       	ldi	r24, 0x01	; 1
    1140:	90 e0       	ldi	r25, 0x00	; 0
    1142:	02 2e       	mov	r0, r18
    1144:	02 c0       	rjmp	.+4      	; 0x114a <DIO_SETPinDirection+0xf6>
    1146:	88 0f       	add	r24, r24
    1148:	99 1f       	adc	r25, r25
    114a:	0a 94       	dec	r0
    114c:	e2 f7       	brpl	.-8      	; 0x1146 <DIO_SETPinDirection+0xf2>
    114e:	84 2b       	or	r24, r20
    1150:	8c 93       	st	X, r24
    1152:	77 c0       	rjmp	.+238    	; 0x1242 <DIO_SETPinDirection+0x1ee>
		}
	}
	else if(PinDirection==INPUT)
    1154:	8b 81       	ldd	r24, Y+3	; 0x03
    1156:	88 23       	and	r24, r24
    1158:	09 f0       	breq	.+2      	; 0x115c <DIO_SETPinDirection+0x108>
    115a:	73 c0       	rjmp	.+230    	; 0x1242 <DIO_SETPinDirection+0x1ee>
	{
		switch(PORT_ID)
    115c:	89 81       	ldd	r24, Y+1	; 0x01
    115e:	28 2f       	mov	r18, r24
    1160:	30 e0       	ldi	r19, 0x00	; 0
    1162:	3d 83       	std	Y+5, r19	; 0x05
    1164:	2c 83       	std	Y+4, r18	; 0x04
    1166:	8c 81       	ldd	r24, Y+4	; 0x04
    1168:	9d 81       	ldd	r25, Y+5	; 0x05
    116a:	81 30       	cpi	r24, 0x01	; 1
    116c:	91 05       	cpc	r25, r1
    116e:	59 f1       	breq	.+86     	; 0x11c6 <DIO_SETPinDirection+0x172>
    1170:	2c 81       	ldd	r18, Y+4	; 0x04
    1172:	3d 81       	ldd	r19, Y+5	; 0x05
    1174:	22 30       	cpi	r18, 0x02	; 2
    1176:	31 05       	cpc	r19, r1
    1178:	2c f4       	brge	.+10     	; 0x1184 <DIO_SETPinDirection+0x130>
    117a:	8c 81       	ldd	r24, Y+4	; 0x04
    117c:	9d 81       	ldd	r25, Y+5	; 0x05
    117e:	00 97       	sbiw	r24, 0x00	; 0
    1180:	69 f0       	breq	.+26     	; 0x119c <DIO_SETPinDirection+0x148>
    1182:	5f c0       	rjmp	.+190    	; 0x1242 <DIO_SETPinDirection+0x1ee>
    1184:	2c 81       	ldd	r18, Y+4	; 0x04
    1186:	3d 81       	ldd	r19, Y+5	; 0x05
    1188:	22 30       	cpi	r18, 0x02	; 2
    118a:	31 05       	cpc	r19, r1
    118c:	89 f1       	breq	.+98     	; 0x11f0 <DIO_SETPinDirection+0x19c>
    118e:	8c 81       	ldd	r24, Y+4	; 0x04
    1190:	9d 81       	ldd	r25, Y+5	; 0x05
    1192:	83 30       	cpi	r24, 0x03	; 3
    1194:	91 05       	cpc	r25, r1
    1196:	09 f4       	brne	.+2      	; 0x119a <DIO_SETPinDirection+0x146>
    1198:	40 c0       	rjmp	.+128    	; 0x121a <DIO_SETPinDirection+0x1c6>
    119a:	53 c0       	rjmp	.+166    	; 0x1242 <DIO_SETPinDirection+0x1ee>
		{
			case PORTA_ID : CLR_BIT(DDRA_REG,PIN_ID);  break;
    119c:	aa e3       	ldi	r26, 0x3A	; 58
    119e:	b0 e0       	ldi	r27, 0x00	; 0
    11a0:	ea e3       	ldi	r30, 0x3A	; 58
    11a2:	f0 e0       	ldi	r31, 0x00	; 0
    11a4:	80 81       	ld	r24, Z
    11a6:	48 2f       	mov	r20, r24
    11a8:	8a 81       	ldd	r24, Y+2	; 0x02
    11aa:	28 2f       	mov	r18, r24
    11ac:	30 e0       	ldi	r19, 0x00	; 0
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	02 2e       	mov	r0, r18
    11b4:	02 c0       	rjmp	.+4      	; 0x11ba <DIO_SETPinDirection+0x166>
    11b6:	88 0f       	add	r24, r24
    11b8:	99 1f       	adc	r25, r25
    11ba:	0a 94       	dec	r0
    11bc:	e2 f7       	brpl	.-8      	; 0x11b6 <DIO_SETPinDirection+0x162>
    11be:	80 95       	com	r24
    11c0:	84 23       	and	r24, r20
    11c2:	8c 93       	st	X, r24
    11c4:	3e c0       	rjmp	.+124    	; 0x1242 <DIO_SETPinDirection+0x1ee>
			case PORTB_ID : CLR_BIT(DDRB_REG,PIN_ID);  break;
    11c6:	a7 e3       	ldi	r26, 0x37	; 55
    11c8:	b0 e0       	ldi	r27, 0x00	; 0
    11ca:	e7 e3       	ldi	r30, 0x37	; 55
    11cc:	f0 e0       	ldi	r31, 0x00	; 0
    11ce:	80 81       	ld	r24, Z
    11d0:	48 2f       	mov	r20, r24
    11d2:	8a 81       	ldd	r24, Y+2	; 0x02
    11d4:	28 2f       	mov	r18, r24
    11d6:	30 e0       	ldi	r19, 0x00	; 0
    11d8:	81 e0       	ldi	r24, 0x01	; 1
    11da:	90 e0       	ldi	r25, 0x00	; 0
    11dc:	02 2e       	mov	r0, r18
    11de:	02 c0       	rjmp	.+4      	; 0x11e4 <DIO_SETPinDirection+0x190>
    11e0:	88 0f       	add	r24, r24
    11e2:	99 1f       	adc	r25, r25
    11e4:	0a 94       	dec	r0
    11e6:	e2 f7       	brpl	.-8      	; 0x11e0 <DIO_SETPinDirection+0x18c>
    11e8:	80 95       	com	r24
    11ea:	84 23       	and	r24, r20
    11ec:	8c 93       	st	X, r24
    11ee:	29 c0       	rjmp	.+82     	; 0x1242 <DIO_SETPinDirection+0x1ee>
			case PORTC_ID : CLR_BIT(DDRC_REG,PIN_ID);  break;
    11f0:	a4 e3       	ldi	r26, 0x34	; 52
    11f2:	b0 e0       	ldi	r27, 0x00	; 0
    11f4:	e4 e3       	ldi	r30, 0x34	; 52
    11f6:	f0 e0       	ldi	r31, 0x00	; 0
    11f8:	80 81       	ld	r24, Z
    11fa:	48 2f       	mov	r20, r24
    11fc:	8a 81       	ldd	r24, Y+2	; 0x02
    11fe:	28 2f       	mov	r18, r24
    1200:	30 e0       	ldi	r19, 0x00	; 0
    1202:	81 e0       	ldi	r24, 0x01	; 1
    1204:	90 e0       	ldi	r25, 0x00	; 0
    1206:	02 2e       	mov	r0, r18
    1208:	02 c0       	rjmp	.+4      	; 0x120e <DIO_SETPinDirection+0x1ba>
    120a:	88 0f       	add	r24, r24
    120c:	99 1f       	adc	r25, r25
    120e:	0a 94       	dec	r0
    1210:	e2 f7       	brpl	.-8      	; 0x120a <DIO_SETPinDirection+0x1b6>
    1212:	80 95       	com	r24
    1214:	84 23       	and	r24, r20
    1216:	8c 93       	st	X, r24
    1218:	14 c0       	rjmp	.+40     	; 0x1242 <DIO_SETPinDirection+0x1ee>
			case PORTD_ID : CLR_BIT(DDRD_REG,PIN_ID);  break;
    121a:	a1 e3       	ldi	r26, 0x31	; 49
    121c:	b0 e0       	ldi	r27, 0x00	; 0
    121e:	e1 e3       	ldi	r30, 0x31	; 49
    1220:	f0 e0       	ldi	r31, 0x00	; 0
    1222:	80 81       	ld	r24, Z
    1224:	48 2f       	mov	r20, r24
    1226:	8a 81       	ldd	r24, Y+2	; 0x02
    1228:	28 2f       	mov	r18, r24
    122a:	30 e0       	ldi	r19, 0x00	; 0
    122c:	81 e0       	ldi	r24, 0x01	; 1
    122e:	90 e0       	ldi	r25, 0x00	; 0
    1230:	02 2e       	mov	r0, r18
    1232:	02 c0       	rjmp	.+4      	; 0x1238 <DIO_SETPinDirection+0x1e4>
    1234:	88 0f       	add	r24, r24
    1236:	99 1f       	adc	r25, r25
    1238:	0a 94       	dec	r0
    123a:	e2 f7       	brpl	.-8      	; 0x1234 <DIO_SETPinDirection+0x1e0>
    123c:	80 95       	com	r24
    123e:	84 23       	and	r24, r20
    1240:	8c 93       	st	X, r24
		}
	}
}
    1242:	27 96       	adiw	r28, 0x07	; 7
    1244:	0f b6       	in	r0, 0x3f	; 63
    1246:	f8 94       	cli
    1248:	de bf       	out	0x3e, r29	; 62
    124a:	0f be       	out	0x3f, r0	; 63
    124c:	cd bf       	out	0x3d, r28	; 61
    124e:	cf 91       	pop	r28
    1250:	df 91       	pop	r29
    1252:	08 95       	ret

00001254 <DIO_SETPinValue>:

void DIO_SETPinValue(u8 PORT_ID , u8 PIN_ID , u8 pinValue)
{
    1254:	df 93       	push	r29
    1256:	cf 93       	push	r28
    1258:	cd b7       	in	r28, 0x3d	; 61
    125a:	de b7       	in	r29, 0x3e	; 62
    125c:	27 97       	sbiw	r28, 0x07	; 7
    125e:	0f b6       	in	r0, 0x3f	; 63
    1260:	f8 94       	cli
    1262:	de bf       	out	0x3e, r29	; 62
    1264:	0f be       	out	0x3f, r0	; 63
    1266:	cd bf       	out	0x3d, r28	; 61
    1268:	89 83       	std	Y+1, r24	; 0x01
    126a:	6a 83       	std	Y+2, r22	; 0x02
    126c:	4b 83       	std	Y+3, r20	; 0x03
	if(pinValue==HIGH)
    126e:	8b 81       	ldd	r24, Y+3	; 0x03
    1270:	81 30       	cpi	r24, 0x01	; 1
    1272:	09 f0       	breq	.+2      	; 0x1276 <DIO_SETPinValue+0x22>
    1274:	6f c0       	rjmp	.+222    	; 0x1354 <DIO_SETPinValue+0x100>
		{
			switch(PORT_ID)
    1276:	89 81       	ldd	r24, Y+1	; 0x01
    1278:	28 2f       	mov	r18, r24
    127a:	30 e0       	ldi	r19, 0x00	; 0
    127c:	3f 83       	std	Y+7, r19	; 0x07
    127e:	2e 83       	std	Y+6, r18	; 0x06
    1280:	8e 81       	ldd	r24, Y+6	; 0x06
    1282:	9f 81       	ldd	r25, Y+7	; 0x07
    1284:	81 30       	cpi	r24, 0x01	; 1
    1286:	91 05       	cpc	r25, r1
    1288:	49 f1       	breq	.+82     	; 0x12dc <DIO_SETPinValue+0x88>
    128a:	2e 81       	ldd	r18, Y+6	; 0x06
    128c:	3f 81       	ldd	r19, Y+7	; 0x07
    128e:	22 30       	cpi	r18, 0x02	; 2
    1290:	31 05       	cpc	r19, r1
    1292:	2c f4       	brge	.+10     	; 0x129e <DIO_SETPinValue+0x4a>
    1294:	8e 81       	ldd	r24, Y+6	; 0x06
    1296:	9f 81       	ldd	r25, Y+7	; 0x07
    1298:	00 97       	sbiw	r24, 0x00	; 0
    129a:	61 f0       	breq	.+24     	; 0x12b4 <DIO_SETPinValue+0x60>
    129c:	d2 c0       	rjmp	.+420    	; 0x1442 <DIO_SETPinValue+0x1ee>
    129e:	2e 81       	ldd	r18, Y+6	; 0x06
    12a0:	3f 81       	ldd	r19, Y+7	; 0x07
    12a2:	22 30       	cpi	r18, 0x02	; 2
    12a4:	31 05       	cpc	r19, r1
    12a6:	71 f1       	breq	.+92     	; 0x1304 <DIO_SETPinValue+0xb0>
    12a8:	8e 81       	ldd	r24, Y+6	; 0x06
    12aa:	9f 81       	ldd	r25, Y+7	; 0x07
    12ac:	83 30       	cpi	r24, 0x03	; 3
    12ae:	91 05       	cpc	r25, r1
    12b0:	e9 f1       	breq	.+122    	; 0x132c <DIO_SETPinValue+0xd8>
    12b2:	c7 c0       	rjmp	.+398    	; 0x1442 <DIO_SETPinValue+0x1ee>
			{
				case PORTA_ID : SET_BIT(PORTA_REG,PIN_ID);  break;
    12b4:	ab e3       	ldi	r26, 0x3B	; 59
    12b6:	b0 e0       	ldi	r27, 0x00	; 0
    12b8:	eb e3       	ldi	r30, 0x3B	; 59
    12ba:	f0 e0       	ldi	r31, 0x00	; 0
    12bc:	80 81       	ld	r24, Z
    12be:	48 2f       	mov	r20, r24
    12c0:	8a 81       	ldd	r24, Y+2	; 0x02
    12c2:	28 2f       	mov	r18, r24
    12c4:	30 e0       	ldi	r19, 0x00	; 0
    12c6:	81 e0       	ldi	r24, 0x01	; 1
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	02 2e       	mov	r0, r18
    12cc:	02 c0       	rjmp	.+4      	; 0x12d2 <DIO_SETPinValue+0x7e>
    12ce:	88 0f       	add	r24, r24
    12d0:	99 1f       	adc	r25, r25
    12d2:	0a 94       	dec	r0
    12d4:	e2 f7       	brpl	.-8      	; 0x12ce <DIO_SETPinValue+0x7a>
    12d6:	84 2b       	or	r24, r20
    12d8:	8c 93       	st	X, r24
    12da:	b3 c0       	rjmp	.+358    	; 0x1442 <DIO_SETPinValue+0x1ee>
				case PORTB_ID : SET_BIT(PORTB_REG,PIN_ID);  break;
    12dc:	a8 e3       	ldi	r26, 0x38	; 56
    12de:	b0 e0       	ldi	r27, 0x00	; 0
    12e0:	e8 e3       	ldi	r30, 0x38	; 56
    12e2:	f0 e0       	ldi	r31, 0x00	; 0
    12e4:	80 81       	ld	r24, Z
    12e6:	48 2f       	mov	r20, r24
    12e8:	8a 81       	ldd	r24, Y+2	; 0x02
    12ea:	28 2f       	mov	r18, r24
    12ec:	30 e0       	ldi	r19, 0x00	; 0
    12ee:	81 e0       	ldi	r24, 0x01	; 1
    12f0:	90 e0       	ldi	r25, 0x00	; 0
    12f2:	02 2e       	mov	r0, r18
    12f4:	02 c0       	rjmp	.+4      	; 0x12fa <DIO_SETPinValue+0xa6>
    12f6:	88 0f       	add	r24, r24
    12f8:	99 1f       	adc	r25, r25
    12fa:	0a 94       	dec	r0
    12fc:	e2 f7       	brpl	.-8      	; 0x12f6 <DIO_SETPinValue+0xa2>
    12fe:	84 2b       	or	r24, r20
    1300:	8c 93       	st	X, r24
    1302:	9f c0       	rjmp	.+318    	; 0x1442 <DIO_SETPinValue+0x1ee>
				case PORTC_ID : SET_BIT(PORTC_REG,PIN_ID);  break;
    1304:	a5 e3       	ldi	r26, 0x35	; 53
    1306:	b0 e0       	ldi	r27, 0x00	; 0
    1308:	e5 e3       	ldi	r30, 0x35	; 53
    130a:	f0 e0       	ldi	r31, 0x00	; 0
    130c:	80 81       	ld	r24, Z
    130e:	48 2f       	mov	r20, r24
    1310:	8a 81       	ldd	r24, Y+2	; 0x02
    1312:	28 2f       	mov	r18, r24
    1314:	30 e0       	ldi	r19, 0x00	; 0
    1316:	81 e0       	ldi	r24, 0x01	; 1
    1318:	90 e0       	ldi	r25, 0x00	; 0
    131a:	02 2e       	mov	r0, r18
    131c:	02 c0       	rjmp	.+4      	; 0x1322 <DIO_SETPinValue+0xce>
    131e:	88 0f       	add	r24, r24
    1320:	99 1f       	adc	r25, r25
    1322:	0a 94       	dec	r0
    1324:	e2 f7       	brpl	.-8      	; 0x131e <DIO_SETPinValue+0xca>
    1326:	84 2b       	or	r24, r20
    1328:	8c 93       	st	X, r24
    132a:	8b c0       	rjmp	.+278    	; 0x1442 <DIO_SETPinValue+0x1ee>
				case PORTD_ID : SET_BIT(PORTD_REG,PIN_ID);  break;
    132c:	a2 e3       	ldi	r26, 0x32	; 50
    132e:	b0 e0       	ldi	r27, 0x00	; 0
    1330:	e2 e3       	ldi	r30, 0x32	; 50
    1332:	f0 e0       	ldi	r31, 0x00	; 0
    1334:	80 81       	ld	r24, Z
    1336:	48 2f       	mov	r20, r24
    1338:	8a 81       	ldd	r24, Y+2	; 0x02
    133a:	28 2f       	mov	r18, r24
    133c:	30 e0       	ldi	r19, 0x00	; 0
    133e:	81 e0       	ldi	r24, 0x01	; 1
    1340:	90 e0       	ldi	r25, 0x00	; 0
    1342:	02 2e       	mov	r0, r18
    1344:	02 c0       	rjmp	.+4      	; 0x134a <DIO_SETPinValue+0xf6>
    1346:	88 0f       	add	r24, r24
    1348:	99 1f       	adc	r25, r25
    134a:	0a 94       	dec	r0
    134c:	e2 f7       	brpl	.-8      	; 0x1346 <DIO_SETPinValue+0xf2>
    134e:	84 2b       	or	r24, r20
    1350:	8c 93       	st	X, r24
    1352:	77 c0       	rjmp	.+238    	; 0x1442 <DIO_SETPinValue+0x1ee>
			}
		}
		else if(pinValue==LOW)
    1354:	8b 81       	ldd	r24, Y+3	; 0x03
    1356:	88 23       	and	r24, r24
    1358:	09 f0       	breq	.+2      	; 0x135c <DIO_SETPinValue+0x108>
    135a:	73 c0       	rjmp	.+230    	; 0x1442 <DIO_SETPinValue+0x1ee>
		{
			switch(PORT_ID)
    135c:	89 81       	ldd	r24, Y+1	; 0x01
    135e:	28 2f       	mov	r18, r24
    1360:	30 e0       	ldi	r19, 0x00	; 0
    1362:	3d 83       	std	Y+5, r19	; 0x05
    1364:	2c 83       	std	Y+4, r18	; 0x04
    1366:	8c 81       	ldd	r24, Y+4	; 0x04
    1368:	9d 81       	ldd	r25, Y+5	; 0x05
    136a:	81 30       	cpi	r24, 0x01	; 1
    136c:	91 05       	cpc	r25, r1
    136e:	59 f1       	breq	.+86     	; 0x13c6 <DIO_SETPinValue+0x172>
    1370:	2c 81       	ldd	r18, Y+4	; 0x04
    1372:	3d 81       	ldd	r19, Y+5	; 0x05
    1374:	22 30       	cpi	r18, 0x02	; 2
    1376:	31 05       	cpc	r19, r1
    1378:	2c f4       	brge	.+10     	; 0x1384 <DIO_SETPinValue+0x130>
    137a:	8c 81       	ldd	r24, Y+4	; 0x04
    137c:	9d 81       	ldd	r25, Y+5	; 0x05
    137e:	00 97       	sbiw	r24, 0x00	; 0
    1380:	69 f0       	breq	.+26     	; 0x139c <DIO_SETPinValue+0x148>
    1382:	5f c0       	rjmp	.+190    	; 0x1442 <DIO_SETPinValue+0x1ee>
    1384:	2c 81       	ldd	r18, Y+4	; 0x04
    1386:	3d 81       	ldd	r19, Y+5	; 0x05
    1388:	22 30       	cpi	r18, 0x02	; 2
    138a:	31 05       	cpc	r19, r1
    138c:	89 f1       	breq	.+98     	; 0x13f0 <DIO_SETPinValue+0x19c>
    138e:	8c 81       	ldd	r24, Y+4	; 0x04
    1390:	9d 81       	ldd	r25, Y+5	; 0x05
    1392:	83 30       	cpi	r24, 0x03	; 3
    1394:	91 05       	cpc	r25, r1
    1396:	09 f4       	brne	.+2      	; 0x139a <DIO_SETPinValue+0x146>
    1398:	40 c0       	rjmp	.+128    	; 0x141a <DIO_SETPinValue+0x1c6>
    139a:	53 c0       	rjmp	.+166    	; 0x1442 <DIO_SETPinValue+0x1ee>
			{
				case PORTA_ID : CLR_BIT(PORTA_REG,PIN_ID);  break;
    139c:	ab e3       	ldi	r26, 0x3B	; 59
    139e:	b0 e0       	ldi	r27, 0x00	; 0
    13a0:	eb e3       	ldi	r30, 0x3B	; 59
    13a2:	f0 e0       	ldi	r31, 0x00	; 0
    13a4:	80 81       	ld	r24, Z
    13a6:	48 2f       	mov	r20, r24
    13a8:	8a 81       	ldd	r24, Y+2	; 0x02
    13aa:	28 2f       	mov	r18, r24
    13ac:	30 e0       	ldi	r19, 0x00	; 0
    13ae:	81 e0       	ldi	r24, 0x01	; 1
    13b0:	90 e0       	ldi	r25, 0x00	; 0
    13b2:	02 2e       	mov	r0, r18
    13b4:	02 c0       	rjmp	.+4      	; 0x13ba <DIO_SETPinValue+0x166>
    13b6:	88 0f       	add	r24, r24
    13b8:	99 1f       	adc	r25, r25
    13ba:	0a 94       	dec	r0
    13bc:	e2 f7       	brpl	.-8      	; 0x13b6 <DIO_SETPinValue+0x162>
    13be:	80 95       	com	r24
    13c0:	84 23       	and	r24, r20
    13c2:	8c 93       	st	X, r24
    13c4:	3e c0       	rjmp	.+124    	; 0x1442 <DIO_SETPinValue+0x1ee>
				case PORTB_ID : CLR_BIT(PORTB_REG,PIN_ID);  break;
    13c6:	a8 e3       	ldi	r26, 0x38	; 56
    13c8:	b0 e0       	ldi	r27, 0x00	; 0
    13ca:	e8 e3       	ldi	r30, 0x38	; 56
    13cc:	f0 e0       	ldi	r31, 0x00	; 0
    13ce:	80 81       	ld	r24, Z
    13d0:	48 2f       	mov	r20, r24
    13d2:	8a 81       	ldd	r24, Y+2	; 0x02
    13d4:	28 2f       	mov	r18, r24
    13d6:	30 e0       	ldi	r19, 0x00	; 0
    13d8:	81 e0       	ldi	r24, 0x01	; 1
    13da:	90 e0       	ldi	r25, 0x00	; 0
    13dc:	02 2e       	mov	r0, r18
    13de:	02 c0       	rjmp	.+4      	; 0x13e4 <DIO_SETPinValue+0x190>
    13e0:	88 0f       	add	r24, r24
    13e2:	99 1f       	adc	r25, r25
    13e4:	0a 94       	dec	r0
    13e6:	e2 f7       	brpl	.-8      	; 0x13e0 <DIO_SETPinValue+0x18c>
    13e8:	80 95       	com	r24
    13ea:	84 23       	and	r24, r20
    13ec:	8c 93       	st	X, r24
    13ee:	29 c0       	rjmp	.+82     	; 0x1442 <DIO_SETPinValue+0x1ee>
				case PORTC_ID : CLR_BIT(PORTC_REG,PIN_ID);  break;
    13f0:	a5 e3       	ldi	r26, 0x35	; 53
    13f2:	b0 e0       	ldi	r27, 0x00	; 0
    13f4:	e5 e3       	ldi	r30, 0x35	; 53
    13f6:	f0 e0       	ldi	r31, 0x00	; 0
    13f8:	80 81       	ld	r24, Z
    13fa:	48 2f       	mov	r20, r24
    13fc:	8a 81       	ldd	r24, Y+2	; 0x02
    13fe:	28 2f       	mov	r18, r24
    1400:	30 e0       	ldi	r19, 0x00	; 0
    1402:	81 e0       	ldi	r24, 0x01	; 1
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	02 2e       	mov	r0, r18
    1408:	02 c0       	rjmp	.+4      	; 0x140e <DIO_SETPinValue+0x1ba>
    140a:	88 0f       	add	r24, r24
    140c:	99 1f       	adc	r25, r25
    140e:	0a 94       	dec	r0
    1410:	e2 f7       	brpl	.-8      	; 0x140a <DIO_SETPinValue+0x1b6>
    1412:	80 95       	com	r24
    1414:	84 23       	and	r24, r20
    1416:	8c 93       	st	X, r24
    1418:	14 c0       	rjmp	.+40     	; 0x1442 <DIO_SETPinValue+0x1ee>
				case PORTD_ID : CLR_BIT(PORTD_REG,PIN_ID);  break;
    141a:	a2 e3       	ldi	r26, 0x32	; 50
    141c:	b0 e0       	ldi	r27, 0x00	; 0
    141e:	e2 e3       	ldi	r30, 0x32	; 50
    1420:	f0 e0       	ldi	r31, 0x00	; 0
    1422:	80 81       	ld	r24, Z
    1424:	48 2f       	mov	r20, r24
    1426:	8a 81       	ldd	r24, Y+2	; 0x02
    1428:	28 2f       	mov	r18, r24
    142a:	30 e0       	ldi	r19, 0x00	; 0
    142c:	81 e0       	ldi	r24, 0x01	; 1
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	02 2e       	mov	r0, r18
    1432:	02 c0       	rjmp	.+4      	; 0x1438 <DIO_SETPinValue+0x1e4>
    1434:	88 0f       	add	r24, r24
    1436:	99 1f       	adc	r25, r25
    1438:	0a 94       	dec	r0
    143a:	e2 f7       	brpl	.-8      	; 0x1434 <DIO_SETPinValue+0x1e0>
    143c:	80 95       	com	r24
    143e:	84 23       	and	r24, r20
    1440:	8c 93       	st	X, r24
			}
		}
}
    1442:	27 96       	adiw	r28, 0x07	; 7
    1444:	0f b6       	in	r0, 0x3f	; 63
    1446:	f8 94       	cli
    1448:	de bf       	out	0x3e, r29	; 62
    144a:	0f be       	out	0x3f, r0	; 63
    144c:	cd bf       	out	0x3d, r28	; 61
    144e:	cf 91       	pop	r28
    1450:	df 91       	pop	r29
    1452:	08 95       	ret

00001454 <DIO_SETPortDirection>:

void DIO_SETPortDirection(u8 PORT_ID , u8 PortDirection)
{
    1454:	df 93       	push	r29
    1456:	cf 93       	push	r28
    1458:	00 d0       	rcall	.+0      	; 0x145a <DIO_SETPortDirection+0x6>
    145a:	00 d0       	rcall	.+0      	; 0x145c <DIO_SETPortDirection+0x8>
    145c:	cd b7       	in	r28, 0x3d	; 61
    145e:	de b7       	in	r29, 0x3e	; 62
    1460:	89 83       	std	Y+1, r24	; 0x01
    1462:	6a 83       	std	Y+2, r22	; 0x02

		switch(PORT_ID)
    1464:	89 81       	ldd	r24, Y+1	; 0x01
    1466:	28 2f       	mov	r18, r24
    1468:	30 e0       	ldi	r19, 0x00	; 0
    146a:	3c 83       	std	Y+4, r19	; 0x04
    146c:	2b 83       	std	Y+3, r18	; 0x03
    146e:	8b 81       	ldd	r24, Y+3	; 0x03
    1470:	9c 81       	ldd	r25, Y+4	; 0x04
    1472:	81 30       	cpi	r24, 0x01	; 1
    1474:	91 05       	cpc	r25, r1
    1476:	d1 f0       	breq	.+52     	; 0x14ac <DIO_SETPortDirection+0x58>
    1478:	2b 81       	ldd	r18, Y+3	; 0x03
    147a:	3c 81       	ldd	r19, Y+4	; 0x04
    147c:	22 30       	cpi	r18, 0x02	; 2
    147e:	31 05       	cpc	r19, r1
    1480:	2c f4       	brge	.+10     	; 0x148c <DIO_SETPortDirection+0x38>
    1482:	8b 81       	ldd	r24, Y+3	; 0x03
    1484:	9c 81       	ldd	r25, Y+4	; 0x04
    1486:	00 97       	sbiw	r24, 0x00	; 0
    1488:	61 f0       	breq	.+24     	; 0x14a2 <DIO_SETPortDirection+0x4e>
    148a:	1e c0       	rjmp	.+60     	; 0x14c8 <DIO_SETPortDirection+0x74>
    148c:	2b 81       	ldd	r18, Y+3	; 0x03
    148e:	3c 81       	ldd	r19, Y+4	; 0x04
    1490:	22 30       	cpi	r18, 0x02	; 2
    1492:	31 05       	cpc	r19, r1
    1494:	81 f0       	breq	.+32     	; 0x14b6 <DIO_SETPortDirection+0x62>
    1496:	8b 81       	ldd	r24, Y+3	; 0x03
    1498:	9c 81       	ldd	r25, Y+4	; 0x04
    149a:	83 30       	cpi	r24, 0x03	; 3
    149c:	91 05       	cpc	r25, r1
    149e:	81 f0       	breq	.+32     	; 0x14c0 <DIO_SETPortDirection+0x6c>
    14a0:	13 c0       	rjmp	.+38     	; 0x14c8 <DIO_SETPortDirection+0x74>
		{
		case PORTA_ID : DDRA_REG = PortDirection;    break;
    14a2:	ea e3       	ldi	r30, 0x3A	; 58
    14a4:	f0 e0       	ldi	r31, 0x00	; 0
    14a6:	8a 81       	ldd	r24, Y+2	; 0x02
    14a8:	80 83       	st	Z, r24
    14aa:	0e c0       	rjmp	.+28     	; 0x14c8 <DIO_SETPortDirection+0x74>
		case PORTB_ID : DDRB_REG = PortDirection;    break;
    14ac:	e7 e3       	ldi	r30, 0x37	; 55
    14ae:	f0 e0       	ldi	r31, 0x00	; 0
    14b0:	8a 81       	ldd	r24, Y+2	; 0x02
    14b2:	80 83       	st	Z, r24
    14b4:	09 c0       	rjmp	.+18     	; 0x14c8 <DIO_SETPortDirection+0x74>
		case PORTC_ID : DDRC_REG = PortDirection;    break;
    14b6:	e4 e3       	ldi	r30, 0x34	; 52
    14b8:	f0 e0       	ldi	r31, 0x00	; 0
    14ba:	8a 81       	ldd	r24, Y+2	; 0x02
    14bc:	80 83       	st	Z, r24
    14be:	04 c0       	rjmp	.+8      	; 0x14c8 <DIO_SETPortDirection+0x74>
		case PORTD_ID : DDRD_REG = PortDirection;    break;
    14c0:	e1 e3       	ldi	r30, 0x31	; 49
    14c2:	f0 e0       	ldi	r31, 0x00	; 0
    14c4:	8a 81       	ldd	r24, Y+2	; 0x02
    14c6:	80 83       	st	Z, r24
		}

}
    14c8:	0f 90       	pop	r0
    14ca:	0f 90       	pop	r0
    14cc:	0f 90       	pop	r0
    14ce:	0f 90       	pop	r0
    14d0:	cf 91       	pop	r28
    14d2:	df 91       	pop	r29
    14d4:	08 95       	ret

000014d6 <DIO_SETPortValue>:

void DIO_SETPortValue(u8 PORT_ID , u8 PortValue)
{
    14d6:	df 93       	push	r29
    14d8:	cf 93       	push	r28
    14da:	00 d0       	rcall	.+0      	; 0x14dc <DIO_SETPortValue+0x6>
    14dc:	00 d0       	rcall	.+0      	; 0x14de <DIO_SETPortValue+0x8>
    14de:	cd b7       	in	r28, 0x3d	; 61
    14e0:	de b7       	in	r29, 0x3e	; 62
    14e2:	89 83       	std	Y+1, r24	; 0x01
    14e4:	6a 83       	std	Y+2, r22	; 0x02
		switch(PORT_ID)
    14e6:	89 81       	ldd	r24, Y+1	; 0x01
    14e8:	28 2f       	mov	r18, r24
    14ea:	30 e0       	ldi	r19, 0x00	; 0
    14ec:	3c 83       	std	Y+4, r19	; 0x04
    14ee:	2b 83       	std	Y+3, r18	; 0x03
    14f0:	8b 81       	ldd	r24, Y+3	; 0x03
    14f2:	9c 81       	ldd	r25, Y+4	; 0x04
    14f4:	81 30       	cpi	r24, 0x01	; 1
    14f6:	91 05       	cpc	r25, r1
    14f8:	d1 f0       	breq	.+52     	; 0x152e <DIO_SETPortValue+0x58>
    14fa:	2b 81       	ldd	r18, Y+3	; 0x03
    14fc:	3c 81       	ldd	r19, Y+4	; 0x04
    14fe:	22 30       	cpi	r18, 0x02	; 2
    1500:	31 05       	cpc	r19, r1
    1502:	2c f4       	brge	.+10     	; 0x150e <DIO_SETPortValue+0x38>
    1504:	8b 81       	ldd	r24, Y+3	; 0x03
    1506:	9c 81       	ldd	r25, Y+4	; 0x04
    1508:	00 97       	sbiw	r24, 0x00	; 0
    150a:	61 f0       	breq	.+24     	; 0x1524 <DIO_SETPortValue+0x4e>
    150c:	1e c0       	rjmp	.+60     	; 0x154a <DIO_SETPortValue+0x74>
    150e:	2b 81       	ldd	r18, Y+3	; 0x03
    1510:	3c 81       	ldd	r19, Y+4	; 0x04
    1512:	22 30       	cpi	r18, 0x02	; 2
    1514:	31 05       	cpc	r19, r1
    1516:	81 f0       	breq	.+32     	; 0x1538 <DIO_SETPortValue+0x62>
    1518:	8b 81       	ldd	r24, Y+3	; 0x03
    151a:	9c 81       	ldd	r25, Y+4	; 0x04
    151c:	83 30       	cpi	r24, 0x03	; 3
    151e:	91 05       	cpc	r25, r1
    1520:	81 f0       	breq	.+32     	; 0x1542 <DIO_SETPortValue+0x6c>
    1522:	13 c0       	rjmp	.+38     	; 0x154a <DIO_SETPortValue+0x74>
			{
			case PORTA_ID : PORTA_REG = PortValue;    break;
    1524:	eb e3       	ldi	r30, 0x3B	; 59
    1526:	f0 e0       	ldi	r31, 0x00	; 0
    1528:	8a 81       	ldd	r24, Y+2	; 0x02
    152a:	80 83       	st	Z, r24
    152c:	0e c0       	rjmp	.+28     	; 0x154a <DIO_SETPortValue+0x74>
			case PORTB_ID : PORTB_REG = PortValue;    break;
    152e:	e8 e3       	ldi	r30, 0x38	; 56
    1530:	f0 e0       	ldi	r31, 0x00	; 0
    1532:	8a 81       	ldd	r24, Y+2	; 0x02
    1534:	80 83       	st	Z, r24
    1536:	09 c0       	rjmp	.+18     	; 0x154a <DIO_SETPortValue+0x74>
			case PORTC_ID : PORTC_REG = PortValue;    break;
    1538:	e5 e3       	ldi	r30, 0x35	; 53
    153a:	f0 e0       	ldi	r31, 0x00	; 0
    153c:	8a 81       	ldd	r24, Y+2	; 0x02
    153e:	80 83       	st	Z, r24
    1540:	04 c0       	rjmp	.+8      	; 0x154a <DIO_SETPortValue+0x74>
			case PORTD_ID : PORTD_REG = PortValue;    break;
    1542:	e2 e3       	ldi	r30, 0x32	; 50
    1544:	f0 e0       	ldi	r31, 0x00	; 0
    1546:	8a 81       	ldd	r24, Y+2	; 0x02
    1548:	80 83       	st	Z, r24
			}

}
    154a:	0f 90       	pop	r0
    154c:	0f 90       	pop	r0
    154e:	0f 90       	pop	r0
    1550:	0f 90       	pop	r0
    1552:	cf 91       	pop	r28
    1554:	df 91       	pop	r29
    1556:	08 95       	ret

00001558 <DIO_TogglingPin>:

void DIO_TogglingPin(u8 PORT_ID , u8 PIN_ID)
{
    1558:	df 93       	push	r29
    155a:	cf 93       	push	r28
    155c:	00 d0       	rcall	.+0      	; 0x155e <DIO_TogglingPin+0x6>
    155e:	00 d0       	rcall	.+0      	; 0x1560 <DIO_TogglingPin+0x8>
    1560:	cd b7       	in	r28, 0x3d	; 61
    1562:	de b7       	in	r29, 0x3e	; 62
    1564:	89 83       	std	Y+1, r24	; 0x01
    1566:	6a 83       	std	Y+2, r22	; 0x02
		switch(PORT_ID)
    1568:	89 81       	ldd	r24, Y+1	; 0x01
    156a:	28 2f       	mov	r18, r24
    156c:	30 e0       	ldi	r19, 0x00	; 0
    156e:	3c 83       	std	Y+4, r19	; 0x04
    1570:	2b 83       	std	Y+3, r18	; 0x03
    1572:	8b 81       	ldd	r24, Y+3	; 0x03
    1574:	9c 81       	ldd	r25, Y+4	; 0x04
    1576:	81 30       	cpi	r24, 0x01	; 1
    1578:	91 05       	cpc	r25, r1
    157a:	49 f1       	breq	.+82     	; 0x15ce <DIO_TogglingPin+0x76>
    157c:	2b 81       	ldd	r18, Y+3	; 0x03
    157e:	3c 81       	ldd	r19, Y+4	; 0x04
    1580:	22 30       	cpi	r18, 0x02	; 2
    1582:	31 05       	cpc	r19, r1
    1584:	2c f4       	brge	.+10     	; 0x1590 <DIO_TogglingPin+0x38>
    1586:	8b 81       	ldd	r24, Y+3	; 0x03
    1588:	9c 81       	ldd	r25, Y+4	; 0x04
    158a:	00 97       	sbiw	r24, 0x00	; 0
    158c:	61 f0       	breq	.+24     	; 0x15a6 <DIO_TogglingPin+0x4e>
    158e:	5a c0       	rjmp	.+180    	; 0x1644 <DIO_TogglingPin+0xec>
    1590:	2b 81       	ldd	r18, Y+3	; 0x03
    1592:	3c 81       	ldd	r19, Y+4	; 0x04
    1594:	22 30       	cpi	r18, 0x02	; 2
    1596:	31 05       	cpc	r19, r1
    1598:	71 f1       	breq	.+92     	; 0x15f6 <DIO_TogglingPin+0x9e>
    159a:	8b 81       	ldd	r24, Y+3	; 0x03
    159c:	9c 81       	ldd	r25, Y+4	; 0x04
    159e:	83 30       	cpi	r24, 0x03	; 3
    15a0:	91 05       	cpc	r25, r1
    15a2:	e9 f1       	breq	.+122    	; 0x161e <DIO_TogglingPin+0xc6>
    15a4:	4f c0       	rjmp	.+158    	; 0x1644 <DIO_TogglingPin+0xec>
		{
			case PORTA_ID : TOG_BIT(PORTA_REG,PIN_ID);  break;
    15a6:	ab e3       	ldi	r26, 0x3B	; 59
    15a8:	b0 e0       	ldi	r27, 0x00	; 0
    15aa:	eb e3       	ldi	r30, 0x3B	; 59
    15ac:	f0 e0       	ldi	r31, 0x00	; 0
    15ae:	80 81       	ld	r24, Z
    15b0:	48 2f       	mov	r20, r24
    15b2:	8a 81       	ldd	r24, Y+2	; 0x02
    15b4:	28 2f       	mov	r18, r24
    15b6:	30 e0       	ldi	r19, 0x00	; 0
    15b8:	81 e0       	ldi	r24, 0x01	; 1
    15ba:	90 e0       	ldi	r25, 0x00	; 0
    15bc:	02 2e       	mov	r0, r18
    15be:	02 c0       	rjmp	.+4      	; 0x15c4 <DIO_TogglingPin+0x6c>
    15c0:	88 0f       	add	r24, r24
    15c2:	99 1f       	adc	r25, r25
    15c4:	0a 94       	dec	r0
    15c6:	e2 f7       	brpl	.-8      	; 0x15c0 <DIO_TogglingPin+0x68>
    15c8:	84 27       	eor	r24, r20
    15ca:	8c 93       	st	X, r24
    15cc:	3b c0       	rjmp	.+118    	; 0x1644 <DIO_TogglingPin+0xec>
			case PORTB_ID : TOG_BIT(PORTB_REG,PIN_ID);  break;
    15ce:	a8 e3       	ldi	r26, 0x38	; 56
    15d0:	b0 e0       	ldi	r27, 0x00	; 0
    15d2:	e8 e3       	ldi	r30, 0x38	; 56
    15d4:	f0 e0       	ldi	r31, 0x00	; 0
    15d6:	80 81       	ld	r24, Z
    15d8:	48 2f       	mov	r20, r24
    15da:	8a 81       	ldd	r24, Y+2	; 0x02
    15dc:	28 2f       	mov	r18, r24
    15de:	30 e0       	ldi	r19, 0x00	; 0
    15e0:	81 e0       	ldi	r24, 0x01	; 1
    15e2:	90 e0       	ldi	r25, 0x00	; 0
    15e4:	02 2e       	mov	r0, r18
    15e6:	02 c0       	rjmp	.+4      	; 0x15ec <DIO_TogglingPin+0x94>
    15e8:	88 0f       	add	r24, r24
    15ea:	99 1f       	adc	r25, r25
    15ec:	0a 94       	dec	r0
    15ee:	e2 f7       	brpl	.-8      	; 0x15e8 <DIO_TogglingPin+0x90>
    15f0:	84 27       	eor	r24, r20
    15f2:	8c 93       	st	X, r24
    15f4:	27 c0       	rjmp	.+78     	; 0x1644 <DIO_TogglingPin+0xec>
			case PORTC_ID : TOG_BIT(PORTC_REG,PIN_ID);  break;
    15f6:	a5 e3       	ldi	r26, 0x35	; 53
    15f8:	b0 e0       	ldi	r27, 0x00	; 0
    15fa:	e5 e3       	ldi	r30, 0x35	; 53
    15fc:	f0 e0       	ldi	r31, 0x00	; 0
    15fe:	80 81       	ld	r24, Z
    1600:	48 2f       	mov	r20, r24
    1602:	8a 81       	ldd	r24, Y+2	; 0x02
    1604:	28 2f       	mov	r18, r24
    1606:	30 e0       	ldi	r19, 0x00	; 0
    1608:	81 e0       	ldi	r24, 0x01	; 1
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	02 2e       	mov	r0, r18
    160e:	02 c0       	rjmp	.+4      	; 0x1614 <DIO_TogglingPin+0xbc>
    1610:	88 0f       	add	r24, r24
    1612:	99 1f       	adc	r25, r25
    1614:	0a 94       	dec	r0
    1616:	e2 f7       	brpl	.-8      	; 0x1610 <DIO_TogglingPin+0xb8>
    1618:	84 27       	eor	r24, r20
    161a:	8c 93       	st	X, r24
    161c:	13 c0       	rjmp	.+38     	; 0x1644 <DIO_TogglingPin+0xec>
			case PORTD_ID : TOG_BIT(PORTD_REG,PIN_ID);  break;
    161e:	a2 e3       	ldi	r26, 0x32	; 50
    1620:	b0 e0       	ldi	r27, 0x00	; 0
    1622:	e2 e3       	ldi	r30, 0x32	; 50
    1624:	f0 e0       	ldi	r31, 0x00	; 0
    1626:	80 81       	ld	r24, Z
    1628:	48 2f       	mov	r20, r24
    162a:	8a 81       	ldd	r24, Y+2	; 0x02
    162c:	28 2f       	mov	r18, r24
    162e:	30 e0       	ldi	r19, 0x00	; 0
    1630:	81 e0       	ldi	r24, 0x01	; 1
    1632:	90 e0       	ldi	r25, 0x00	; 0
    1634:	02 2e       	mov	r0, r18
    1636:	02 c0       	rjmp	.+4      	; 0x163c <DIO_TogglingPin+0xe4>
    1638:	88 0f       	add	r24, r24
    163a:	99 1f       	adc	r25, r25
    163c:	0a 94       	dec	r0
    163e:	e2 f7       	brpl	.-8      	; 0x1638 <DIO_TogglingPin+0xe0>
    1640:	84 27       	eor	r24, r20
    1642:	8c 93       	st	X, r24
		}

}
    1644:	0f 90       	pop	r0
    1646:	0f 90       	pop	r0
    1648:	0f 90       	pop	r0
    164a:	0f 90       	pop	r0
    164c:	cf 91       	pop	r28
    164e:	df 91       	pop	r29
    1650:	08 95       	ret

00001652 <DIOReadPinValue>:

u8 DIOReadPinValue(u8 PORT_ID , u8 PIN_ID)
{
    1652:	df 93       	push	r29
    1654:	cf 93       	push	r28
    1656:	00 d0       	rcall	.+0      	; 0x1658 <DIOReadPinValue+0x6>
    1658:	00 d0       	rcall	.+0      	; 0x165a <DIOReadPinValue+0x8>
    165a:	0f 92       	push	r0
    165c:	cd b7       	in	r28, 0x3d	; 61
    165e:	de b7       	in	r29, 0x3e	; 62
    1660:	8a 83       	std	Y+2, r24	; 0x02
    1662:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_PinValue;
	switch(PORT_ID)
    1664:	8a 81       	ldd	r24, Y+2	; 0x02
    1666:	28 2f       	mov	r18, r24
    1668:	30 e0       	ldi	r19, 0x00	; 0
    166a:	3d 83       	std	Y+5, r19	; 0x05
    166c:	2c 83       	std	Y+4, r18	; 0x04
    166e:	4c 81       	ldd	r20, Y+4	; 0x04
    1670:	5d 81       	ldd	r21, Y+5	; 0x05
    1672:	41 30       	cpi	r20, 0x01	; 1
    1674:	51 05       	cpc	r21, r1
    1676:	41 f1       	breq	.+80     	; 0x16c8 <DIOReadPinValue+0x76>
    1678:	8c 81       	ldd	r24, Y+4	; 0x04
    167a:	9d 81       	ldd	r25, Y+5	; 0x05
    167c:	82 30       	cpi	r24, 0x02	; 2
    167e:	91 05       	cpc	r25, r1
    1680:	34 f4       	brge	.+12     	; 0x168e <DIOReadPinValue+0x3c>
    1682:	2c 81       	ldd	r18, Y+4	; 0x04
    1684:	3d 81       	ldd	r19, Y+5	; 0x05
    1686:	21 15       	cp	r18, r1
    1688:	31 05       	cpc	r19, r1
    168a:	61 f0       	breq	.+24     	; 0x16a4 <DIOReadPinValue+0x52>
    168c:	52 c0       	rjmp	.+164    	; 0x1732 <DIOReadPinValue+0xe0>
    168e:	4c 81       	ldd	r20, Y+4	; 0x04
    1690:	5d 81       	ldd	r21, Y+5	; 0x05
    1692:	42 30       	cpi	r20, 0x02	; 2
    1694:	51 05       	cpc	r21, r1
    1696:	51 f1       	breq	.+84     	; 0x16ec <DIOReadPinValue+0x9a>
    1698:	8c 81       	ldd	r24, Y+4	; 0x04
    169a:	9d 81       	ldd	r25, Y+5	; 0x05
    169c:	83 30       	cpi	r24, 0x03	; 3
    169e:	91 05       	cpc	r25, r1
    16a0:	b9 f1       	breq	.+110    	; 0x1710 <DIOReadPinValue+0xbe>
    16a2:	47 c0       	rjmp	.+142    	; 0x1732 <DIOReadPinValue+0xe0>
	{
		case PORTA_ID : Local_PinValue = GET_BIT(PINA_REG,PIN_ID);    break;
    16a4:	e9 e3       	ldi	r30, 0x39	; 57
    16a6:	f0 e0       	ldi	r31, 0x00	; 0
    16a8:	80 81       	ld	r24, Z
    16aa:	28 2f       	mov	r18, r24
    16ac:	30 e0       	ldi	r19, 0x00	; 0
    16ae:	8b 81       	ldd	r24, Y+3	; 0x03
    16b0:	88 2f       	mov	r24, r24
    16b2:	90 e0       	ldi	r25, 0x00	; 0
    16b4:	a9 01       	movw	r20, r18
    16b6:	02 c0       	rjmp	.+4      	; 0x16bc <DIOReadPinValue+0x6a>
    16b8:	55 95       	asr	r21
    16ba:	47 95       	ror	r20
    16bc:	8a 95       	dec	r24
    16be:	e2 f7       	brpl	.-8      	; 0x16b8 <DIOReadPinValue+0x66>
    16c0:	ca 01       	movw	r24, r20
    16c2:	81 70       	andi	r24, 0x01	; 1
    16c4:	89 83       	std	Y+1, r24	; 0x01
    16c6:	35 c0       	rjmp	.+106    	; 0x1732 <DIOReadPinValue+0xe0>
		case PORTB_ID : Local_PinValue = GET_BIT(PINB_REG,PIN_ID);    break;
    16c8:	e6 e3       	ldi	r30, 0x36	; 54
    16ca:	f0 e0       	ldi	r31, 0x00	; 0
    16cc:	80 81       	ld	r24, Z
    16ce:	28 2f       	mov	r18, r24
    16d0:	30 e0       	ldi	r19, 0x00	; 0
    16d2:	8b 81       	ldd	r24, Y+3	; 0x03
    16d4:	88 2f       	mov	r24, r24
    16d6:	90 e0       	ldi	r25, 0x00	; 0
    16d8:	a9 01       	movw	r20, r18
    16da:	02 c0       	rjmp	.+4      	; 0x16e0 <DIOReadPinValue+0x8e>
    16dc:	55 95       	asr	r21
    16de:	47 95       	ror	r20
    16e0:	8a 95       	dec	r24
    16e2:	e2 f7       	brpl	.-8      	; 0x16dc <DIOReadPinValue+0x8a>
    16e4:	ca 01       	movw	r24, r20
    16e6:	81 70       	andi	r24, 0x01	; 1
    16e8:	89 83       	std	Y+1, r24	; 0x01
    16ea:	23 c0       	rjmp	.+70     	; 0x1732 <DIOReadPinValue+0xe0>
		case PORTC_ID : Local_PinValue = GET_BIT(PINC_REG,PIN_ID);    break;
    16ec:	e3 e3       	ldi	r30, 0x33	; 51
    16ee:	f0 e0       	ldi	r31, 0x00	; 0
    16f0:	80 81       	ld	r24, Z
    16f2:	28 2f       	mov	r18, r24
    16f4:	30 e0       	ldi	r19, 0x00	; 0
    16f6:	8b 81       	ldd	r24, Y+3	; 0x03
    16f8:	88 2f       	mov	r24, r24
    16fa:	90 e0       	ldi	r25, 0x00	; 0
    16fc:	a9 01       	movw	r20, r18
    16fe:	02 c0       	rjmp	.+4      	; 0x1704 <DIOReadPinValue+0xb2>
    1700:	55 95       	asr	r21
    1702:	47 95       	ror	r20
    1704:	8a 95       	dec	r24
    1706:	e2 f7       	brpl	.-8      	; 0x1700 <DIOReadPinValue+0xae>
    1708:	ca 01       	movw	r24, r20
    170a:	81 70       	andi	r24, 0x01	; 1
    170c:	89 83       	std	Y+1, r24	; 0x01
    170e:	11 c0       	rjmp	.+34     	; 0x1732 <DIOReadPinValue+0xe0>
		case PORTD_ID : Local_PinValue = GET_BIT(PIND_REG,PIN_ID);    break;
    1710:	e0 e3       	ldi	r30, 0x30	; 48
    1712:	f0 e0       	ldi	r31, 0x00	; 0
    1714:	80 81       	ld	r24, Z
    1716:	28 2f       	mov	r18, r24
    1718:	30 e0       	ldi	r19, 0x00	; 0
    171a:	8b 81       	ldd	r24, Y+3	; 0x03
    171c:	88 2f       	mov	r24, r24
    171e:	90 e0       	ldi	r25, 0x00	; 0
    1720:	a9 01       	movw	r20, r18
    1722:	02 c0       	rjmp	.+4      	; 0x1728 <DIOReadPinValue+0xd6>
    1724:	55 95       	asr	r21
    1726:	47 95       	ror	r20
    1728:	8a 95       	dec	r24
    172a:	e2 f7       	brpl	.-8      	; 0x1724 <DIOReadPinValue+0xd2>
    172c:	ca 01       	movw	r24, r20
    172e:	81 70       	andi	r24, 0x01	; 1
    1730:	89 83       	std	Y+1, r24	; 0x01
	}

	return Local_PinValue;
    1732:	89 81       	ldd	r24, Y+1	; 0x01
}
    1734:	0f 90       	pop	r0
    1736:	0f 90       	pop	r0
    1738:	0f 90       	pop	r0
    173a:	0f 90       	pop	r0
    173c:	0f 90       	pop	r0
    173e:	cf 91       	pop	r28
    1740:	df 91       	pop	r29
    1742:	08 95       	ret

00001744 <ADC_VoidInit>:
#include "ADC_Private.h"

static void (*ADC_CallBack)(void) = {NULL};

void ADC_VoidInit(void)
{
    1744:	df 93       	push	r29
    1746:	cf 93       	push	r28
    1748:	cd b7       	in	r28, 0x3d	; 61
    174a:	de b7       	in	r29, 0x3e	; 62
	/*	Voltage Reference Selections for ADC	*/
	CLR_BIT(ADMUX,7);
    174c:	a7 e2       	ldi	r26, 0x27	; 39
    174e:	b0 e0       	ldi	r27, 0x00	; 0
    1750:	e7 e2       	ldi	r30, 0x27	; 39
    1752:	f0 e0       	ldi	r31, 0x00	; 0
    1754:	80 81       	ld	r24, Z
    1756:	8f 77       	andi	r24, 0x7F	; 127
    1758:	8c 93       	st	X, r24
	SET_BIT(ADMUX,6);
    175a:	a7 e2       	ldi	r26, 0x27	; 39
    175c:	b0 e0       	ldi	r27, 0x00	; 0
    175e:	e7 e2       	ldi	r30, 0x27	; 39
    1760:	f0 e0       	ldi	r31, 0x00	; 0
    1762:	80 81       	ld	r24, Z
    1764:	80 64       	ori	r24, 0x40	; 64
    1766:	8c 93       	st	X, r24

	/*	ADC Left Adjust Result(data managing)	*/
	CLR_BIT(ADMUX,5);
    1768:	a7 e2       	ldi	r26, 0x27	; 39
    176a:	b0 e0       	ldi	r27, 0x00	; 0
    176c:	e7 e2       	ldi	r30, 0x27	; 39
    176e:	f0 e0       	ldi	r31, 0x00	; 0
    1770:	80 81       	ld	r24, Z
    1772:	8f 7d       	andi	r24, 0xDF	; 223
    1774:	8c 93       	st	X, r24

	/*	set the prescaller	*/
	SET_BIT(ADCSRA,0);
    1776:	a6 e2       	ldi	r26, 0x26	; 38
    1778:	b0 e0       	ldi	r27, 0x00	; 0
    177a:	e6 e2       	ldi	r30, 0x26	; 38
    177c:	f0 e0       	ldi	r31, 0x00	; 0
    177e:	80 81       	ld	r24, Z
    1780:	81 60       	ori	r24, 0x01	; 1
    1782:	8c 93       	st	X, r24
	SET_BIT(ADCSRA,1);
    1784:	a6 e2       	ldi	r26, 0x26	; 38
    1786:	b0 e0       	ldi	r27, 0x00	; 0
    1788:	e6 e2       	ldi	r30, 0x26	; 38
    178a:	f0 e0       	ldi	r31, 0x00	; 0
    178c:	80 81       	ld	r24, Z
    178e:	82 60       	ori	r24, 0x02	; 2
    1790:	8c 93       	st	X, r24
	SET_BIT(ADCSRA,2);
    1792:	a6 e2       	ldi	r26, 0x26	; 38
    1794:	b0 e0       	ldi	r27, 0x00	; 0
    1796:	e6 e2       	ldi	r30, 0x26	; 38
    1798:	f0 e0       	ldi	r31, 0x00	; 0
    179a:	80 81       	ld	r24, Z
    179c:	84 60       	ori	r24, 0x04	; 4
    179e:	8c 93       	st	X, r24

	/*	interrput enable	*/
	SET_BIT(ADCSRA,3);
    17a0:	a6 e2       	ldi	r26, 0x26	; 38
    17a2:	b0 e0       	ldi	r27, 0x00	; 0
    17a4:	e6 e2       	ldi	r30, 0x26	; 38
    17a6:	f0 e0       	ldi	r31, 0x00	; 0
    17a8:	80 81       	ld	r24, Z
    17aa:	88 60       	ori	r24, 0x08	; 8
    17ac:	8c 93       	st	X, r24

	/*	 ADEN: ADC Enable	*/
	SET_BIT(ADCSRA,7);
    17ae:	a6 e2       	ldi	r26, 0x26	; 38
    17b0:	b0 e0       	ldi	r27, 0x00	; 0
    17b2:	e6 e2       	ldi	r30, 0x26	; 38
    17b4:	f0 e0       	ldi	r31, 0x00	; 0
    17b6:	80 81       	ld	r24, Z
    17b8:	80 68       	ori	r24, 0x80	; 128
    17ba:	8c 93       	st	X, r24
}
    17bc:	cf 91       	pop	r28
    17be:	df 91       	pop	r29
    17c0:	08 95       	ret

000017c2 <ADC_voidChannelSellect>:

void ADC_voidChannelSellect(u8 copy_u8ChannelSellect )
{
    17c2:	df 93       	push	r29
    17c4:	cf 93       	push	r28
    17c6:	0f 92       	push	r0
    17c8:	cd b7       	in	r28, 0x3d	; 61
    17ca:	de b7       	in	r29, 0x3e	; 62
    17cc:	89 83       	std	Y+1, r24	; 0x01
	/*	Input Channel and Gain Selections
	 *  clear the first 5 bits
	 *  set the first 5 bits by the select channel from the user
	 * */
	ADMUX &= 0b11100000;
    17ce:	a7 e2       	ldi	r26, 0x27	; 39
    17d0:	b0 e0       	ldi	r27, 0x00	; 0
    17d2:	e7 e2       	ldi	r30, 0x27	; 39
    17d4:	f0 e0       	ldi	r31, 0x00	; 0
    17d6:	80 81       	ld	r24, Z
    17d8:	80 7e       	andi	r24, 0xE0	; 224
    17da:	8c 93       	st	X, r24
	ADMUX |= copy_u8ChannelSellect;
    17dc:	a7 e2       	ldi	r26, 0x27	; 39
    17de:	b0 e0       	ldi	r27, 0x00	; 0
    17e0:	e7 e2       	ldi	r30, 0x27	; 39
    17e2:	f0 e0       	ldi	r31, 0x00	; 0
    17e4:	90 81       	ld	r25, Z
    17e6:	89 81       	ldd	r24, Y+1	; 0x01
    17e8:	89 2b       	or	r24, r25
    17ea:	8c 93       	st	X, r24
}
    17ec:	0f 90       	pop	r0
    17ee:	cf 91       	pop	r28
    17f0:	df 91       	pop	r29
    17f2:	08 95       	ret

000017f4 <ADC_StartConversion>:

void ADC_StartConversion(u16 *copy_Pu8Data)
{
    17f4:	df 93       	push	r29
    17f6:	cf 93       	push	r28
    17f8:	00 d0       	rcall	.+0      	; 0x17fa <ADC_StartConversion+0x6>
    17fa:	cd b7       	in	r28, 0x3d	; 61
    17fc:	de b7       	in	r29, 0x3e	; 62
    17fe:	9a 83       	std	Y+2, r25	; 0x02
    1800:	89 83       	std	Y+1, r24	; 0x01
	/*	start conversion	*/
	SET_BIT(ADCSRA,6);
    1802:	a6 e2       	ldi	r26, 0x26	; 38
    1804:	b0 e0       	ldi	r27, 0x00	; 0
    1806:	e6 e2       	ldi	r30, 0x26	; 38
    1808:	f0 e0       	ldi	r31, 0x00	; 0
    180a:	80 81       	ld	r24, Z
    180c:	80 64       	ori	r24, 0x40	; 64
    180e:	8c 93       	st	X, r24
	//while(GET_BIT(ADCSRA,4)==0);
	/*	clear the flage	*/
	//SET_BIT(ADCSRA,4);

	/*	return the data	*/
	*copy_Pu8Data=ADCL;
    1810:	e4 e2       	ldi	r30, 0x24	; 36
    1812:	f0 e0       	ldi	r31, 0x00	; 0
    1814:	80 81       	ld	r24, Z
    1816:	91 81       	ldd	r25, Z+1	; 0x01
    1818:	e9 81       	ldd	r30, Y+1	; 0x01
    181a:	fa 81       	ldd	r31, Y+2	; 0x02
    181c:	91 83       	std	Z+1, r25	; 0x01
    181e:	80 83       	st	Z, r24
}
    1820:	0f 90       	pop	r0
    1822:	0f 90       	pop	r0
    1824:	cf 91       	pop	r28
    1826:	df 91       	pop	r29
    1828:	08 95       	ret

0000182a <ADC_Clear_ADCReguster>:

void ADC_Clear_ADCReguster(void)
{
    182a:	df 93       	push	r29
    182c:	cf 93       	push	r28
    182e:	cd b7       	in	r28, 0x3d	; 61
    1830:	de b7       	in	r29, 0x3e	; 62
	ADCL=0x0000;
    1832:	e4 e2       	ldi	r30, 0x24	; 36
    1834:	f0 e0       	ldi	r31, 0x00	; 0
    1836:	11 82       	std	Z+1, r1	; 0x01
    1838:	10 82       	st	Z, r1
}
    183a:	cf 91       	pop	r28
    183c:	df 91       	pop	r29
    183e:	08 95       	ret

00001840 <ADC_voidSetCallBack>:

void ADC_voidSetCallBack(  void (*ptr_ext)(void) )
{
    1840:	df 93       	push	r29
    1842:	cf 93       	push	r28
    1844:	00 d0       	rcall	.+0      	; 0x1846 <ADC_voidSetCallBack+0x6>
    1846:	cd b7       	in	r28, 0x3d	; 61
    1848:	de b7       	in	r29, 0x3e	; 62
    184a:	9a 83       	std	Y+2, r25	; 0x02
    184c:	89 83       	std	Y+1, r24	; 0x01
	if(ptr_ext!=NULL)
    184e:	89 81       	ldd	r24, Y+1	; 0x01
    1850:	9a 81       	ldd	r25, Y+2	; 0x02
    1852:	00 97       	sbiw	r24, 0x00	; 0
    1854:	31 f0       	breq	.+12     	; 0x1862 <ADC_voidSetCallBack+0x22>
	ADC_CallBack = ptr_ext;
    1856:	89 81       	ldd	r24, Y+1	; 0x01
    1858:	9a 81       	ldd	r25, Y+2	; 0x02
    185a:	90 93 a5 00 	sts	0x00A5, r25
    185e:	80 93 a4 00 	sts	0x00A4, r24
}
    1862:	0f 90       	pop	r0
    1864:	0f 90       	pop	r0
    1866:	cf 91       	pop	r28
    1868:	df 91       	pop	r29
    186a:	08 95       	ret

0000186c <__vector_16>:

void __vector_16 ()
{
    186c:	1f 92       	push	r1
    186e:	0f 92       	push	r0
    1870:	0f b6       	in	r0, 0x3f	; 63
    1872:	0f 92       	push	r0
    1874:	11 24       	eor	r1, r1
    1876:	2f 93       	push	r18
    1878:	3f 93       	push	r19
    187a:	4f 93       	push	r20
    187c:	5f 93       	push	r21
    187e:	6f 93       	push	r22
    1880:	7f 93       	push	r23
    1882:	8f 93       	push	r24
    1884:	9f 93       	push	r25
    1886:	af 93       	push	r26
    1888:	bf 93       	push	r27
    188a:	ef 93       	push	r30
    188c:	ff 93       	push	r31
    188e:	df 93       	push	r29
    1890:	cf 93       	push	r28
    1892:	cd b7       	in	r28, 0x3d	; 61
    1894:	de b7       	in	r29, 0x3e	; 62
	ADC_CallBack();
    1896:	e0 91 a4 00 	lds	r30, 0x00A4
    189a:	f0 91 a5 00 	lds	r31, 0x00A5
    189e:	09 95       	icall
}
    18a0:	cf 91       	pop	r28
    18a2:	df 91       	pop	r29
    18a4:	ff 91       	pop	r31
    18a6:	ef 91       	pop	r30
    18a8:	bf 91       	pop	r27
    18aa:	af 91       	pop	r26
    18ac:	9f 91       	pop	r25
    18ae:	8f 91       	pop	r24
    18b0:	7f 91       	pop	r23
    18b2:	6f 91       	pop	r22
    18b4:	5f 91       	pop	r21
    18b6:	4f 91       	pop	r20
    18b8:	3f 91       	pop	r19
    18ba:	2f 91       	pop	r18
    18bc:	0f 90       	pop	r0
    18be:	0f be       	out	0x3f, r0	; 63
    18c0:	0f 90       	pop	r0
    18c2:	1f 90       	pop	r1
    18c4:	18 95       	reti

000018c6 <LCD_voidWriteBitsToSend>:
#include "LCD_Private.h"



void LCD_voidWriteBitsToSend(u8 copy_u8Byte)
{
    18c6:	df 93       	push	r29
    18c8:	cf 93       	push	r28
    18ca:	cd b7       	in	r28, 0x3d	; 61
    18cc:	de b7       	in	r29, 0x3e	; 62
    18ce:	e9 97       	sbiw	r28, 0x39	; 57
    18d0:	0f b6       	in	r0, 0x3f	; 63
    18d2:	f8 94       	cli
    18d4:	de bf       	out	0x3e, r29	; 62
    18d6:	0f be       	out	0x3f, r0	; 63
    18d8:	cd bf       	out	0x3d, r28	; 61
    18da:	89 af       	std	Y+57, r24	; 0x39

	//DIO_SETPinValue(RW_PORT,RW_PIN, LOW);
	DIO_SETPinValue(EN_PORT,EN_PIN, LOW);
    18dc:	80 e0       	ldi	r24, 0x00	; 0
    18de:	62 e0       	ldi	r22, 0x02	; 2
    18e0:	40 e0       	ldi	r20, 0x00	; 0
    18e2:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>




	DIO_SETPinValue(D7_PORT,D7_PIN, (copy_u8Byte>> 7) & 1);
    18e6:	89 ad       	ldd	r24, Y+57	; 0x39
    18e8:	98 2f       	mov	r25, r24
    18ea:	99 1f       	adc	r25, r25
    18ec:	99 27       	eor	r25, r25
    18ee:	99 1f       	adc	r25, r25
    18f0:	81 e0       	ldi	r24, 0x01	; 1
    18f2:	64 e0       	ldi	r22, 0x04	; 4
    18f4:	49 2f       	mov	r20, r25
    18f6:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
	DIO_SETPinValue(D6_PORT,D6_PIN, (copy_u8Byte>> 6) & 1);
    18fa:	89 ad       	ldd	r24, Y+57	; 0x39
    18fc:	82 95       	swap	r24
    18fe:	86 95       	lsr	r24
    1900:	86 95       	lsr	r24
    1902:	83 70       	andi	r24, 0x03	; 3
    1904:	98 2f       	mov	r25, r24
    1906:	91 70       	andi	r25, 0x01	; 1
    1908:	81 e0       	ldi	r24, 0x01	; 1
    190a:	62 e0       	ldi	r22, 0x02	; 2
    190c:	49 2f       	mov	r20, r25
    190e:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
	DIO_SETPinValue(D5_PORT,D5_PIN, (copy_u8Byte>> 5) & 1);
    1912:	89 ad       	ldd	r24, Y+57	; 0x39
    1914:	82 95       	swap	r24
    1916:	86 95       	lsr	r24
    1918:	87 70       	andi	r24, 0x07	; 7
    191a:	98 2f       	mov	r25, r24
    191c:	91 70       	andi	r25, 0x01	; 1
    191e:	81 e0       	ldi	r24, 0x01	; 1
    1920:	61 e0       	ldi	r22, 0x01	; 1
    1922:	49 2f       	mov	r20, r25
    1924:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
	DIO_SETPinValue(D4_PORT,D4_PIN, (copy_u8Byte>> 4) & 1);
    1928:	89 ad       	ldd	r24, Y+57	; 0x39
    192a:	82 95       	swap	r24
    192c:	8f 70       	andi	r24, 0x0F	; 15
    192e:	98 2f       	mov	r25, r24
    1930:	91 70       	andi	r25, 0x01	; 1
    1932:	81 e0       	ldi	r24, 0x01	; 1
    1934:	60 e0       	ldi	r22, 0x00	; 0
    1936:	49 2f       	mov	r20, r25
    1938:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>

	DIO_SETPinValue(EN_PORT,EN_PIN, HIGH);
    193c:	80 e0       	ldi	r24, 0x00	; 0
    193e:	62 e0       	ldi	r22, 0x02	; 2
    1940:	41 e0       	ldi	r20, 0x01	; 1
    1942:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
    1946:	80 e0       	ldi	r24, 0x00	; 0
    1948:	90 e0       	ldi	r25, 0x00	; 0
    194a:	a0 e8       	ldi	r26, 0x80	; 128
    194c:	bf e3       	ldi	r27, 0x3F	; 63
    194e:	8d ab       	std	Y+53, r24	; 0x35
    1950:	9e ab       	std	Y+54, r25	; 0x36
    1952:	af ab       	std	Y+55, r26	; 0x37
    1954:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1956:	6d a9       	ldd	r22, Y+53	; 0x35
    1958:	7e a9       	ldd	r23, Y+54	; 0x36
    195a:	8f a9       	ldd	r24, Y+55	; 0x37
    195c:	98 ad       	ldd	r25, Y+56	; 0x38
    195e:	20 e0       	ldi	r18, 0x00	; 0
    1960:	30 e0       	ldi	r19, 0x00	; 0
    1962:	4a e7       	ldi	r20, 0x7A	; 122
    1964:	55 e4       	ldi	r21, 0x45	; 69
    1966:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    196a:	dc 01       	movw	r26, r24
    196c:	cb 01       	movw	r24, r22
    196e:	89 ab       	std	Y+49, r24	; 0x31
    1970:	9a ab       	std	Y+50, r25	; 0x32
    1972:	ab ab       	std	Y+51, r26	; 0x33
    1974:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1976:	69 a9       	ldd	r22, Y+49	; 0x31
    1978:	7a a9       	ldd	r23, Y+50	; 0x32
    197a:	8b a9       	ldd	r24, Y+51	; 0x33
    197c:	9c a9       	ldd	r25, Y+52	; 0x34
    197e:	20 e0       	ldi	r18, 0x00	; 0
    1980:	30 e0       	ldi	r19, 0x00	; 0
    1982:	40 e8       	ldi	r20, 0x80	; 128
    1984:	5f e3       	ldi	r21, 0x3F	; 63
    1986:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    198a:	88 23       	and	r24, r24
    198c:	2c f4       	brge	.+10     	; 0x1998 <LCD_voidWriteBitsToSend+0xd2>
		__ticks = 1;
    198e:	81 e0       	ldi	r24, 0x01	; 1
    1990:	90 e0       	ldi	r25, 0x00	; 0
    1992:	98 ab       	std	Y+48, r25	; 0x30
    1994:	8f a7       	std	Y+47, r24	; 0x2f
    1996:	3f c0       	rjmp	.+126    	; 0x1a16 <LCD_voidWriteBitsToSend+0x150>
	else if (__tmp > 65535)
    1998:	69 a9       	ldd	r22, Y+49	; 0x31
    199a:	7a a9       	ldd	r23, Y+50	; 0x32
    199c:	8b a9       	ldd	r24, Y+51	; 0x33
    199e:	9c a9       	ldd	r25, Y+52	; 0x34
    19a0:	20 e0       	ldi	r18, 0x00	; 0
    19a2:	3f ef       	ldi	r19, 0xFF	; 255
    19a4:	4f e7       	ldi	r20, 0x7F	; 127
    19a6:	57 e4       	ldi	r21, 0x47	; 71
    19a8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    19ac:	18 16       	cp	r1, r24
    19ae:	4c f5       	brge	.+82     	; 0x1a02 <LCD_voidWriteBitsToSend+0x13c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    19b0:	6d a9       	ldd	r22, Y+53	; 0x35
    19b2:	7e a9       	ldd	r23, Y+54	; 0x36
    19b4:	8f a9       	ldd	r24, Y+55	; 0x37
    19b6:	98 ad       	ldd	r25, Y+56	; 0x38
    19b8:	20 e0       	ldi	r18, 0x00	; 0
    19ba:	30 e0       	ldi	r19, 0x00	; 0
    19bc:	40 e2       	ldi	r20, 0x20	; 32
    19be:	51 e4       	ldi	r21, 0x41	; 65
    19c0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    19c4:	dc 01       	movw	r26, r24
    19c6:	cb 01       	movw	r24, r22
    19c8:	bc 01       	movw	r22, r24
    19ca:	cd 01       	movw	r24, r26
    19cc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19d0:	dc 01       	movw	r26, r24
    19d2:	cb 01       	movw	r24, r22
    19d4:	98 ab       	std	Y+48, r25	; 0x30
    19d6:	8f a7       	std	Y+47, r24	; 0x2f
    19d8:	0f c0       	rjmp	.+30     	; 0x19f8 <LCD_voidWriteBitsToSend+0x132>
    19da:	80 e9       	ldi	r24, 0x90	; 144
    19dc:	91 e0       	ldi	r25, 0x01	; 1
    19de:	9e a7       	std	Y+46, r25	; 0x2e
    19e0:	8d a7       	std	Y+45, r24	; 0x2d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    19e2:	8d a5       	ldd	r24, Y+45	; 0x2d
    19e4:	9e a5       	ldd	r25, Y+46	; 0x2e
    19e6:	01 97       	sbiw	r24, 0x01	; 1
    19e8:	f1 f7       	brne	.-4      	; 0x19e6 <LCD_voidWriteBitsToSend+0x120>
    19ea:	9e a7       	std	Y+46, r25	; 0x2e
    19ec:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19ee:	8f a5       	ldd	r24, Y+47	; 0x2f
    19f0:	98 a9       	ldd	r25, Y+48	; 0x30
    19f2:	01 97       	sbiw	r24, 0x01	; 1
    19f4:	98 ab       	std	Y+48, r25	; 0x30
    19f6:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19f8:	8f a5       	ldd	r24, Y+47	; 0x2f
    19fa:	98 a9       	ldd	r25, Y+48	; 0x30
    19fc:	00 97       	sbiw	r24, 0x00	; 0
    19fe:	69 f7       	brne	.-38     	; 0x19da <LCD_voidWriteBitsToSend+0x114>
    1a00:	14 c0       	rjmp	.+40     	; 0x1a2a <LCD_voidWriteBitsToSend+0x164>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a02:	69 a9       	ldd	r22, Y+49	; 0x31
    1a04:	7a a9       	ldd	r23, Y+50	; 0x32
    1a06:	8b a9       	ldd	r24, Y+51	; 0x33
    1a08:	9c a9       	ldd	r25, Y+52	; 0x34
    1a0a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a0e:	dc 01       	movw	r26, r24
    1a10:	cb 01       	movw	r24, r22
    1a12:	98 ab       	std	Y+48, r25	; 0x30
    1a14:	8f a7       	std	Y+47, r24	; 0x2f
    1a16:	8f a5       	ldd	r24, Y+47	; 0x2f
    1a18:	98 a9       	ldd	r25, Y+48	; 0x30
    1a1a:	9c a7       	std	Y+44, r25	; 0x2c
    1a1c:	8b a7       	std	Y+43, r24	; 0x2b
    1a1e:	8b a5       	ldd	r24, Y+43	; 0x2b
    1a20:	9c a5       	ldd	r25, Y+44	; 0x2c
    1a22:	01 97       	sbiw	r24, 0x01	; 1
    1a24:	f1 f7       	brne	.-4      	; 0x1a22 <LCD_voidWriteBitsToSend+0x15c>
    1a26:	9c a7       	std	Y+44, r25	; 0x2c
    1a28:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1);
	DIO_SETPinValue(EN_PORT,EN_PIN, LOW);
    1a2a:	80 e0       	ldi	r24, 0x00	; 0
    1a2c:	62 e0       	ldi	r22, 0x02	; 2
    1a2e:	40 e0       	ldi	r20, 0x00	; 0
    1a30:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
    1a34:	80 e0       	ldi	r24, 0x00	; 0
    1a36:	90 e0       	ldi	r25, 0x00	; 0
    1a38:	a0 ef       	ldi	r26, 0xF0	; 240
    1a3a:	b1 e4       	ldi	r27, 0x41	; 65
    1a3c:	8f a3       	std	Y+39, r24	; 0x27
    1a3e:	98 a7       	std	Y+40, r25	; 0x28
    1a40:	a9 a7       	std	Y+41, r26	; 0x29
    1a42:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1a44:	6f a1       	ldd	r22, Y+39	; 0x27
    1a46:	78 a5       	ldd	r23, Y+40	; 0x28
    1a48:	89 a5       	ldd	r24, Y+41	; 0x29
    1a4a:	9a a5       	ldd	r25, Y+42	; 0x2a
    1a4c:	20 e0       	ldi	r18, 0x00	; 0
    1a4e:	30 e0       	ldi	r19, 0x00	; 0
    1a50:	4a e7       	ldi	r20, 0x7A	; 122
    1a52:	55 e4       	ldi	r21, 0x45	; 69
    1a54:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a58:	dc 01       	movw	r26, r24
    1a5a:	cb 01       	movw	r24, r22
    1a5c:	8b a3       	std	Y+35, r24	; 0x23
    1a5e:	9c a3       	std	Y+36, r25	; 0x24
    1a60:	ad a3       	std	Y+37, r26	; 0x25
    1a62:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1a64:	6b a1       	ldd	r22, Y+35	; 0x23
    1a66:	7c a1       	ldd	r23, Y+36	; 0x24
    1a68:	8d a1       	ldd	r24, Y+37	; 0x25
    1a6a:	9e a1       	ldd	r25, Y+38	; 0x26
    1a6c:	20 e0       	ldi	r18, 0x00	; 0
    1a6e:	30 e0       	ldi	r19, 0x00	; 0
    1a70:	40 e8       	ldi	r20, 0x80	; 128
    1a72:	5f e3       	ldi	r21, 0x3F	; 63
    1a74:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1a78:	88 23       	and	r24, r24
    1a7a:	2c f4       	brge	.+10     	; 0x1a86 <LCD_voidWriteBitsToSend+0x1c0>
		__ticks = 1;
    1a7c:	81 e0       	ldi	r24, 0x01	; 1
    1a7e:	90 e0       	ldi	r25, 0x00	; 0
    1a80:	9a a3       	std	Y+34, r25	; 0x22
    1a82:	89 a3       	std	Y+33, r24	; 0x21
    1a84:	3f c0       	rjmp	.+126    	; 0x1b04 <LCD_voidWriteBitsToSend+0x23e>
	else if (__tmp > 65535)
    1a86:	6b a1       	ldd	r22, Y+35	; 0x23
    1a88:	7c a1       	ldd	r23, Y+36	; 0x24
    1a8a:	8d a1       	ldd	r24, Y+37	; 0x25
    1a8c:	9e a1       	ldd	r25, Y+38	; 0x26
    1a8e:	20 e0       	ldi	r18, 0x00	; 0
    1a90:	3f ef       	ldi	r19, 0xFF	; 255
    1a92:	4f e7       	ldi	r20, 0x7F	; 127
    1a94:	57 e4       	ldi	r21, 0x47	; 71
    1a96:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1a9a:	18 16       	cp	r1, r24
    1a9c:	4c f5       	brge	.+82     	; 0x1af0 <LCD_voidWriteBitsToSend+0x22a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a9e:	6f a1       	ldd	r22, Y+39	; 0x27
    1aa0:	78 a5       	ldd	r23, Y+40	; 0x28
    1aa2:	89 a5       	ldd	r24, Y+41	; 0x29
    1aa4:	9a a5       	ldd	r25, Y+42	; 0x2a
    1aa6:	20 e0       	ldi	r18, 0x00	; 0
    1aa8:	30 e0       	ldi	r19, 0x00	; 0
    1aaa:	40 e2       	ldi	r20, 0x20	; 32
    1aac:	51 e4       	ldi	r21, 0x41	; 65
    1aae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ab2:	dc 01       	movw	r26, r24
    1ab4:	cb 01       	movw	r24, r22
    1ab6:	bc 01       	movw	r22, r24
    1ab8:	cd 01       	movw	r24, r26
    1aba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1abe:	dc 01       	movw	r26, r24
    1ac0:	cb 01       	movw	r24, r22
    1ac2:	9a a3       	std	Y+34, r25	; 0x22
    1ac4:	89 a3       	std	Y+33, r24	; 0x21
    1ac6:	0f c0       	rjmp	.+30     	; 0x1ae6 <LCD_voidWriteBitsToSend+0x220>
    1ac8:	80 e9       	ldi	r24, 0x90	; 144
    1aca:	91 e0       	ldi	r25, 0x01	; 1
    1acc:	98 a3       	std	Y+32, r25	; 0x20
    1ace:	8f 8f       	std	Y+31, r24	; 0x1f
    1ad0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1ad2:	98 a1       	ldd	r25, Y+32	; 0x20
    1ad4:	01 97       	sbiw	r24, 0x01	; 1
    1ad6:	f1 f7       	brne	.-4      	; 0x1ad4 <LCD_voidWriteBitsToSend+0x20e>
    1ad8:	98 a3       	std	Y+32, r25	; 0x20
    1ada:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1adc:	89 a1       	ldd	r24, Y+33	; 0x21
    1ade:	9a a1       	ldd	r25, Y+34	; 0x22
    1ae0:	01 97       	sbiw	r24, 0x01	; 1
    1ae2:	9a a3       	std	Y+34, r25	; 0x22
    1ae4:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ae6:	89 a1       	ldd	r24, Y+33	; 0x21
    1ae8:	9a a1       	ldd	r25, Y+34	; 0x22
    1aea:	00 97       	sbiw	r24, 0x00	; 0
    1aec:	69 f7       	brne	.-38     	; 0x1ac8 <LCD_voidWriteBitsToSend+0x202>
    1aee:	14 c0       	rjmp	.+40     	; 0x1b18 <LCD_voidWriteBitsToSend+0x252>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1af0:	6b a1       	ldd	r22, Y+35	; 0x23
    1af2:	7c a1       	ldd	r23, Y+36	; 0x24
    1af4:	8d a1       	ldd	r24, Y+37	; 0x25
    1af6:	9e a1       	ldd	r25, Y+38	; 0x26
    1af8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1afc:	dc 01       	movw	r26, r24
    1afe:	cb 01       	movw	r24, r22
    1b00:	9a a3       	std	Y+34, r25	; 0x22
    1b02:	89 a3       	std	Y+33, r24	; 0x21
    1b04:	89 a1       	ldd	r24, Y+33	; 0x21
    1b06:	9a a1       	ldd	r25, Y+34	; 0x22
    1b08:	9e 8f       	std	Y+30, r25	; 0x1e
    1b0a:	8d 8f       	std	Y+29, r24	; 0x1d
    1b0c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1b0e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1b10:	01 97       	sbiw	r24, 0x01	; 1
    1b12:	f1 f7       	brne	.-4      	; 0x1b10 <LCD_voidWriteBitsToSend+0x24a>
    1b14:	9e 8f       	std	Y+30, r25	; 0x1e
    1b16:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(30);

	DIO_SETPinValue(D7_PORT,D7_PIN, (copy_u8Byte>> 3) & 1);
    1b18:	89 ad       	ldd	r24, Y+57	; 0x39
    1b1a:	86 95       	lsr	r24
    1b1c:	86 95       	lsr	r24
    1b1e:	86 95       	lsr	r24
    1b20:	98 2f       	mov	r25, r24
    1b22:	91 70       	andi	r25, 0x01	; 1
    1b24:	81 e0       	ldi	r24, 0x01	; 1
    1b26:	64 e0       	ldi	r22, 0x04	; 4
    1b28:	49 2f       	mov	r20, r25
    1b2a:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
	DIO_SETPinValue(D6_PORT,D6_PIN, (copy_u8Byte>> 2) & 1);
    1b2e:	89 ad       	ldd	r24, Y+57	; 0x39
    1b30:	86 95       	lsr	r24
    1b32:	86 95       	lsr	r24
    1b34:	98 2f       	mov	r25, r24
    1b36:	91 70       	andi	r25, 0x01	; 1
    1b38:	81 e0       	ldi	r24, 0x01	; 1
    1b3a:	62 e0       	ldi	r22, 0x02	; 2
    1b3c:	49 2f       	mov	r20, r25
    1b3e:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
	DIO_SETPinValue(D5_PORT,D5_PIN, (copy_u8Byte>> 1) & 1);
    1b42:	89 ad       	ldd	r24, Y+57	; 0x39
    1b44:	86 95       	lsr	r24
    1b46:	98 2f       	mov	r25, r24
    1b48:	91 70       	andi	r25, 0x01	; 1
    1b4a:	81 e0       	ldi	r24, 0x01	; 1
    1b4c:	61 e0       	ldi	r22, 0x01	; 1
    1b4e:	49 2f       	mov	r20, r25
    1b50:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
	DIO_SETPinValue(D4_PORT,D4_PIN, (copy_u8Byte>> 0) & 1);
    1b54:	89 ad       	ldd	r24, Y+57	; 0x39
    1b56:	98 2f       	mov	r25, r24
    1b58:	91 70       	andi	r25, 0x01	; 1
    1b5a:	81 e0       	ldi	r24, 0x01	; 1
    1b5c:	60 e0       	ldi	r22, 0x00	; 0
    1b5e:	49 2f       	mov	r20, r25
    1b60:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>

	DIO_SETPinValue(EN_PORT,EN_PIN, HIGH);
    1b64:	80 e0       	ldi	r24, 0x00	; 0
    1b66:	62 e0       	ldi	r22, 0x02	; 2
    1b68:	41 e0       	ldi	r20, 0x01	; 1
    1b6a:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
    1b6e:	80 e0       	ldi	r24, 0x00	; 0
    1b70:	90 e0       	ldi	r25, 0x00	; 0
    1b72:	a0 e8       	ldi	r26, 0x80	; 128
    1b74:	bf e3       	ldi	r27, 0x3F	; 63
    1b76:	89 8f       	std	Y+25, r24	; 0x19
    1b78:	9a 8f       	std	Y+26, r25	; 0x1a
    1b7a:	ab 8f       	std	Y+27, r26	; 0x1b
    1b7c:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1b7e:	69 8d       	ldd	r22, Y+25	; 0x19
    1b80:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1b82:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1b84:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1b86:	20 e0       	ldi	r18, 0x00	; 0
    1b88:	30 e0       	ldi	r19, 0x00	; 0
    1b8a:	4a e7       	ldi	r20, 0x7A	; 122
    1b8c:	55 e4       	ldi	r21, 0x45	; 69
    1b8e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b92:	dc 01       	movw	r26, r24
    1b94:	cb 01       	movw	r24, r22
    1b96:	8d 8b       	std	Y+21, r24	; 0x15
    1b98:	9e 8b       	std	Y+22, r25	; 0x16
    1b9a:	af 8b       	std	Y+23, r26	; 0x17
    1b9c:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1b9e:	6d 89       	ldd	r22, Y+21	; 0x15
    1ba0:	7e 89       	ldd	r23, Y+22	; 0x16
    1ba2:	8f 89       	ldd	r24, Y+23	; 0x17
    1ba4:	98 8d       	ldd	r25, Y+24	; 0x18
    1ba6:	20 e0       	ldi	r18, 0x00	; 0
    1ba8:	30 e0       	ldi	r19, 0x00	; 0
    1baa:	40 e8       	ldi	r20, 0x80	; 128
    1bac:	5f e3       	ldi	r21, 0x3F	; 63
    1bae:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1bb2:	88 23       	and	r24, r24
    1bb4:	2c f4       	brge	.+10     	; 0x1bc0 <LCD_voidWriteBitsToSend+0x2fa>
		__ticks = 1;
    1bb6:	81 e0       	ldi	r24, 0x01	; 1
    1bb8:	90 e0       	ldi	r25, 0x00	; 0
    1bba:	9c 8b       	std	Y+20, r25	; 0x14
    1bbc:	8b 8b       	std	Y+19, r24	; 0x13
    1bbe:	3f c0       	rjmp	.+126    	; 0x1c3e <LCD_voidWriteBitsToSend+0x378>
	else if (__tmp > 65535)
    1bc0:	6d 89       	ldd	r22, Y+21	; 0x15
    1bc2:	7e 89       	ldd	r23, Y+22	; 0x16
    1bc4:	8f 89       	ldd	r24, Y+23	; 0x17
    1bc6:	98 8d       	ldd	r25, Y+24	; 0x18
    1bc8:	20 e0       	ldi	r18, 0x00	; 0
    1bca:	3f ef       	ldi	r19, 0xFF	; 255
    1bcc:	4f e7       	ldi	r20, 0x7F	; 127
    1bce:	57 e4       	ldi	r21, 0x47	; 71
    1bd0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1bd4:	18 16       	cp	r1, r24
    1bd6:	4c f5       	brge	.+82     	; 0x1c2a <LCD_voidWriteBitsToSend+0x364>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1bd8:	69 8d       	ldd	r22, Y+25	; 0x19
    1bda:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1bdc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1bde:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1be0:	20 e0       	ldi	r18, 0x00	; 0
    1be2:	30 e0       	ldi	r19, 0x00	; 0
    1be4:	40 e2       	ldi	r20, 0x20	; 32
    1be6:	51 e4       	ldi	r21, 0x41	; 65
    1be8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1bec:	dc 01       	movw	r26, r24
    1bee:	cb 01       	movw	r24, r22
    1bf0:	bc 01       	movw	r22, r24
    1bf2:	cd 01       	movw	r24, r26
    1bf4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bf8:	dc 01       	movw	r26, r24
    1bfa:	cb 01       	movw	r24, r22
    1bfc:	9c 8b       	std	Y+20, r25	; 0x14
    1bfe:	8b 8b       	std	Y+19, r24	; 0x13
    1c00:	0f c0       	rjmp	.+30     	; 0x1c20 <LCD_voidWriteBitsToSend+0x35a>
    1c02:	80 e9       	ldi	r24, 0x90	; 144
    1c04:	91 e0       	ldi	r25, 0x01	; 1
    1c06:	9a 8b       	std	Y+18, r25	; 0x12
    1c08:	89 8b       	std	Y+17, r24	; 0x11
    1c0a:	89 89       	ldd	r24, Y+17	; 0x11
    1c0c:	9a 89       	ldd	r25, Y+18	; 0x12
    1c0e:	01 97       	sbiw	r24, 0x01	; 1
    1c10:	f1 f7       	brne	.-4      	; 0x1c0e <LCD_voidWriteBitsToSend+0x348>
    1c12:	9a 8b       	std	Y+18, r25	; 0x12
    1c14:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c16:	8b 89       	ldd	r24, Y+19	; 0x13
    1c18:	9c 89       	ldd	r25, Y+20	; 0x14
    1c1a:	01 97       	sbiw	r24, 0x01	; 1
    1c1c:	9c 8b       	std	Y+20, r25	; 0x14
    1c1e:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c20:	8b 89       	ldd	r24, Y+19	; 0x13
    1c22:	9c 89       	ldd	r25, Y+20	; 0x14
    1c24:	00 97       	sbiw	r24, 0x00	; 0
    1c26:	69 f7       	brne	.-38     	; 0x1c02 <LCD_voidWriteBitsToSend+0x33c>
    1c28:	14 c0       	rjmp	.+40     	; 0x1c52 <LCD_voidWriteBitsToSend+0x38c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c2a:	6d 89       	ldd	r22, Y+21	; 0x15
    1c2c:	7e 89       	ldd	r23, Y+22	; 0x16
    1c2e:	8f 89       	ldd	r24, Y+23	; 0x17
    1c30:	98 8d       	ldd	r25, Y+24	; 0x18
    1c32:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c36:	dc 01       	movw	r26, r24
    1c38:	cb 01       	movw	r24, r22
    1c3a:	9c 8b       	std	Y+20, r25	; 0x14
    1c3c:	8b 8b       	std	Y+19, r24	; 0x13
    1c3e:	8b 89       	ldd	r24, Y+19	; 0x13
    1c40:	9c 89       	ldd	r25, Y+20	; 0x14
    1c42:	98 8b       	std	Y+16, r25	; 0x10
    1c44:	8f 87       	std	Y+15, r24	; 0x0f
    1c46:	8f 85       	ldd	r24, Y+15	; 0x0f
    1c48:	98 89       	ldd	r25, Y+16	; 0x10
    1c4a:	01 97       	sbiw	r24, 0x01	; 1
    1c4c:	f1 f7       	brne	.-4      	; 0x1c4a <LCD_voidWriteBitsToSend+0x384>
    1c4e:	98 8b       	std	Y+16, r25	; 0x10
    1c50:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);
	DIO_SETPinValue(EN_PORT,EN_PIN, LOW);
    1c52:	80 e0       	ldi	r24, 0x00	; 0
    1c54:	62 e0       	ldi	r22, 0x02	; 2
    1c56:	40 e0       	ldi	r20, 0x00	; 0
    1c58:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
    1c5c:	80 e0       	ldi	r24, 0x00	; 0
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	a0 ef       	ldi	r26, 0xF0	; 240
    1c62:	b1 e4       	ldi	r27, 0x41	; 65
    1c64:	8b 87       	std	Y+11, r24	; 0x0b
    1c66:	9c 87       	std	Y+12, r25	; 0x0c
    1c68:	ad 87       	std	Y+13, r26	; 0x0d
    1c6a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c6c:	6b 85       	ldd	r22, Y+11	; 0x0b
    1c6e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1c70:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c72:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c74:	20 e0       	ldi	r18, 0x00	; 0
    1c76:	30 e0       	ldi	r19, 0x00	; 0
    1c78:	4a e7       	ldi	r20, 0x7A	; 122
    1c7a:	55 e4       	ldi	r21, 0x45	; 69
    1c7c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c80:	dc 01       	movw	r26, r24
    1c82:	cb 01       	movw	r24, r22
    1c84:	8f 83       	std	Y+7, r24	; 0x07
    1c86:	98 87       	std	Y+8, r25	; 0x08
    1c88:	a9 87       	std	Y+9, r26	; 0x09
    1c8a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1c8c:	6f 81       	ldd	r22, Y+7	; 0x07
    1c8e:	78 85       	ldd	r23, Y+8	; 0x08
    1c90:	89 85       	ldd	r24, Y+9	; 0x09
    1c92:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c94:	20 e0       	ldi	r18, 0x00	; 0
    1c96:	30 e0       	ldi	r19, 0x00	; 0
    1c98:	40 e8       	ldi	r20, 0x80	; 128
    1c9a:	5f e3       	ldi	r21, 0x3F	; 63
    1c9c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1ca0:	88 23       	and	r24, r24
    1ca2:	2c f4       	brge	.+10     	; 0x1cae <LCD_voidWriteBitsToSend+0x3e8>
		__ticks = 1;
    1ca4:	81 e0       	ldi	r24, 0x01	; 1
    1ca6:	90 e0       	ldi	r25, 0x00	; 0
    1ca8:	9e 83       	std	Y+6, r25	; 0x06
    1caa:	8d 83       	std	Y+5, r24	; 0x05
    1cac:	3f c0       	rjmp	.+126    	; 0x1d2c <LCD_voidWriteBitsToSend+0x466>
	else if (__tmp > 65535)
    1cae:	6f 81       	ldd	r22, Y+7	; 0x07
    1cb0:	78 85       	ldd	r23, Y+8	; 0x08
    1cb2:	89 85       	ldd	r24, Y+9	; 0x09
    1cb4:	9a 85       	ldd	r25, Y+10	; 0x0a
    1cb6:	20 e0       	ldi	r18, 0x00	; 0
    1cb8:	3f ef       	ldi	r19, 0xFF	; 255
    1cba:	4f e7       	ldi	r20, 0x7F	; 127
    1cbc:	57 e4       	ldi	r21, 0x47	; 71
    1cbe:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1cc2:	18 16       	cp	r1, r24
    1cc4:	4c f5       	brge	.+82     	; 0x1d18 <LCD_voidWriteBitsToSend+0x452>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1cc6:	6b 85       	ldd	r22, Y+11	; 0x0b
    1cc8:	7c 85       	ldd	r23, Y+12	; 0x0c
    1cca:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ccc:	9e 85       	ldd	r25, Y+14	; 0x0e
    1cce:	20 e0       	ldi	r18, 0x00	; 0
    1cd0:	30 e0       	ldi	r19, 0x00	; 0
    1cd2:	40 e2       	ldi	r20, 0x20	; 32
    1cd4:	51 e4       	ldi	r21, 0x41	; 65
    1cd6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cda:	dc 01       	movw	r26, r24
    1cdc:	cb 01       	movw	r24, r22
    1cde:	bc 01       	movw	r22, r24
    1ce0:	cd 01       	movw	r24, r26
    1ce2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ce6:	dc 01       	movw	r26, r24
    1ce8:	cb 01       	movw	r24, r22
    1cea:	9e 83       	std	Y+6, r25	; 0x06
    1cec:	8d 83       	std	Y+5, r24	; 0x05
    1cee:	0f c0       	rjmp	.+30     	; 0x1d0e <LCD_voidWriteBitsToSend+0x448>
    1cf0:	80 e9       	ldi	r24, 0x90	; 144
    1cf2:	91 e0       	ldi	r25, 0x01	; 1
    1cf4:	9c 83       	std	Y+4, r25	; 0x04
    1cf6:	8b 83       	std	Y+3, r24	; 0x03
    1cf8:	8b 81       	ldd	r24, Y+3	; 0x03
    1cfa:	9c 81       	ldd	r25, Y+4	; 0x04
    1cfc:	01 97       	sbiw	r24, 0x01	; 1
    1cfe:	f1 f7       	brne	.-4      	; 0x1cfc <LCD_voidWriteBitsToSend+0x436>
    1d00:	9c 83       	std	Y+4, r25	; 0x04
    1d02:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d04:	8d 81       	ldd	r24, Y+5	; 0x05
    1d06:	9e 81       	ldd	r25, Y+6	; 0x06
    1d08:	01 97       	sbiw	r24, 0x01	; 1
    1d0a:	9e 83       	std	Y+6, r25	; 0x06
    1d0c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d0e:	8d 81       	ldd	r24, Y+5	; 0x05
    1d10:	9e 81       	ldd	r25, Y+6	; 0x06
    1d12:	00 97       	sbiw	r24, 0x00	; 0
    1d14:	69 f7       	brne	.-38     	; 0x1cf0 <LCD_voidWriteBitsToSend+0x42a>
    1d16:	14 c0       	rjmp	.+40     	; 0x1d40 <LCD_voidWriteBitsToSend+0x47a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d18:	6f 81       	ldd	r22, Y+7	; 0x07
    1d1a:	78 85       	ldd	r23, Y+8	; 0x08
    1d1c:	89 85       	ldd	r24, Y+9	; 0x09
    1d1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d20:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d24:	dc 01       	movw	r26, r24
    1d26:	cb 01       	movw	r24, r22
    1d28:	9e 83       	std	Y+6, r25	; 0x06
    1d2a:	8d 83       	std	Y+5, r24	; 0x05
    1d2c:	8d 81       	ldd	r24, Y+5	; 0x05
    1d2e:	9e 81       	ldd	r25, Y+6	; 0x06
    1d30:	9a 83       	std	Y+2, r25	; 0x02
    1d32:	89 83       	std	Y+1, r24	; 0x01
    1d34:	89 81       	ldd	r24, Y+1	; 0x01
    1d36:	9a 81       	ldd	r25, Y+2	; 0x02
    1d38:	01 97       	sbiw	r24, 0x01	; 1
    1d3a:	f1 f7       	brne	.-4      	; 0x1d38 <LCD_voidWriteBitsToSend+0x472>
    1d3c:	9a 83       	std	Y+2, r25	; 0x02
    1d3e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(30);



}
    1d40:	e9 96       	adiw	r28, 0x39	; 57
    1d42:	0f b6       	in	r0, 0x3f	; 63
    1d44:	f8 94       	cli
    1d46:	de bf       	out	0x3e, r29	; 62
    1d48:	0f be       	out	0x3f, r0	; 63
    1d4a:	cd bf       	out	0x3d, r28	; 61
    1d4c:	cf 91       	pop	r28
    1d4e:	df 91       	pop	r29
    1d50:	08 95       	ret

00001d52 <LCD_voidInit>:


void LCD_voidInit(void)
{
    1d52:	0f 93       	push	r16
    1d54:	1f 93       	push	r17
    1d56:	df 93       	push	r29
    1d58:	cf 93       	push	r28
    1d5a:	cd b7       	in	r28, 0x3d	; 61
    1d5c:	de b7       	in	r29, 0x3e	; 62
    1d5e:	c6 54       	subi	r28, 0x46	; 70
    1d60:	d0 40       	sbci	r29, 0x00	; 0
    1d62:	0f b6       	in	r0, 0x3f	; 63
    1d64:	f8 94       	cli
    1d66:	de bf       	out	0x3e, r29	; 62
    1d68:	0f be       	out	0x3f, r0	; 63
    1d6a:	cd bf       	out	0x3d, r28	; 61
    1d6c:	fe 01       	movw	r30, r28
    1d6e:	ed 5b       	subi	r30, 0xBD	; 189
    1d70:	ff 4f       	sbci	r31, 0xFF	; 255
    1d72:	80 e0       	ldi	r24, 0x00	; 0
    1d74:	90 e0       	ldi	r25, 0x00	; 0
    1d76:	a0 ef       	ldi	r26, 0xF0	; 240
    1d78:	b1 e4       	ldi	r27, 0x41	; 65
    1d7a:	80 83       	st	Z, r24
    1d7c:	91 83       	std	Z+1, r25	; 0x01
    1d7e:	a2 83       	std	Z+2, r26	; 0x02
    1d80:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d82:	8e 01       	movw	r16, r28
    1d84:	01 5c       	subi	r16, 0xC1	; 193
    1d86:	1f 4f       	sbci	r17, 0xFF	; 255
    1d88:	fe 01       	movw	r30, r28
    1d8a:	ed 5b       	subi	r30, 0xBD	; 189
    1d8c:	ff 4f       	sbci	r31, 0xFF	; 255
    1d8e:	60 81       	ld	r22, Z
    1d90:	71 81       	ldd	r23, Z+1	; 0x01
    1d92:	82 81       	ldd	r24, Z+2	; 0x02
    1d94:	93 81       	ldd	r25, Z+3	; 0x03
    1d96:	20 e0       	ldi	r18, 0x00	; 0
    1d98:	30 e0       	ldi	r19, 0x00	; 0
    1d9a:	4a e7       	ldi	r20, 0x7A	; 122
    1d9c:	55 e4       	ldi	r21, 0x45	; 69
    1d9e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1da2:	dc 01       	movw	r26, r24
    1da4:	cb 01       	movw	r24, r22
    1da6:	f8 01       	movw	r30, r16
    1da8:	80 83       	st	Z, r24
    1daa:	91 83       	std	Z+1, r25	; 0x01
    1dac:	a2 83       	std	Z+2, r26	; 0x02
    1dae:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1db0:	fe 01       	movw	r30, r28
    1db2:	ff 96       	adiw	r30, 0x3f	; 63
    1db4:	60 81       	ld	r22, Z
    1db6:	71 81       	ldd	r23, Z+1	; 0x01
    1db8:	82 81       	ldd	r24, Z+2	; 0x02
    1dba:	93 81       	ldd	r25, Z+3	; 0x03
    1dbc:	20 e0       	ldi	r18, 0x00	; 0
    1dbe:	30 e0       	ldi	r19, 0x00	; 0
    1dc0:	40 e8       	ldi	r20, 0x80	; 128
    1dc2:	5f e3       	ldi	r21, 0x3F	; 63
    1dc4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1dc8:	88 23       	and	r24, r24
    1dca:	2c f4       	brge	.+10     	; 0x1dd6 <LCD_voidInit+0x84>
		__ticks = 1;
    1dcc:	81 e0       	ldi	r24, 0x01	; 1
    1dce:	90 e0       	ldi	r25, 0x00	; 0
    1dd0:	9e af       	std	Y+62, r25	; 0x3e
    1dd2:	8d af       	std	Y+61, r24	; 0x3d
    1dd4:	46 c0       	rjmp	.+140    	; 0x1e62 <LCD_voidInit+0x110>
	else if (__tmp > 65535)
    1dd6:	fe 01       	movw	r30, r28
    1dd8:	ff 96       	adiw	r30, 0x3f	; 63
    1dda:	60 81       	ld	r22, Z
    1ddc:	71 81       	ldd	r23, Z+1	; 0x01
    1dde:	82 81       	ldd	r24, Z+2	; 0x02
    1de0:	93 81       	ldd	r25, Z+3	; 0x03
    1de2:	20 e0       	ldi	r18, 0x00	; 0
    1de4:	3f ef       	ldi	r19, 0xFF	; 255
    1de6:	4f e7       	ldi	r20, 0x7F	; 127
    1de8:	57 e4       	ldi	r21, 0x47	; 71
    1dea:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1dee:	18 16       	cp	r1, r24
    1df0:	64 f5       	brge	.+88     	; 0x1e4a <LCD_voidInit+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1df2:	fe 01       	movw	r30, r28
    1df4:	ed 5b       	subi	r30, 0xBD	; 189
    1df6:	ff 4f       	sbci	r31, 0xFF	; 255
    1df8:	60 81       	ld	r22, Z
    1dfa:	71 81       	ldd	r23, Z+1	; 0x01
    1dfc:	82 81       	ldd	r24, Z+2	; 0x02
    1dfe:	93 81       	ldd	r25, Z+3	; 0x03
    1e00:	20 e0       	ldi	r18, 0x00	; 0
    1e02:	30 e0       	ldi	r19, 0x00	; 0
    1e04:	40 e2       	ldi	r20, 0x20	; 32
    1e06:	51 e4       	ldi	r21, 0x41	; 65
    1e08:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e0c:	dc 01       	movw	r26, r24
    1e0e:	cb 01       	movw	r24, r22
    1e10:	bc 01       	movw	r22, r24
    1e12:	cd 01       	movw	r24, r26
    1e14:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e18:	dc 01       	movw	r26, r24
    1e1a:	cb 01       	movw	r24, r22
    1e1c:	9e af       	std	Y+62, r25	; 0x3e
    1e1e:	8d af       	std	Y+61, r24	; 0x3d
    1e20:	0f c0       	rjmp	.+30     	; 0x1e40 <LCD_voidInit+0xee>
    1e22:	80 e9       	ldi	r24, 0x90	; 144
    1e24:	91 e0       	ldi	r25, 0x01	; 1
    1e26:	9c af       	std	Y+60, r25	; 0x3c
    1e28:	8b af       	std	Y+59, r24	; 0x3b
    1e2a:	8b ad       	ldd	r24, Y+59	; 0x3b
    1e2c:	9c ad       	ldd	r25, Y+60	; 0x3c
    1e2e:	01 97       	sbiw	r24, 0x01	; 1
    1e30:	f1 f7       	brne	.-4      	; 0x1e2e <LCD_voidInit+0xdc>
    1e32:	9c af       	std	Y+60, r25	; 0x3c
    1e34:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e36:	8d ad       	ldd	r24, Y+61	; 0x3d
    1e38:	9e ad       	ldd	r25, Y+62	; 0x3e
    1e3a:	01 97       	sbiw	r24, 0x01	; 1
    1e3c:	9e af       	std	Y+62, r25	; 0x3e
    1e3e:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e40:	8d ad       	ldd	r24, Y+61	; 0x3d
    1e42:	9e ad       	ldd	r25, Y+62	; 0x3e
    1e44:	00 97       	sbiw	r24, 0x00	; 0
    1e46:	69 f7       	brne	.-38     	; 0x1e22 <LCD_voidInit+0xd0>
    1e48:	16 c0       	rjmp	.+44     	; 0x1e76 <LCD_voidInit+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e4a:	fe 01       	movw	r30, r28
    1e4c:	ff 96       	adiw	r30, 0x3f	; 63
    1e4e:	60 81       	ld	r22, Z
    1e50:	71 81       	ldd	r23, Z+1	; 0x01
    1e52:	82 81       	ldd	r24, Z+2	; 0x02
    1e54:	93 81       	ldd	r25, Z+3	; 0x03
    1e56:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e5a:	dc 01       	movw	r26, r24
    1e5c:	cb 01       	movw	r24, r22
    1e5e:	9e af       	std	Y+62, r25	; 0x3e
    1e60:	8d af       	std	Y+61, r24	; 0x3d
    1e62:	8d ad       	ldd	r24, Y+61	; 0x3d
    1e64:	9e ad       	ldd	r25, Y+62	; 0x3e
    1e66:	9a af       	std	Y+58, r25	; 0x3a
    1e68:	89 af       	std	Y+57, r24	; 0x39
    1e6a:	89 ad       	ldd	r24, Y+57	; 0x39
    1e6c:	9a ad       	ldd	r25, Y+58	; 0x3a
    1e6e:	01 97       	sbiw	r24, 0x01	; 1
    1e70:	f1 f7       	brne	.-4      	; 0x1e6e <LCD_voidInit+0x11c>
    1e72:	9a af       	std	Y+58, r25	; 0x3a
    1e74:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms(30);

	DIO_SETPinDirection(RS_PORT,RS_PIN,OUTPUT);
    1e76:	80 e0       	ldi	r24, 0x00	; 0
    1e78:	63 e0       	ldi	r22, 0x03	; 3
    1e7a:	41 e0       	ldi	r20, 0x01	; 1
    1e7c:	0e 94 2a 08 	call	0x1054	; 0x1054 <DIO_SETPinDirection>
	//DIO_SETPinDirection(RW_PORT,RW_PIN,OUTPUT);
	DIO_SETPinDirection(EN_PORT, EN_PIN,OUTPUT);
    1e80:	80 e0       	ldi	r24, 0x00	; 0
    1e82:	62 e0       	ldi	r22, 0x02	; 2
    1e84:	41 e0       	ldi	r20, 0x01	; 1
    1e86:	0e 94 2a 08 	call	0x1054	; 0x1054 <DIO_SETPinDirection>


	DIO_SETPinDirection(D4_PORT,D4_PIN,OUTPUT);
    1e8a:	81 e0       	ldi	r24, 0x01	; 1
    1e8c:	60 e0       	ldi	r22, 0x00	; 0
    1e8e:	41 e0       	ldi	r20, 0x01	; 1
    1e90:	0e 94 2a 08 	call	0x1054	; 0x1054 <DIO_SETPinDirection>
	DIO_SETPinDirection(D5_PORT,D5_PIN,OUTPUT);
    1e94:	81 e0       	ldi	r24, 0x01	; 1
    1e96:	61 e0       	ldi	r22, 0x01	; 1
    1e98:	41 e0       	ldi	r20, 0x01	; 1
    1e9a:	0e 94 2a 08 	call	0x1054	; 0x1054 <DIO_SETPinDirection>
	DIO_SETPinDirection(D6_PORT,D6_PIN,OUTPUT);
    1e9e:	81 e0       	ldi	r24, 0x01	; 1
    1ea0:	62 e0       	ldi	r22, 0x02	; 2
    1ea2:	41 e0       	ldi	r20, 0x01	; 1
    1ea4:	0e 94 2a 08 	call	0x1054	; 0x1054 <DIO_SETPinDirection>
	DIO_SETPinDirection(D7_PORT,D7_PIN,OUTPUT);
    1ea8:	81 e0       	ldi	r24, 0x01	; 1
    1eaa:	64 e0       	ldi	r22, 0x04	; 4
    1eac:	41 e0       	ldi	r20, 0x01	; 1
    1eae:	0e 94 2a 08 	call	0x1054	; 0x1054 <DIO_SETPinDirection>




	LCD_voidWriteCommand(0x02);
    1eb2:	82 e0       	ldi	r24, 0x02	; 2
    1eb4:	0e 94 4e 11 	call	0x229c	; 0x229c <LCD_voidWriteCommand>
    1eb8:	80 e0       	ldi	r24, 0x00	; 0
    1eba:	90 e0       	ldi	r25, 0x00	; 0
    1ebc:	a0 e0       	ldi	r26, 0x00	; 0
    1ebe:	b0 e4       	ldi	r27, 0x40	; 64
    1ec0:	8d ab       	std	Y+53, r24	; 0x35
    1ec2:	9e ab       	std	Y+54, r25	; 0x36
    1ec4:	af ab       	std	Y+55, r26	; 0x37
    1ec6:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1ec8:	6d a9       	ldd	r22, Y+53	; 0x35
    1eca:	7e a9       	ldd	r23, Y+54	; 0x36
    1ecc:	8f a9       	ldd	r24, Y+55	; 0x37
    1ece:	98 ad       	ldd	r25, Y+56	; 0x38
    1ed0:	20 e0       	ldi	r18, 0x00	; 0
    1ed2:	30 e0       	ldi	r19, 0x00	; 0
    1ed4:	4a e7       	ldi	r20, 0x7A	; 122
    1ed6:	55 e4       	ldi	r21, 0x45	; 69
    1ed8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1edc:	dc 01       	movw	r26, r24
    1ede:	cb 01       	movw	r24, r22
    1ee0:	89 ab       	std	Y+49, r24	; 0x31
    1ee2:	9a ab       	std	Y+50, r25	; 0x32
    1ee4:	ab ab       	std	Y+51, r26	; 0x33
    1ee6:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1ee8:	69 a9       	ldd	r22, Y+49	; 0x31
    1eea:	7a a9       	ldd	r23, Y+50	; 0x32
    1eec:	8b a9       	ldd	r24, Y+51	; 0x33
    1eee:	9c a9       	ldd	r25, Y+52	; 0x34
    1ef0:	20 e0       	ldi	r18, 0x00	; 0
    1ef2:	30 e0       	ldi	r19, 0x00	; 0
    1ef4:	40 e8       	ldi	r20, 0x80	; 128
    1ef6:	5f e3       	ldi	r21, 0x3F	; 63
    1ef8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1efc:	88 23       	and	r24, r24
    1efe:	2c f4       	brge	.+10     	; 0x1f0a <LCD_voidInit+0x1b8>
		__ticks = 1;
    1f00:	81 e0       	ldi	r24, 0x01	; 1
    1f02:	90 e0       	ldi	r25, 0x00	; 0
    1f04:	98 ab       	std	Y+48, r25	; 0x30
    1f06:	8f a7       	std	Y+47, r24	; 0x2f
    1f08:	3f c0       	rjmp	.+126    	; 0x1f88 <LCD_voidInit+0x236>
	else if (__tmp > 65535)
    1f0a:	69 a9       	ldd	r22, Y+49	; 0x31
    1f0c:	7a a9       	ldd	r23, Y+50	; 0x32
    1f0e:	8b a9       	ldd	r24, Y+51	; 0x33
    1f10:	9c a9       	ldd	r25, Y+52	; 0x34
    1f12:	20 e0       	ldi	r18, 0x00	; 0
    1f14:	3f ef       	ldi	r19, 0xFF	; 255
    1f16:	4f e7       	ldi	r20, 0x7F	; 127
    1f18:	57 e4       	ldi	r21, 0x47	; 71
    1f1a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1f1e:	18 16       	cp	r1, r24
    1f20:	4c f5       	brge	.+82     	; 0x1f74 <LCD_voidInit+0x222>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f22:	6d a9       	ldd	r22, Y+53	; 0x35
    1f24:	7e a9       	ldd	r23, Y+54	; 0x36
    1f26:	8f a9       	ldd	r24, Y+55	; 0x37
    1f28:	98 ad       	ldd	r25, Y+56	; 0x38
    1f2a:	20 e0       	ldi	r18, 0x00	; 0
    1f2c:	30 e0       	ldi	r19, 0x00	; 0
    1f2e:	40 e2       	ldi	r20, 0x20	; 32
    1f30:	51 e4       	ldi	r21, 0x41	; 65
    1f32:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f36:	dc 01       	movw	r26, r24
    1f38:	cb 01       	movw	r24, r22
    1f3a:	bc 01       	movw	r22, r24
    1f3c:	cd 01       	movw	r24, r26
    1f3e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f42:	dc 01       	movw	r26, r24
    1f44:	cb 01       	movw	r24, r22
    1f46:	98 ab       	std	Y+48, r25	; 0x30
    1f48:	8f a7       	std	Y+47, r24	; 0x2f
    1f4a:	0f c0       	rjmp	.+30     	; 0x1f6a <LCD_voidInit+0x218>
    1f4c:	80 e9       	ldi	r24, 0x90	; 144
    1f4e:	91 e0       	ldi	r25, 0x01	; 1
    1f50:	9e a7       	std	Y+46, r25	; 0x2e
    1f52:	8d a7       	std	Y+45, r24	; 0x2d
    1f54:	8d a5       	ldd	r24, Y+45	; 0x2d
    1f56:	9e a5       	ldd	r25, Y+46	; 0x2e
    1f58:	01 97       	sbiw	r24, 0x01	; 1
    1f5a:	f1 f7       	brne	.-4      	; 0x1f58 <LCD_voidInit+0x206>
    1f5c:	9e a7       	std	Y+46, r25	; 0x2e
    1f5e:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f60:	8f a5       	ldd	r24, Y+47	; 0x2f
    1f62:	98 a9       	ldd	r25, Y+48	; 0x30
    1f64:	01 97       	sbiw	r24, 0x01	; 1
    1f66:	98 ab       	std	Y+48, r25	; 0x30
    1f68:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f6a:	8f a5       	ldd	r24, Y+47	; 0x2f
    1f6c:	98 a9       	ldd	r25, Y+48	; 0x30
    1f6e:	00 97       	sbiw	r24, 0x00	; 0
    1f70:	69 f7       	brne	.-38     	; 0x1f4c <LCD_voidInit+0x1fa>
    1f72:	14 c0       	rjmp	.+40     	; 0x1f9c <LCD_voidInit+0x24a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1f74:	69 a9       	ldd	r22, Y+49	; 0x31
    1f76:	7a a9       	ldd	r23, Y+50	; 0x32
    1f78:	8b a9       	ldd	r24, Y+51	; 0x33
    1f7a:	9c a9       	ldd	r25, Y+52	; 0x34
    1f7c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f80:	dc 01       	movw	r26, r24
    1f82:	cb 01       	movw	r24, r22
    1f84:	98 ab       	std	Y+48, r25	; 0x30
    1f86:	8f a7       	std	Y+47, r24	; 0x2f
    1f88:	8f a5       	ldd	r24, Y+47	; 0x2f
    1f8a:	98 a9       	ldd	r25, Y+48	; 0x30
    1f8c:	9c a7       	std	Y+44, r25	; 0x2c
    1f8e:	8b a7       	std	Y+43, r24	; 0x2b
    1f90:	8b a5       	ldd	r24, Y+43	; 0x2b
    1f92:	9c a5       	ldd	r25, Y+44	; 0x2c
    1f94:	01 97       	sbiw	r24, 0x01	; 1
    1f96:	f1 f7       	brne	.-4      	; 0x1f94 <LCD_voidInit+0x242>
    1f98:	9c a7       	std	Y+44, r25	; 0x2c
    1f9a:	8b a7       	std	Y+43, r24	; 0x2b
    _delay_ms(2);

	LCD_voidWriteCommand(0x2C);
    1f9c:	8c e2       	ldi	r24, 0x2C	; 44
    1f9e:	0e 94 4e 11 	call	0x229c	; 0x229c <LCD_voidWriteCommand>
    1fa2:	80 e0       	ldi	r24, 0x00	; 0
    1fa4:	90 e0       	ldi	r25, 0x00	; 0
    1fa6:	a0 e0       	ldi	r26, 0x00	; 0
    1fa8:	b0 e4       	ldi	r27, 0x40	; 64
    1faa:	8f a3       	std	Y+39, r24	; 0x27
    1fac:	98 a7       	std	Y+40, r25	; 0x28
    1fae:	a9 a7       	std	Y+41, r26	; 0x29
    1fb0:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1fb2:	6f a1       	ldd	r22, Y+39	; 0x27
    1fb4:	78 a5       	ldd	r23, Y+40	; 0x28
    1fb6:	89 a5       	ldd	r24, Y+41	; 0x29
    1fb8:	9a a5       	ldd	r25, Y+42	; 0x2a
    1fba:	20 e0       	ldi	r18, 0x00	; 0
    1fbc:	30 e0       	ldi	r19, 0x00	; 0
    1fbe:	4a e7       	ldi	r20, 0x7A	; 122
    1fc0:	55 e4       	ldi	r21, 0x45	; 69
    1fc2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1fc6:	dc 01       	movw	r26, r24
    1fc8:	cb 01       	movw	r24, r22
    1fca:	8b a3       	std	Y+35, r24	; 0x23
    1fcc:	9c a3       	std	Y+36, r25	; 0x24
    1fce:	ad a3       	std	Y+37, r26	; 0x25
    1fd0:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    1fd2:	6b a1       	ldd	r22, Y+35	; 0x23
    1fd4:	7c a1       	ldd	r23, Y+36	; 0x24
    1fd6:	8d a1       	ldd	r24, Y+37	; 0x25
    1fd8:	9e a1       	ldd	r25, Y+38	; 0x26
    1fda:	20 e0       	ldi	r18, 0x00	; 0
    1fdc:	30 e0       	ldi	r19, 0x00	; 0
    1fde:	40 e8       	ldi	r20, 0x80	; 128
    1fe0:	5f e3       	ldi	r21, 0x3F	; 63
    1fe2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1fe6:	88 23       	and	r24, r24
    1fe8:	2c f4       	brge	.+10     	; 0x1ff4 <LCD_voidInit+0x2a2>
		__ticks = 1;
    1fea:	81 e0       	ldi	r24, 0x01	; 1
    1fec:	90 e0       	ldi	r25, 0x00	; 0
    1fee:	9a a3       	std	Y+34, r25	; 0x22
    1ff0:	89 a3       	std	Y+33, r24	; 0x21
    1ff2:	3f c0       	rjmp	.+126    	; 0x2072 <LCD_voidInit+0x320>
	else if (__tmp > 65535)
    1ff4:	6b a1       	ldd	r22, Y+35	; 0x23
    1ff6:	7c a1       	ldd	r23, Y+36	; 0x24
    1ff8:	8d a1       	ldd	r24, Y+37	; 0x25
    1ffa:	9e a1       	ldd	r25, Y+38	; 0x26
    1ffc:	20 e0       	ldi	r18, 0x00	; 0
    1ffe:	3f ef       	ldi	r19, 0xFF	; 255
    2000:	4f e7       	ldi	r20, 0x7F	; 127
    2002:	57 e4       	ldi	r21, 0x47	; 71
    2004:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2008:	18 16       	cp	r1, r24
    200a:	4c f5       	brge	.+82     	; 0x205e <LCD_voidInit+0x30c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    200c:	6f a1       	ldd	r22, Y+39	; 0x27
    200e:	78 a5       	ldd	r23, Y+40	; 0x28
    2010:	89 a5       	ldd	r24, Y+41	; 0x29
    2012:	9a a5       	ldd	r25, Y+42	; 0x2a
    2014:	20 e0       	ldi	r18, 0x00	; 0
    2016:	30 e0       	ldi	r19, 0x00	; 0
    2018:	40 e2       	ldi	r20, 0x20	; 32
    201a:	51 e4       	ldi	r21, 0x41	; 65
    201c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2020:	dc 01       	movw	r26, r24
    2022:	cb 01       	movw	r24, r22
    2024:	bc 01       	movw	r22, r24
    2026:	cd 01       	movw	r24, r26
    2028:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    202c:	dc 01       	movw	r26, r24
    202e:	cb 01       	movw	r24, r22
    2030:	9a a3       	std	Y+34, r25	; 0x22
    2032:	89 a3       	std	Y+33, r24	; 0x21
    2034:	0f c0       	rjmp	.+30     	; 0x2054 <LCD_voidInit+0x302>
    2036:	80 e9       	ldi	r24, 0x90	; 144
    2038:	91 e0       	ldi	r25, 0x01	; 1
    203a:	98 a3       	std	Y+32, r25	; 0x20
    203c:	8f 8f       	std	Y+31, r24	; 0x1f
    203e:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2040:	98 a1       	ldd	r25, Y+32	; 0x20
    2042:	01 97       	sbiw	r24, 0x01	; 1
    2044:	f1 f7       	brne	.-4      	; 0x2042 <LCD_voidInit+0x2f0>
    2046:	98 a3       	std	Y+32, r25	; 0x20
    2048:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    204a:	89 a1       	ldd	r24, Y+33	; 0x21
    204c:	9a a1       	ldd	r25, Y+34	; 0x22
    204e:	01 97       	sbiw	r24, 0x01	; 1
    2050:	9a a3       	std	Y+34, r25	; 0x22
    2052:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2054:	89 a1       	ldd	r24, Y+33	; 0x21
    2056:	9a a1       	ldd	r25, Y+34	; 0x22
    2058:	00 97       	sbiw	r24, 0x00	; 0
    205a:	69 f7       	brne	.-38     	; 0x2036 <LCD_voidInit+0x2e4>
    205c:	14 c0       	rjmp	.+40     	; 0x2086 <LCD_voidInit+0x334>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    205e:	6b a1       	ldd	r22, Y+35	; 0x23
    2060:	7c a1       	ldd	r23, Y+36	; 0x24
    2062:	8d a1       	ldd	r24, Y+37	; 0x25
    2064:	9e a1       	ldd	r25, Y+38	; 0x26
    2066:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    206a:	dc 01       	movw	r26, r24
    206c:	cb 01       	movw	r24, r22
    206e:	9a a3       	std	Y+34, r25	; 0x22
    2070:	89 a3       	std	Y+33, r24	; 0x21
    2072:	89 a1       	ldd	r24, Y+33	; 0x21
    2074:	9a a1       	ldd	r25, Y+34	; 0x22
    2076:	9e 8f       	std	Y+30, r25	; 0x1e
    2078:	8d 8f       	std	Y+29, r24	; 0x1d
    207a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    207c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    207e:	01 97       	sbiw	r24, 0x01	; 1
    2080:	f1 f7       	brne	.-4      	; 0x207e <LCD_voidInit+0x32c>
    2082:	9e 8f       	std	Y+30, r25	; 0x1e
    2084:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(2);

	LCD_voidWriteCommand(0x0C);
    2086:	8c e0       	ldi	r24, 0x0C	; 12
    2088:	0e 94 4e 11 	call	0x229c	; 0x229c <LCD_voidWriteCommand>
    208c:	80 e0       	ldi	r24, 0x00	; 0
    208e:	90 e0       	ldi	r25, 0x00	; 0
    2090:	a0 e0       	ldi	r26, 0x00	; 0
    2092:	b0 e4       	ldi	r27, 0x40	; 64
    2094:	89 8f       	std	Y+25, r24	; 0x19
    2096:	9a 8f       	std	Y+26, r25	; 0x1a
    2098:	ab 8f       	std	Y+27, r26	; 0x1b
    209a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    209c:	69 8d       	ldd	r22, Y+25	; 0x19
    209e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    20a0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    20a2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    20a4:	20 e0       	ldi	r18, 0x00	; 0
    20a6:	30 e0       	ldi	r19, 0x00	; 0
    20a8:	4a e7       	ldi	r20, 0x7A	; 122
    20aa:	55 e4       	ldi	r21, 0x45	; 69
    20ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20b0:	dc 01       	movw	r26, r24
    20b2:	cb 01       	movw	r24, r22
    20b4:	8d 8b       	std	Y+21, r24	; 0x15
    20b6:	9e 8b       	std	Y+22, r25	; 0x16
    20b8:	af 8b       	std	Y+23, r26	; 0x17
    20ba:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    20bc:	6d 89       	ldd	r22, Y+21	; 0x15
    20be:	7e 89       	ldd	r23, Y+22	; 0x16
    20c0:	8f 89       	ldd	r24, Y+23	; 0x17
    20c2:	98 8d       	ldd	r25, Y+24	; 0x18
    20c4:	20 e0       	ldi	r18, 0x00	; 0
    20c6:	30 e0       	ldi	r19, 0x00	; 0
    20c8:	40 e8       	ldi	r20, 0x80	; 128
    20ca:	5f e3       	ldi	r21, 0x3F	; 63
    20cc:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    20d0:	88 23       	and	r24, r24
    20d2:	2c f4       	brge	.+10     	; 0x20de <LCD_voidInit+0x38c>
		__ticks = 1;
    20d4:	81 e0       	ldi	r24, 0x01	; 1
    20d6:	90 e0       	ldi	r25, 0x00	; 0
    20d8:	9c 8b       	std	Y+20, r25	; 0x14
    20da:	8b 8b       	std	Y+19, r24	; 0x13
    20dc:	3f c0       	rjmp	.+126    	; 0x215c <LCD_voidInit+0x40a>
	else if (__tmp > 65535)
    20de:	6d 89       	ldd	r22, Y+21	; 0x15
    20e0:	7e 89       	ldd	r23, Y+22	; 0x16
    20e2:	8f 89       	ldd	r24, Y+23	; 0x17
    20e4:	98 8d       	ldd	r25, Y+24	; 0x18
    20e6:	20 e0       	ldi	r18, 0x00	; 0
    20e8:	3f ef       	ldi	r19, 0xFF	; 255
    20ea:	4f e7       	ldi	r20, 0x7F	; 127
    20ec:	57 e4       	ldi	r21, 0x47	; 71
    20ee:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    20f2:	18 16       	cp	r1, r24
    20f4:	4c f5       	brge	.+82     	; 0x2148 <LCD_voidInit+0x3f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    20f6:	69 8d       	ldd	r22, Y+25	; 0x19
    20f8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    20fa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    20fc:	9c 8d       	ldd	r25, Y+28	; 0x1c
    20fe:	20 e0       	ldi	r18, 0x00	; 0
    2100:	30 e0       	ldi	r19, 0x00	; 0
    2102:	40 e2       	ldi	r20, 0x20	; 32
    2104:	51 e4       	ldi	r21, 0x41	; 65
    2106:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    210a:	dc 01       	movw	r26, r24
    210c:	cb 01       	movw	r24, r22
    210e:	bc 01       	movw	r22, r24
    2110:	cd 01       	movw	r24, r26
    2112:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2116:	dc 01       	movw	r26, r24
    2118:	cb 01       	movw	r24, r22
    211a:	9c 8b       	std	Y+20, r25	; 0x14
    211c:	8b 8b       	std	Y+19, r24	; 0x13
    211e:	0f c0       	rjmp	.+30     	; 0x213e <LCD_voidInit+0x3ec>
    2120:	80 e9       	ldi	r24, 0x90	; 144
    2122:	91 e0       	ldi	r25, 0x01	; 1
    2124:	9a 8b       	std	Y+18, r25	; 0x12
    2126:	89 8b       	std	Y+17, r24	; 0x11
    2128:	89 89       	ldd	r24, Y+17	; 0x11
    212a:	9a 89       	ldd	r25, Y+18	; 0x12
    212c:	01 97       	sbiw	r24, 0x01	; 1
    212e:	f1 f7       	brne	.-4      	; 0x212c <LCD_voidInit+0x3da>
    2130:	9a 8b       	std	Y+18, r25	; 0x12
    2132:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2134:	8b 89       	ldd	r24, Y+19	; 0x13
    2136:	9c 89       	ldd	r25, Y+20	; 0x14
    2138:	01 97       	sbiw	r24, 0x01	; 1
    213a:	9c 8b       	std	Y+20, r25	; 0x14
    213c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    213e:	8b 89       	ldd	r24, Y+19	; 0x13
    2140:	9c 89       	ldd	r25, Y+20	; 0x14
    2142:	00 97       	sbiw	r24, 0x00	; 0
    2144:	69 f7       	brne	.-38     	; 0x2120 <LCD_voidInit+0x3ce>
    2146:	14 c0       	rjmp	.+40     	; 0x2170 <LCD_voidInit+0x41e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2148:	6d 89       	ldd	r22, Y+21	; 0x15
    214a:	7e 89       	ldd	r23, Y+22	; 0x16
    214c:	8f 89       	ldd	r24, Y+23	; 0x17
    214e:	98 8d       	ldd	r25, Y+24	; 0x18
    2150:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2154:	dc 01       	movw	r26, r24
    2156:	cb 01       	movw	r24, r22
    2158:	9c 8b       	std	Y+20, r25	; 0x14
    215a:	8b 8b       	std	Y+19, r24	; 0x13
    215c:	8b 89       	ldd	r24, Y+19	; 0x13
    215e:	9c 89       	ldd	r25, Y+20	; 0x14
    2160:	98 8b       	std	Y+16, r25	; 0x10
    2162:	8f 87       	std	Y+15, r24	; 0x0f
    2164:	8f 85       	ldd	r24, Y+15	; 0x0f
    2166:	98 89       	ldd	r25, Y+16	; 0x10
    2168:	01 97       	sbiw	r24, 0x01	; 1
    216a:	f1 f7       	brne	.-4      	; 0x2168 <LCD_voidInit+0x416>
    216c:	98 8b       	std	Y+16, r25	; 0x10
    216e:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);

	LCD_voidWriteCommand(0x01);
    2170:	81 e0       	ldi	r24, 0x01	; 1
    2172:	0e 94 4e 11 	call	0x229c	; 0x229c <LCD_voidWriteCommand>
    2176:	80 e0       	ldi	r24, 0x00	; 0
    2178:	90 e0       	ldi	r25, 0x00	; 0
    217a:	a0 e0       	ldi	r26, 0x00	; 0
    217c:	b0 e4       	ldi	r27, 0x40	; 64
    217e:	8b 87       	std	Y+11, r24	; 0x0b
    2180:	9c 87       	std	Y+12, r25	; 0x0c
    2182:	ad 87       	std	Y+13, r26	; 0x0d
    2184:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2186:	6b 85       	ldd	r22, Y+11	; 0x0b
    2188:	7c 85       	ldd	r23, Y+12	; 0x0c
    218a:	8d 85       	ldd	r24, Y+13	; 0x0d
    218c:	9e 85       	ldd	r25, Y+14	; 0x0e
    218e:	20 e0       	ldi	r18, 0x00	; 0
    2190:	30 e0       	ldi	r19, 0x00	; 0
    2192:	4a e7       	ldi	r20, 0x7A	; 122
    2194:	55 e4       	ldi	r21, 0x45	; 69
    2196:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    219a:	dc 01       	movw	r26, r24
    219c:	cb 01       	movw	r24, r22
    219e:	8f 83       	std	Y+7, r24	; 0x07
    21a0:	98 87       	std	Y+8, r25	; 0x08
    21a2:	a9 87       	std	Y+9, r26	; 0x09
    21a4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    21a6:	6f 81       	ldd	r22, Y+7	; 0x07
    21a8:	78 85       	ldd	r23, Y+8	; 0x08
    21aa:	89 85       	ldd	r24, Y+9	; 0x09
    21ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    21ae:	20 e0       	ldi	r18, 0x00	; 0
    21b0:	30 e0       	ldi	r19, 0x00	; 0
    21b2:	40 e8       	ldi	r20, 0x80	; 128
    21b4:	5f e3       	ldi	r21, 0x3F	; 63
    21b6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    21ba:	88 23       	and	r24, r24
    21bc:	2c f4       	brge	.+10     	; 0x21c8 <LCD_voidInit+0x476>
		__ticks = 1;
    21be:	81 e0       	ldi	r24, 0x01	; 1
    21c0:	90 e0       	ldi	r25, 0x00	; 0
    21c2:	9e 83       	std	Y+6, r25	; 0x06
    21c4:	8d 83       	std	Y+5, r24	; 0x05
    21c6:	3f c0       	rjmp	.+126    	; 0x2246 <LCD_voidInit+0x4f4>
	else if (__tmp > 65535)
    21c8:	6f 81       	ldd	r22, Y+7	; 0x07
    21ca:	78 85       	ldd	r23, Y+8	; 0x08
    21cc:	89 85       	ldd	r24, Y+9	; 0x09
    21ce:	9a 85       	ldd	r25, Y+10	; 0x0a
    21d0:	20 e0       	ldi	r18, 0x00	; 0
    21d2:	3f ef       	ldi	r19, 0xFF	; 255
    21d4:	4f e7       	ldi	r20, 0x7F	; 127
    21d6:	57 e4       	ldi	r21, 0x47	; 71
    21d8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    21dc:	18 16       	cp	r1, r24
    21de:	4c f5       	brge	.+82     	; 0x2232 <LCD_voidInit+0x4e0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    21e0:	6b 85       	ldd	r22, Y+11	; 0x0b
    21e2:	7c 85       	ldd	r23, Y+12	; 0x0c
    21e4:	8d 85       	ldd	r24, Y+13	; 0x0d
    21e6:	9e 85       	ldd	r25, Y+14	; 0x0e
    21e8:	20 e0       	ldi	r18, 0x00	; 0
    21ea:	30 e0       	ldi	r19, 0x00	; 0
    21ec:	40 e2       	ldi	r20, 0x20	; 32
    21ee:	51 e4       	ldi	r21, 0x41	; 65
    21f0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21f4:	dc 01       	movw	r26, r24
    21f6:	cb 01       	movw	r24, r22
    21f8:	bc 01       	movw	r22, r24
    21fa:	cd 01       	movw	r24, r26
    21fc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2200:	dc 01       	movw	r26, r24
    2202:	cb 01       	movw	r24, r22
    2204:	9e 83       	std	Y+6, r25	; 0x06
    2206:	8d 83       	std	Y+5, r24	; 0x05
    2208:	0f c0       	rjmp	.+30     	; 0x2228 <LCD_voidInit+0x4d6>
    220a:	80 e9       	ldi	r24, 0x90	; 144
    220c:	91 e0       	ldi	r25, 0x01	; 1
    220e:	9c 83       	std	Y+4, r25	; 0x04
    2210:	8b 83       	std	Y+3, r24	; 0x03
    2212:	8b 81       	ldd	r24, Y+3	; 0x03
    2214:	9c 81       	ldd	r25, Y+4	; 0x04
    2216:	01 97       	sbiw	r24, 0x01	; 1
    2218:	f1 f7       	brne	.-4      	; 0x2216 <LCD_voidInit+0x4c4>
    221a:	9c 83       	std	Y+4, r25	; 0x04
    221c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    221e:	8d 81       	ldd	r24, Y+5	; 0x05
    2220:	9e 81       	ldd	r25, Y+6	; 0x06
    2222:	01 97       	sbiw	r24, 0x01	; 1
    2224:	9e 83       	std	Y+6, r25	; 0x06
    2226:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2228:	8d 81       	ldd	r24, Y+5	; 0x05
    222a:	9e 81       	ldd	r25, Y+6	; 0x06
    222c:	00 97       	sbiw	r24, 0x00	; 0
    222e:	69 f7       	brne	.-38     	; 0x220a <LCD_voidInit+0x4b8>
    2230:	14 c0       	rjmp	.+40     	; 0x225a <LCD_voidInit+0x508>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2232:	6f 81       	ldd	r22, Y+7	; 0x07
    2234:	78 85       	ldd	r23, Y+8	; 0x08
    2236:	89 85       	ldd	r24, Y+9	; 0x09
    2238:	9a 85       	ldd	r25, Y+10	; 0x0a
    223a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    223e:	dc 01       	movw	r26, r24
    2240:	cb 01       	movw	r24, r22
    2242:	9e 83       	std	Y+6, r25	; 0x06
    2244:	8d 83       	std	Y+5, r24	; 0x05
    2246:	8d 81       	ldd	r24, Y+5	; 0x05
    2248:	9e 81       	ldd	r25, Y+6	; 0x06
    224a:	9a 83       	std	Y+2, r25	; 0x02
    224c:	89 83       	std	Y+1, r24	; 0x01
    224e:	89 81       	ldd	r24, Y+1	; 0x01
    2250:	9a 81       	ldd	r25, Y+2	; 0x02
    2252:	01 97       	sbiw	r24, 0x01	; 1
    2254:	f1 f7       	brne	.-4      	; 0x2252 <LCD_voidInit+0x500>
    2256:	9a 83       	std	Y+2, r25	; 0x02
    2258:	89 83       	std	Y+1, r24	; 0x01

	_delay_ms(2);

	LCD_voidWriteCommand(0x06 );
    225a:	86 e0       	ldi	r24, 0x06	; 6
    225c:	0e 94 4e 11 	call	0x229c	; 0x229c <LCD_voidWriteCommand>

}
    2260:	ca 5b       	subi	r28, 0xBA	; 186
    2262:	df 4f       	sbci	r29, 0xFF	; 255
    2264:	0f b6       	in	r0, 0x3f	; 63
    2266:	f8 94       	cli
    2268:	de bf       	out	0x3e, r29	; 62
    226a:	0f be       	out	0x3f, r0	; 63
    226c:	cd bf       	out	0x3d, r28	; 61
    226e:	cf 91       	pop	r28
    2270:	df 91       	pop	r29
    2272:	1f 91       	pop	r17
    2274:	0f 91       	pop	r16
    2276:	08 95       	ret

00002278 <LCD_voidWriteData>:
void LCD_voidWriteData(u8 copy_u8data)
{
    2278:	df 93       	push	r29
    227a:	cf 93       	push	r28
    227c:	0f 92       	push	r0
    227e:	cd b7       	in	r28, 0x3d	; 61
    2280:	de b7       	in	r29, 0x3e	; 62
    2282:	89 83       	std	Y+1, r24	; 0x01

	DIO_SETPinValue(RS_PORT,RS_PIN,HIGH);
    2284:	80 e0       	ldi	r24, 0x00	; 0
    2286:	63 e0       	ldi	r22, 0x03	; 3
    2288:	41 e0       	ldi	r20, 0x01	; 1
    228a:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>


	LCD_voidWriteBitsToSend(copy_u8data);
    228e:	89 81       	ldd	r24, Y+1	; 0x01
    2290:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <LCD_voidWriteBitsToSend>
}
    2294:	0f 90       	pop	r0
    2296:	cf 91       	pop	r28
    2298:	df 91       	pop	r29
    229a:	08 95       	ret

0000229c <LCD_voidWriteCommand>:
void LCD_voidWriteCommand(u8 copy_u8Command)
{
    229c:	df 93       	push	r29
    229e:	cf 93       	push	r28
    22a0:	0f 92       	push	r0
    22a2:	cd b7       	in	r28, 0x3d	; 61
    22a4:	de b7       	in	r29, 0x3e	; 62
    22a6:	89 83       	std	Y+1, r24	; 0x01
	DIO_SETPinValue(RS_PORT,RS_PIN,LOW);
    22a8:	80 e0       	ldi	r24, 0x00	; 0
    22aa:	63 e0       	ldi	r22, 0x03	; 3
    22ac:	40 e0       	ldi	r20, 0x00	; 0
    22ae:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>



	LCD_voidWriteBitsToSend(copy_u8Command);
    22b2:	89 81       	ldd	r24, Y+1	; 0x01
    22b4:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <LCD_voidWriteBitsToSend>
}
    22b8:	0f 90       	pop	r0
    22ba:	cf 91       	pop	r28
    22bc:	df 91       	pop	r29
    22be:	08 95       	ret

000022c0 <LCD_voidWriteString>:
void LCD_voidWriteString(u8 * copy_str)
{
    22c0:	df 93       	push	r29
    22c2:	cf 93       	push	r28
    22c4:	00 d0       	rcall	.+0      	; 0x22c6 <LCD_voidWriteString+0x6>
    22c6:	00 d0       	rcall	.+0      	; 0x22c8 <LCD_voidWriteString+0x8>
    22c8:	00 d0       	rcall	.+0      	; 0x22ca <LCD_voidWriteString+0xa>
    22ca:	cd b7       	in	r28, 0x3d	; 61
    22cc:	de b7       	in	r29, 0x3e	; 62
    22ce:	9e 83       	std	Y+6, r25	; 0x06
    22d0:	8d 83       	std	Y+5, r24	; 0x05
	u32 i= 0;
    22d2:	19 82       	std	Y+1, r1	; 0x01
    22d4:	1a 82       	std	Y+2, r1	; 0x02
    22d6:	1b 82       	std	Y+3, r1	; 0x03
    22d8:	1c 82       	std	Y+4, r1	; 0x04
    22da:	15 c0       	rjmp	.+42     	; 0x2306 <LCD_voidWriteString+0x46>
	while(copy_str[i] != '\0')
	{
		LCD_voidWriteData(copy_str[i]);
    22dc:	29 81       	ldd	r18, Y+1	; 0x01
    22de:	3a 81       	ldd	r19, Y+2	; 0x02
    22e0:	8d 81       	ldd	r24, Y+5	; 0x05
    22e2:	9e 81       	ldd	r25, Y+6	; 0x06
    22e4:	fc 01       	movw	r30, r24
    22e6:	e2 0f       	add	r30, r18
    22e8:	f3 1f       	adc	r31, r19
    22ea:	80 81       	ld	r24, Z
    22ec:	0e 94 3c 11 	call	0x2278	; 0x2278 <LCD_voidWriteData>
		i++;
    22f0:	89 81       	ldd	r24, Y+1	; 0x01
    22f2:	9a 81       	ldd	r25, Y+2	; 0x02
    22f4:	ab 81       	ldd	r26, Y+3	; 0x03
    22f6:	bc 81       	ldd	r27, Y+4	; 0x04
    22f8:	01 96       	adiw	r24, 0x01	; 1
    22fa:	a1 1d       	adc	r26, r1
    22fc:	b1 1d       	adc	r27, r1
    22fe:	89 83       	std	Y+1, r24	; 0x01
    2300:	9a 83       	std	Y+2, r25	; 0x02
    2302:	ab 83       	std	Y+3, r26	; 0x03
    2304:	bc 83       	std	Y+4, r27	; 0x04
	LCD_voidWriteBitsToSend(copy_u8Command);
}
void LCD_voidWriteString(u8 * copy_str)
{
	u32 i= 0;
	while(copy_str[i] != '\0')
    2306:	29 81       	ldd	r18, Y+1	; 0x01
    2308:	3a 81       	ldd	r19, Y+2	; 0x02
    230a:	8d 81       	ldd	r24, Y+5	; 0x05
    230c:	9e 81       	ldd	r25, Y+6	; 0x06
    230e:	fc 01       	movw	r30, r24
    2310:	e2 0f       	add	r30, r18
    2312:	f3 1f       	adc	r31, r19
    2314:	80 81       	ld	r24, Z
    2316:	88 23       	and	r24, r24
    2318:	09 f7       	brne	.-62     	; 0x22dc <LCD_voidWriteString+0x1c>
	{
		LCD_voidWriteData(copy_str[i]);
		i++;
	}
}
    231a:	26 96       	adiw	r28, 0x06	; 6
    231c:	0f b6       	in	r0, 0x3f	; 63
    231e:	f8 94       	cli
    2320:	de bf       	out	0x3e, r29	; 62
    2322:	0f be       	out	0x3f, r0	; 63
    2324:	cd bf       	out	0x3d, r28	; 61
    2326:	cf 91       	pop	r28
    2328:	df 91       	pop	r29
    232a:	08 95       	ret

0000232c <LCD_voidWriteChar>:

void LCD_voidWriteChar(u8 CharData)
{
    232c:	df 93       	push	r29
    232e:	cf 93       	push	r28
    2330:	0f 92       	push	r0
    2332:	cd b7       	in	r28, 0x3d	; 61
    2334:	de b7       	in	r29, 0x3e	; 62
    2336:	89 83       	std	Y+1, r24	; 0x01
	LCD_voidWriteData(CharData);
    2338:	89 81       	ldd	r24, Y+1	; 0x01
    233a:	0e 94 3c 11 	call	0x2278	; 0x2278 <LCD_voidWriteData>
}
    233e:	0f 90       	pop	r0
    2340:	cf 91       	pop	r28
    2342:	df 91       	pop	r29
    2344:	08 95       	ret

00002346 <LCD_SetCursor>:

void LCD_SetCursor(u8 Row , u8 Col)
{
    2346:	df 93       	push	r29
    2348:	cf 93       	push	r28
    234a:	00 d0       	rcall	.+0      	; 0x234c <LCD_SetCursor+0x6>
    234c:	00 d0       	rcall	.+0      	; 0x234e <LCD_SetCursor+0x8>
    234e:	cd b7       	in	r28, 0x3d	; 61
    2350:	de b7       	in	r29, 0x3e	; 62
    2352:	89 83       	std	Y+1, r24	; 0x01
    2354:	6a 83       	std	Y+2, r22	; 0x02
	switch(Row)
    2356:	89 81       	ldd	r24, Y+1	; 0x01
    2358:	28 2f       	mov	r18, r24
    235a:	30 e0       	ldi	r19, 0x00	; 0
    235c:	3c 83       	std	Y+4, r19	; 0x04
    235e:	2b 83       	std	Y+3, r18	; 0x03
    2360:	8b 81       	ldd	r24, Y+3	; 0x03
    2362:	9c 81       	ldd	r25, Y+4	; 0x04
    2364:	00 97       	sbiw	r24, 0x00	; 0
    2366:	31 f0       	breq	.+12     	; 0x2374 <LCD_SetCursor+0x2e>
    2368:	2b 81       	ldd	r18, Y+3	; 0x03
    236a:	3c 81       	ldd	r19, Y+4	; 0x04
    236c:	21 30       	cpi	r18, 0x01	; 1
    236e:	31 05       	cpc	r19, r1
    2370:	31 f0       	breq	.+12     	; 0x237e <LCD_SetCursor+0x38>
    2372:	09 c0       	rjmp	.+18     	; 0x2386 <LCD_SetCursor+0x40>
	{
		case Row0 : LCD_voidWriteCommand( ((0x80) |Col ) );  break;
    2374:	8a 81       	ldd	r24, Y+2	; 0x02
    2376:	80 68       	ori	r24, 0x80	; 128
    2378:	0e 94 4e 11 	call	0x229c	; 0x229c <LCD_voidWriteCommand>
    237c:	04 c0       	rjmp	.+8      	; 0x2386 <LCD_SetCursor+0x40>
		case Row1 : LCD_voidWriteCommand( ((0x80) | (0x40) | Col ) );  break;
    237e:	8a 81       	ldd	r24, Y+2	; 0x02
    2380:	80 6c       	ori	r24, 0xC0	; 192
    2382:	0e 94 4e 11 	call	0x229c	; 0x229c <LCD_voidWriteCommand>
		default :  break;
	}

}
    2386:	0f 90       	pop	r0
    2388:	0f 90       	pop	r0
    238a:	0f 90       	pop	r0
    238c:	0f 90       	pop	r0
    238e:	cf 91       	pop	r28
    2390:	df 91       	pop	r29
    2392:	08 95       	ret

00002394 <LCD_voidClear>:

void LCD_voidClear(void)
{
    2394:	df 93       	push	r29
    2396:	cf 93       	push	r28
    2398:	cd b7       	in	r28, 0x3d	; 61
    239a:	de b7       	in	r29, 0x3e	; 62
	LCD_voidWriteCommand( 0x01);
    239c:	81 e0       	ldi	r24, 0x01	; 1
    239e:	0e 94 4e 11 	call	0x229c	; 0x229c <LCD_voidWriteCommand>
}
    23a2:	cf 91       	pop	r28
    23a4:	df 91       	pop	r29
    23a6:	08 95       	ret

000023a8 <LCD_voidWriteNumber>:
//			i--;
//		}
//
//	}
void LCD_voidWriteNumber( u32 Copy_u8num )
{
    23a8:	0f 93       	push	r16
    23aa:	1f 93       	push	r17
    23ac:	df 93       	push	r29
    23ae:	cf 93       	push	r28
    23b0:	cd b7       	in	r28, 0x3d	; 61
    23b2:	de b7       	in	r29, 0x3e	; 62
    23b4:	63 97       	sbiw	r28, 0x13	; 19
    23b6:	0f b6       	in	r0, 0x3f	; 63
    23b8:	f8 94       	cli
    23ba:	de bf       	out	0x3e, r29	; 62
    23bc:	0f be       	out	0x3f, r0	; 63
    23be:	cd bf       	out	0x3d, r28	; 61
    23c0:	68 8b       	std	Y+16, r22	; 0x10
    23c2:	79 8b       	std	Y+17, r23	; 0x11
    23c4:	8a 8b       	std	Y+18, r24	; 0x12
    23c6:	9b 8b       	std	Y+19, r25	; 0x13
	u32 LOCAL_NUMBER=Copy_u8num ;
    23c8:	88 89       	ldd	r24, Y+16	; 0x10
    23ca:	99 89       	ldd	r25, Y+17	; 0x11
    23cc:	aa 89       	ldd	r26, Y+18	; 0x12
    23ce:	bb 89       	ldd	r27, Y+19	; 0x13
    23d0:	8a 83       	std	Y+2, r24	; 0x02
    23d2:	9b 83       	std	Y+3, r25	; 0x03
    23d4:	ac 83       	std	Y+4, r26	; 0x04
    23d6:	bd 83       	std	Y+5, r27	; 0x05
	u8 LOCAL_ARR[10] ,i=0 ;
    23d8:	19 82       	std	Y+1, r1	; 0x01

	do
	{
		LOCAL_ARR[i]= ((LOCAL_NUMBER%10)+48);
    23da:	89 81       	ldd	r24, Y+1	; 0x01
    23dc:	08 2f       	mov	r16, r24
    23de:	10 e0       	ldi	r17, 0x00	; 0
    23e0:	8a 81       	ldd	r24, Y+2	; 0x02
    23e2:	9b 81       	ldd	r25, Y+3	; 0x03
    23e4:	ac 81       	ldd	r26, Y+4	; 0x04
    23e6:	bd 81       	ldd	r27, Y+5	; 0x05
    23e8:	2a e0       	ldi	r18, 0x0A	; 10
    23ea:	30 e0       	ldi	r19, 0x00	; 0
    23ec:	40 e0       	ldi	r20, 0x00	; 0
    23ee:	50 e0       	ldi	r21, 0x00	; 0
    23f0:	bc 01       	movw	r22, r24
    23f2:	cd 01       	movw	r24, r26
    23f4:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <__udivmodsi4>
    23f8:	dc 01       	movw	r26, r24
    23fa:	cb 01       	movw	r24, r22
    23fc:	28 2f       	mov	r18, r24
    23fe:	20 5d       	subi	r18, 0xD0	; 208
    2400:	ce 01       	movw	r24, r28
    2402:	06 96       	adiw	r24, 0x06	; 6
    2404:	fc 01       	movw	r30, r24
    2406:	e0 0f       	add	r30, r16
    2408:	f1 1f       	adc	r31, r17
    240a:	20 83       	st	Z, r18
		LOCAL_NUMBER=LOCAL_NUMBER/10 ;
    240c:	8a 81       	ldd	r24, Y+2	; 0x02
    240e:	9b 81       	ldd	r25, Y+3	; 0x03
    2410:	ac 81       	ldd	r26, Y+4	; 0x04
    2412:	bd 81       	ldd	r27, Y+5	; 0x05
    2414:	2a e0       	ldi	r18, 0x0A	; 10
    2416:	30 e0       	ldi	r19, 0x00	; 0
    2418:	40 e0       	ldi	r20, 0x00	; 0
    241a:	50 e0       	ldi	r21, 0x00	; 0
    241c:	bc 01       	movw	r22, r24
    241e:	cd 01       	movw	r24, r26
    2420:	0e 94 74 27 	call	0x4ee8	; 0x4ee8 <__udivmodsi4>
    2424:	da 01       	movw	r26, r20
    2426:	c9 01       	movw	r24, r18
    2428:	8a 83       	std	Y+2, r24	; 0x02
    242a:	9b 83       	std	Y+3, r25	; 0x03
    242c:	ac 83       	std	Y+4, r26	; 0x04
    242e:	bd 83       	std	Y+5, r27	; 0x05

		i++ ;
    2430:	89 81       	ldd	r24, Y+1	; 0x01
    2432:	8f 5f       	subi	r24, 0xFF	; 255
    2434:	89 83       	std	Y+1, r24	; 0x01
	}
	while(LOCAL_NUMBER!=0);
    2436:	8a 81       	ldd	r24, Y+2	; 0x02
    2438:	9b 81       	ldd	r25, Y+3	; 0x03
    243a:	ac 81       	ldd	r26, Y+4	; 0x04
    243c:	bd 81       	ldd	r27, Y+5	; 0x05
    243e:	00 97       	sbiw	r24, 0x00	; 0
    2440:	a1 05       	cpc	r26, r1
    2442:	b1 05       	cpc	r27, r1
    2444:	51 f6       	brne	.-108    	; 0x23da <LCD_voidWriteNumber+0x32>
    2446:	11 c0       	rjmp	.+34     	; 0x246a <LCD_voidWriteNumber+0xc2>
				LCD_voidWriteData(48);
		}*/

	for(;i>0;i--)
	{
		LCD_voidWriteData(LOCAL_ARR[i-1]);
    2448:	89 81       	ldd	r24, Y+1	; 0x01
    244a:	88 2f       	mov	r24, r24
    244c:	90 e0       	ldi	r25, 0x00	; 0
    244e:	9c 01       	movw	r18, r24
    2450:	21 50       	subi	r18, 0x01	; 1
    2452:	30 40       	sbci	r19, 0x00	; 0
    2454:	ce 01       	movw	r24, r28
    2456:	06 96       	adiw	r24, 0x06	; 6
    2458:	fc 01       	movw	r30, r24
    245a:	e2 0f       	add	r30, r18
    245c:	f3 1f       	adc	r31, r19
    245e:	80 81       	ld	r24, Z
    2460:	0e 94 3c 11 	call	0x2278	; 0x2278 <LCD_voidWriteData>
	if(Copy_u8num==0)
		{
				LCD_voidWriteData(48);
		}*/

	for(;i>0;i--)
    2464:	89 81       	ldd	r24, Y+1	; 0x01
    2466:	81 50       	subi	r24, 0x01	; 1
    2468:	89 83       	std	Y+1, r24	; 0x01
    246a:	89 81       	ldd	r24, Y+1	; 0x01
    246c:	88 23       	and	r24, r24
    246e:	61 f7       	brne	.-40     	; 0x2448 <LCD_voidWriteNumber+0xa0>
	{
		LCD_voidWriteData(LOCAL_ARR[i-1]);
	}

}
    2470:	63 96       	adiw	r28, 0x13	; 19
    2472:	0f b6       	in	r0, 0x3f	; 63
    2474:	f8 94       	cli
    2476:	de bf       	out	0x3e, r29	; 62
    2478:	0f be       	out	0x3f, r0	; 63
    247a:	cd bf       	out	0x3d, r28	; 61
    247c:	cf 91       	pop	r28
    247e:	df 91       	pop	r29
    2480:	1f 91       	pop	r17
    2482:	0f 91       	pop	r16
    2484:	08 95       	ret

00002486 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    2486:	df 93       	push	r29
    2488:	cf 93       	push	r28
    248a:	cd b7       	in	r28, 0x3d	; 61
    248c:	de b7       	in	r29, 0x3e	; 62
    248e:	27 97       	sbiw	r28, 0x07	; 7
    2490:	0f b6       	in	r0, 0x3f	; 63
    2492:	f8 94       	cli
    2494:	de bf       	out	0x3e, r29	; 62
    2496:	0f be       	out	0x3f, r0	; 63
    2498:	cd bf       	out	0x3d, r28	; 61
    249a:	9d 83       	std	Y+5, r25	; 0x05
    249c:	8c 83       	std	Y+4, r24	; 0x04
    249e:	6e 83       	std	Y+6, r22	; 0x06
    24a0:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    24a2:	8a e1       	ldi	r24, 0x1A	; 26
    24a4:	90 e0       	ldi	r25, 0x00	; 0
    24a6:	0e 94 1b 15 	call	0x2a36	; 0x2a36 <pvPortMalloc>
    24aa:	9a 83       	std	Y+2, r25	; 0x02
    24ac:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    24ae:	89 81       	ldd	r24, Y+1	; 0x01
    24b0:	9a 81       	ldd	r25, Y+2	; 0x02
    24b2:	00 97       	sbiw	r24, 0x00	; 0
    24b4:	09 f4       	brne	.+2      	; 0x24b8 <xCoRoutineCreate+0x32>
    24b6:	6f c0       	rjmp	.+222    	; 0x2596 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    24b8:	80 91 a6 00 	lds	r24, 0x00A6
    24bc:	90 91 a7 00 	lds	r25, 0x00A7
    24c0:	00 97       	sbiw	r24, 0x00	; 0
    24c2:	41 f4       	brne	.+16     	; 0x24d4 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    24c4:	89 81       	ldd	r24, Y+1	; 0x01
    24c6:	9a 81       	ldd	r25, Y+2	; 0x02
    24c8:	90 93 a7 00 	sts	0x00A7, r25
    24cc:	80 93 a6 00 	sts	0x00A6, r24
			prvInitialiseCoRoutineLists();
    24d0:	0e 94 aa 14 	call	0x2954	; 0x2954 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    24d4:	8e 81       	ldd	r24, Y+6	; 0x06
    24d6:	82 30       	cpi	r24, 0x02	; 2
    24d8:	10 f0       	brcs	.+4      	; 0x24de <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    24da:	81 e0       	ldi	r24, 0x01	; 1
    24dc:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    24de:	e9 81       	ldd	r30, Y+1	; 0x01
    24e0:	fa 81       	ldd	r31, Y+2	; 0x02
    24e2:	11 8e       	std	Z+25, r1	; 0x19
    24e4:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    24e6:	e9 81       	ldd	r30, Y+1	; 0x01
    24e8:	fa 81       	ldd	r31, Y+2	; 0x02
    24ea:	8e 81       	ldd	r24, Y+6	; 0x06
    24ec:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    24ee:	e9 81       	ldd	r30, Y+1	; 0x01
    24f0:	fa 81       	ldd	r31, Y+2	; 0x02
    24f2:	8f 81       	ldd	r24, Y+7	; 0x07
    24f4:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    24f6:	e9 81       	ldd	r30, Y+1	; 0x01
    24f8:	fa 81       	ldd	r31, Y+2	; 0x02
    24fa:	8c 81       	ldd	r24, Y+4	; 0x04
    24fc:	9d 81       	ldd	r25, Y+5	; 0x05
    24fe:	91 83       	std	Z+1, r25	; 0x01
    2500:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2502:	89 81       	ldd	r24, Y+1	; 0x01
    2504:	9a 81       	ldd	r25, Y+2	; 0x02
    2506:	02 96       	adiw	r24, 0x02	; 2
    2508:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    250c:	89 81       	ldd	r24, Y+1	; 0x01
    250e:	9a 81       	ldd	r25, Y+2	; 0x02
    2510:	0c 96       	adiw	r24, 0x0c	; 12
    2512:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2516:	e9 81       	ldd	r30, Y+1	; 0x01
    2518:	fa 81       	ldd	r31, Y+2	; 0x02
    251a:	89 81       	ldd	r24, Y+1	; 0x01
    251c:	9a 81       	ldd	r25, Y+2	; 0x02
    251e:	91 87       	std	Z+9, r25	; 0x09
    2520:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2522:	e9 81       	ldd	r30, Y+1	; 0x01
    2524:	fa 81       	ldd	r31, Y+2	; 0x02
    2526:	89 81       	ldd	r24, Y+1	; 0x01
    2528:	9a 81       	ldd	r25, Y+2	; 0x02
    252a:	93 8b       	std	Z+19, r25	; 0x13
    252c:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    252e:	8e 81       	ldd	r24, Y+6	; 0x06
    2530:	28 2f       	mov	r18, r24
    2532:	30 e0       	ldi	r19, 0x00	; 0
    2534:	86 e0       	ldi	r24, 0x06	; 6
    2536:	90 e0       	ldi	r25, 0x00	; 0
    2538:	82 1b       	sub	r24, r18
    253a:	93 0b       	sbc	r25, r19
    253c:	e9 81       	ldd	r30, Y+1	; 0x01
    253e:	fa 81       	ldd	r31, Y+2	; 0x02
    2540:	95 87       	std	Z+13, r25	; 0x0d
    2542:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2544:	e9 81       	ldd	r30, Y+1	; 0x01
    2546:	fa 81       	ldd	r31, Y+2	; 0x02
    2548:	96 89       	ldd	r25, Z+22	; 0x16
    254a:	80 91 a8 00 	lds	r24, 0x00A8
    254e:	89 17       	cp	r24, r25
    2550:	28 f4       	brcc	.+10     	; 0x255c <xCoRoutineCreate+0xd6>
    2552:	e9 81       	ldd	r30, Y+1	; 0x01
    2554:	fa 81       	ldd	r31, Y+2	; 0x02
    2556:	86 89       	ldd	r24, Z+22	; 0x16
    2558:	80 93 a8 00 	sts	0x00A8, r24
    255c:	e9 81       	ldd	r30, Y+1	; 0x01
    255e:	fa 81       	ldd	r31, Y+2	; 0x02
    2560:	86 89       	ldd	r24, Z+22	; 0x16
    2562:	28 2f       	mov	r18, r24
    2564:	30 e0       	ldi	r19, 0x00	; 0
    2566:	c9 01       	movw	r24, r18
    2568:	88 0f       	add	r24, r24
    256a:	99 1f       	adc	r25, r25
    256c:	88 0f       	add	r24, r24
    256e:	99 1f       	adc	r25, r25
    2570:	88 0f       	add	r24, r24
    2572:	99 1f       	adc	r25, r25
    2574:	82 0f       	add	r24, r18
    2576:	93 1f       	adc	r25, r19
    2578:	ac 01       	movw	r20, r24
    257a:	41 55       	subi	r20, 0x51	; 81
    257c:	5f 4f       	sbci	r21, 0xFF	; 255
    257e:	89 81       	ldd	r24, Y+1	; 0x01
    2580:	9a 81       	ldd	r25, Y+2	; 0x02
    2582:	9c 01       	movw	r18, r24
    2584:	2e 5f       	subi	r18, 0xFE	; 254
    2586:	3f 4f       	sbci	r19, 0xFF	; 255
    2588:	ca 01       	movw	r24, r20
    258a:	b9 01       	movw	r22, r18
    258c:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>

		xReturn = pdPASS;
    2590:	81 e0       	ldi	r24, 0x01	; 1
    2592:	8b 83       	std	Y+3, r24	; 0x03
    2594:	02 c0       	rjmp	.+4      	; 0x259a <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2596:	8f ef       	ldi	r24, 0xFF	; 255
    2598:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    259a:	8b 81       	ldd	r24, Y+3	; 0x03
}
    259c:	27 96       	adiw	r28, 0x07	; 7
    259e:	0f b6       	in	r0, 0x3f	; 63
    25a0:	f8 94       	cli
    25a2:	de bf       	out	0x3e, r29	; 62
    25a4:	0f be       	out	0x3f, r0	; 63
    25a6:	cd bf       	out	0x3d, r28	; 61
    25a8:	cf 91       	pop	r28
    25aa:	df 91       	pop	r29
    25ac:	08 95       	ret

000025ae <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    25ae:	df 93       	push	r29
    25b0:	cf 93       	push	r28
    25b2:	00 d0       	rcall	.+0      	; 0x25b4 <vCoRoutineAddToDelayedList+0x6>
    25b4:	00 d0       	rcall	.+0      	; 0x25b6 <vCoRoutineAddToDelayedList+0x8>
    25b6:	00 d0       	rcall	.+0      	; 0x25b8 <vCoRoutineAddToDelayedList+0xa>
    25b8:	cd b7       	in	r28, 0x3d	; 61
    25ba:	de b7       	in	r29, 0x3e	; 62
    25bc:	9c 83       	std	Y+4, r25	; 0x04
    25be:	8b 83       	std	Y+3, r24	; 0x03
    25c0:	7e 83       	std	Y+6, r23	; 0x06
    25c2:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    25c4:	20 91 a9 00 	lds	r18, 0x00A9
    25c8:	30 91 aa 00 	lds	r19, 0x00AA
    25cc:	8b 81       	ldd	r24, Y+3	; 0x03
    25ce:	9c 81       	ldd	r25, Y+4	; 0x04
    25d0:	82 0f       	add	r24, r18
    25d2:	93 1f       	adc	r25, r19
    25d4:	9a 83       	std	Y+2, r25	; 0x02
    25d6:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    25d8:	80 91 a6 00 	lds	r24, 0x00A6
    25dc:	90 91 a7 00 	lds	r25, 0x00A7
    25e0:	02 96       	adiw	r24, 0x02	; 2
    25e2:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    25e6:	e0 91 a6 00 	lds	r30, 0x00A6
    25ea:	f0 91 a7 00 	lds	r31, 0x00A7
    25ee:	89 81       	ldd	r24, Y+1	; 0x01
    25f0:	9a 81       	ldd	r25, Y+2	; 0x02
    25f2:	93 83       	std	Z+3, r25	; 0x03
    25f4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    25f6:	20 91 a9 00 	lds	r18, 0x00A9
    25fa:	30 91 aa 00 	lds	r19, 0x00AA
    25fe:	89 81       	ldd	r24, Y+1	; 0x01
    2600:	9a 81       	ldd	r25, Y+2	; 0x02
    2602:	82 17       	cp	r24, r18
    2604:	93 07       	cpc	r25, r19
    2606:	70 f4       	brcc	.+28     	; 0x2624 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2608:	80 91 d5 00 	lds	r24, 0x00D5
    260c:	90 91 d6 00 	lds	r25, 0x00D6
    2610:	20 91 a6 00 	lds	r18, 0x00A6
    2614:	30 91 a7 00 	lds	r19, 0x00A7
    2618:	2e 5f       	subi	r18, 0xFE	; 254
    261a:	3f 4f       	sbci	r19, 0xFF	; 255
    261c:	b9 01       	movw	r22, r18
    261e:	0e 94 0d 16 	call	0x2c1a	; 0x2c1a <vListInsert>
    2622:	0d c0       	rjmp	.+26     	; 0x263e <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2624:	80 91 d3 00 	lds	r24, 0x00D3
    2628:	90 91 d4 00 	lds	r25, 0x00D4
    262c:	20 91 a6 00 	lds	r18, 0x00A6
    2630:	30 91 a7 00 	lds	r19, 0x00A7
    2634:	2e 5f       	subi	r18, 0xFE	; 254
    2636:	3f 4f       	sbci	r19, 0xFF	; 255
    2638:	b9 01       	movw	r22, r18
    263a:	0e 94 0d 16 	call	0x2c1a	; 0x2c1a <vListInsert>
	}

	if( pxEventList )
    263e:	8d 81       	ldd	r24, Y+5	; 0x05
    2640:	9e 81       	ldd	r25, Y+6	; 0x06
    2642:	00 97       	sbiw	r24, 0x00	; 0
    2644:	61 f0       	breq	.+24     	; 0x265e <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2646:	80 91 a6 00 	lds	r24, 0x00A6
    264a:	90 91 a7 00 	lds	r25, 0x00A7
    264e:	9c 01       	movw	r18, r24
    2650:	24 5f       	subi	r18, 0xF4	; 244
    2652:	3f 4f       	sbci	r19, 0xFF	; 255
    2654:	8d 81       	ldd	r24, Y+5	; 0x05
    2656:	9e 81       	ldd	r25, Y+6	; 0x06
    2658:	b9 01       	movw	r22, r18
    265a:	0e 94 0d 16 	call	0x2c1a	; 0x2c1a <vListInsert>
	}
}
    265e:	26 96       	adiw	r28, 0x06	; 6
    2660:	0f b6       	in	r0, 0x3f	; 63
    2662:	f8 94       	cli
    2664:	de bf       	out	0x3e, r29	; 62
    2666:	0f be       	out	0x3f, r0	; 63
    2668:	cd bf       	out	0x3d, r28	; 61
    266a:	cf 91       	pop	r28
    266c:	df 91       	pop	r29
    266e:	08 95       	ret

00002670 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    2670:	df 93       	push	r29
    2672:	cf 93       	push	r28
    2674:	00 d0       	rcall	.+0      	; 0x2676 <prvCheckPendingReadyList+0x6>
    2676:	cd b7       	in	r28, 0x3d	; 61
    2678:	de b7       	in	r29, 0x3e	; 62
    267a:	3a c0       	rjmp	.+116    	; 0x26f0 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    267c:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    267e:	e0 91 dc 00 	lds	r30, 0x00DC
    2682:	f0 91 dd 00 	lds	r31, 0x00DD
    2686:	86 81       	ldd	r24, Z+6	; 0x06
    2688:	97 81       	ldd	r25, Z+7	; 0x07
    268a:	9a 83       	std	Y+2, r25	; 0x02
    268c:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    268e:	89 81       	ldd	r24, Y+1	; 0x01
    2690:	9a 81       	ldd	r25, Y+2	; 0x02
    2692:	0c 96       	adiw	r24, 0x0c	; 12
    2694:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    2698:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    269a:	89 81       	ldd	r24, Y+1	; 0x01
    269c:	9a 81       	ldd	r25, Y+2	; 0x02
    269e:	02 96       	adiw	r24, 0x02	; 2
    26a0:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    26a4:	e9 81       	ldd	r30, Y+1	; 0x01
    26a6:	fa 81       	ldd	r31, Y+2	; 0x02
    26a8:	96 89       	ldd	r25, Z+22	; 0x16
    26aa:	80 91 a8 00 	lds	r24, 0x00A8
    26ae:	89 17       	cp	r24, r25
    26b0:	28 f4       	brcc	.+10     	; 0x26bc <prvCheckPendingReadyList+0x4c>
    26b2:	e9 81       	ldd	r30, Y+1	; 0x01
    26b4:	fa 81       	ldd	r31, Y+2	; 0x02
    26b6:	86 89       	ldd	r24, Z+22	; 0x16
    26b8:	80 93 a8 00 	sts	0x00A8, r24
    26bc:	e9 81       	ldd	r30, Y+1	; 0x01
    26be:	fa 81       	ldd	r31, Y+2	; 0x02
    26c0:	86 89       	ldd	r24, Z+22	; 0x16
    26c2:	28 2f       	mov	r18, r24
    26c4:	30 e0       	ldi	r19, 0x00	; 0
    26c6:	c9 01       	movw	r24, r18
    26c8:	88 0f       	add	r24, r24
    26ca:	99 1f       	adc	r25, r25
    26cc:	88 0f       	add	r24, r24
    26ce:	99 1f       	adc	r25, r25
    26d0:	88 0f       	add	r24, r24
    26d2:	99 1f       	adc	r25, r25
    26d4:	82 0f       	add	r24, r18
    26d6:	93 1f       	adc	r25, r19
    26d8:	ac 01       	movw	r20, r24
    26da:	41 55       	subi	r20, 0x51	; 81
    26dc:	5f 4f       	sbci	r21, 0xFF	; 255
    26de:	89 81       	ldd	r24, Y+1	; 0x01
    26e0:	9a 81       	ldd	r25, Y+2	; 0x02
    26e2:	9c 01       	movw	r18, r24
    26e4:	2e 5f       	subi	r18, 0xFE	; 254
    26e6:	3f 4f       	sbci	r19, 0xFF	; 255
    26e8:	ca 01       	movw	r24, r20
    26ea:	b9 01       	movw	r22, r18
    26ec:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    26f0:	80 91 d7 00 	lds	r24, 0x00D7
    26f4:	88 23       	and	r24, r24
    26f6:	09 f0       	breq	.+2      	; 0x26fa <prvCheckPendingReadyList+0x8a>
    26f8:	c1 cf       	rjmp	.-126    	; 0x267c <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    26fa:	0f 90       	pop	r0
    26fc:	0f 90       	pop	r0
    26fe:	cf 91       	pop	r28
    2700:	df 91       	pop	r29
    2702:	08 95       	ret

00002704 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2704:	df 93       	push	r29
    2706:	cf 93       	push	r28
    2708:	00 d0       	rcall	.+0      	; 0x270a <prvCheckDelayedList+0x6>
    270a:	00 d0       	rcall	.+0      	; 0x270c <prvCheckDelayedList+0x8>
    270c:	cd b7       	in	r28, 0x3d	; 61
    270e:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2710:	0e 94 65 22 	call	0x44ca	; 0x44ca <xTaskGetTickCount>
    2714:	20 91 ab 00 	lds	r18, 0x00AB
    2718:	30 91 ac 00 	lds	r19, 0x00AC
    271c:	82 1b       	sub	r24, r18
    271e:	93 0b       	sbc	r25, r19
    2720:	90 93 ae 00 	sts	0x00AE, r25
    2724:	80 93 ad 00 	sts	0x00AD, r24
    2728:	85 c0       	rjmp	.+266    	; 0x2834 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    272a:	80 91 a9 00 	lds	r24, 0x00A9
    272e:	90 91 aa 00 	lds	r25, 0x00AA
    2732:	01 96       	adiw	r24, 0x01	; 1
    2734:	90 93 aa 00 	sts	0x00AA, r25
    2738:	80 93 a9 00 	sts	0x00A9, r24
		xPassedTicks--;
    273c:	80 91 ad 00 	lds	r24, 0x00AD
    2740:	90 91 ae 00 	lds	r25, 0x00AE
    2744:	01 97       	sbiw	r24, 0x01	; 1
    2746:	90 93 ae 00 	sts	0x00AE, r25
    274a:	80 93 ad 00 	sts	0x00AD, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    274e:	80 91 a9 00 	lds	r24, 0x00A9
    2752:	90 91 aa 00 	lds	r25, 0x00AA
    2756:	00 97       	sbiw	r24, 0x00	; 0
    2758:	09 f0       	breq	.+2      	; 0x275c <prvCheckDelayedList+0x58>
    275a:	64 c0       	rjmp	.+200    	; 0x2824 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    275c:	80 91 d3 00 	lds	r24, 0x00D3
    2760:	90 91 d4 00 	lds	r25, 0x00D4
    2764:	9a 83       	std	Y+2, r25	; 0x02
    2766:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2768:	80 91 d5 00 	lds	r24, 0x00D5
    276c:	90 91 d6 00 	lds	r25, 0x00D6
    2770:	90 93 d4 00 	sts	0x00D4, r25
    2774:	80 93 d3 00 	sts	0x00D3, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2778:	89 81       	ldd	r24, Y+1	; 0x01
    277a:	9a 81       	ldd	r25, Y+2	; 0x02
    277c:	90 93 d6 00 	sts	0x00D6, r25
    2780:	80 93 d5 00 	sts	0x00D5, r24
    2784:	4f c0       	rjmp	.+158    	; 0x2824 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2786:	e0 91 d3 00 	lds	r30, 0x00D3
    278a:	f0 91 d4 00 	lds	r31, 0x00D4
    278e:	05 80       	ldd	r0, Z+5	; 0x05
    2790:	f6 81       	ldd	r31, Z+6	; 0x06
    2792:	e0 2d       	mov	r30, r0
    2794:	86 81       	ldd	r24, Z+6	; 0x06
    2796:	97 81       	ldd	r25, Z+7	; 0x07
    2798:	9c 83       	std	Y+4, r25	; 0x04
    279a:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    279c:	eb 81       	ldd	r30, Y+3	; 0x03
    279e:	fc 81       	ldd	r31, Y+4	; 0x04
    27a0:	22 81       	ldd	r18, Z+2	; 0x02
    27a2:	33 81       	ldd	r19, Z+3	; 0x03
    27a4:	80 91 a9 00 	lds	r24, 0x00A9
    27a8:	90 91 aa 00 	lds	r25, 0x00AA
    27ac:	82 17       	cp	r24, r18
    27ae:	93 07       	cpc	r25, r19
    27b0:	08 f4       	brcc	.+2      	; 0x27b4 <prvCheckDelayedList+0xb0>
    27b2:	40 c0       	rjmp	.+128    	; 0x2834 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    27b4:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    27b6:	8b 81       	ldd	r24, Y+3	; 0x03
    27b8:	9c 81       	ldd	r25, Y+4	; 0x04
    27ba:	02 96       	adiw	r24, 0x02	; 2
    27bc:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    27c0:	eb 81       	ldd	r30, Y+3	; 0x03
    27c2:	fc 81       	ldd	r31, Y+4	; 0x04
    27c4:	84 89       	ldd	r24, Z+20	; 0x14
    27c6:	95 89       	ldd	r25, Z+21	; 0x15
    27c8:	00 97       	sbiw	r24, 0x00	; 0
    27ca:	29 f0       	breq	.+10     	; 0x27d6 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    27cc:	8b 81       	ldd	r24, Y+3	; 0x03
    27ce:	9c 81       	ldd	r25, Y+4	; 0x04
    27d0:	0c 96       	adiw	r24, 0x0c	; 12
    27d2:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    27d6:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    27d8:	eb 81       	ldd	r30, Y+3	; 0x03
    27da:	fc 81       	ldd	r31, Y+4	; 0x04
    27dc:	96 89       	ldd	r25, Z+22	; 0x16
    27de:	80 91 a8 00 	lds	r24, 0x00A8
    27e2:	89 17       	cp	r24, r25
    27e4:	28 f4       	brcc	.+10     	; 0x27f0 <prvCheckDelayedList+0xec>
    27e6:	eb 81       	ldd	r30, Y+3	; 0x03
    27e8:	fc 81       	ldd	r31, Y+4	; 0x04
    27ea:	86 89       	ldd	r24, Z+22	; 0x16
    27ec:	80 93 a8 00 	sts	0x00A8, r24
    27f0:	eb 81       	ldd	r30, Y+3	; 0x03
    27f2:	fc 81       	ldd	r31, Y+4	; 0x04
    27f4:	86 89       	ldd	r24, Z+22	; 0x16
    27f6:	28 2f       	mov	r18, r24
    27f8:	30 e0       	ldi	r19, 0x00	; 0
    27fa:	c9 01       	movw	r24, r18
    27fc:	88 0f       	add	r24, r24
    27fe:	99 1f       	adc	r25, r25
    2800:	88 0f       	add	r24, r24
    2802:	99 1f       	adc	r25, r25
    2804:	88 0f       	add	r24, r24
    2806:	99 1f       	adc	r25, r25
    2808:	82 0f       	add	r24, r18
    280a:	93 1f       	adc	r25, r19
    280c:	ac 01       	movw	r20, r24
    280e:	41 55       	subi	r20, 0x51	; 81
    2810:	5f 4f       	sbci	r21, 0xFF	; 255
    2812:	8b 81       	ldd	r24, Y+3	; 0x03
    2814:	9c 81       	ldd	r25, Y+4	; 0x04
    2816:	9c 01       	movw	r18, r24
    2818:	2e 5f       	subi	r18, 0xFE	; 254
    281a:	3f 4f       	sbci	r19, 0xFF	; 255
    281c:	ca 01       	movw	r24, r20
    281e:	b9 01       	movw	r22, r18
    2820:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2824:	e0 91 d3 00 	lds	r30, 0x00D3
    2828:	f0 91 d4 00 	lds	r31, 0x00D4
    282c:	80 81       	ld	r24, Z
    282e:	88 23       	and	r24, r24
    2830:	09 f0       	breq	.+2      	; 0x2834 <prvCheckDelayedList+0x130>
    2832:	a9 cf       	rjmp	.-174    	; 0x2786 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2834:	80 91 ad 00 	lds	r24, 0x00AD
    2838:	90 91 ae 00 	lds	r25, 0x00AE
    283c:	00 97       	sbiw	r24, 0x00	; 0
    283e:	09 f0       	breq	.+2      	; 0x2842 <prvCheckDelayedList+0x13e>
    2840:	74 cf       	rjmp	.-280    	; 0x272a <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2842:	80 91 a9 00 	lds	r24, 0x00A9
    2846:	90 91 aa 00 	lds	r25, 0x00AA
    284a:	90 93 ac 00 	sts	0x00AC, r25
    284e:	80 93 ab 00 	sts	0x00AB, r24
}
    2852:	0f 90       	pop	r0
    2854:	0f 90       	pop	r0
    2856:	0f 90       	pop	r0
    2858:	0f 90       	pop	r0
    285a:	cf 91       	pop	r28
    285c:	df 91       	pop	r29
    285e:	08 95       	ret

00002860 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2860:	df 93       	push	r29
    2862:	cf 93       	push	r28
    2864:	00 d0       	rcall	.+0      	; 0x2866 <vCoRoutineSchedule+0x6>
    2866:	cd b7       	in	r28, 0x3d	; 61
    2868:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    286a:	0e 94 38 13 	call	0x2670	; 0x2670 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    286e:	0e 94 82 13 	call	0x2704	; 0x2704 <prvCheckDelayedList>
    2872:	0a c0       	rjmp	.+20     	; 0x2888 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2874:	80 91 a8 00 	lds	r24, 0x00A8
    2878:	88 23       	and	r24, r24
    287a:	09 f4       	brne	.+2      	; 0x287e <vCoRoutineSchedule+0x1e>
    287c:	66 c0       	rjmp	.+204    	; 0x294a <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    287e:	80 91 a8 00 	lds	r24, 0x00A8
    2882:	81 50       	subi	r24, 0x01	; 1
    2884:	80 93 a8 00 	sts	0x00A8, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2888:	80 91 a8 00 	lds	r24, 0x00A8
    288c:	28 2f       	mov	r18, r24
    288e:	30 e0       	ldi	r19, 0x00	; 0
    2890:	c9 01       	movw	r24, r18
    2892:	88 0f       	add	r24, r24
    2894:	99 1f       	adc	r25, r25
    2896:	88 0f       	add	r24, r24
    2898:	99 1f       	adc	r25, r25
    289a:	88 0f       	add	r24, r24
    289c:	99 1f       	adc	r25, r25
    289e:	82 0f       	add	r24, r18
    28a0:	93 1f       	adc	r25, r19
    28a2:	fc 01       	movw	r30, r24
    28a4:	e1 55       	subi	r30, 0x51	; 81
    28a6:	ff 4f       	sbci	r31, 0xFF	; 255
    28a8:	80 81       	ld	r24, Z
    28aa:	88 23       	and	r24, r24
    28ac:	19 f3       	breq	.-58     	; 0x2874 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    28ae:	80 91 a8 00 	lds	r24, 0x00A8
    28b2:	28 2f       	mov	r18, r24
    28b4:	30 e0       	ldi	r19, 0x00	; 0
    28b6:	c9 01       	movw	r24, r18
    28b8:	88 0f       	add	r24, r24
    28ba:	99 1f       	adc	r25, r25
    28bc:	88 0f       	add	r24, r24
    28be:	99 1f       	adc	r25, r25
    28c0:	88 0f       	add	r24, r24
    28c2:	99 1f       	adc	r25, r25
    28c4:	82 0f       	add	r24, r18
    28c6:	93 1f       	adc	r25, r19
    28c8:	81 55       	subi	r24, 0x51	; 81
    28ca:	9f 4f       	sbci	r25, 0xFF	; 255
    28cc:	9a 83       	std	Y+2, r25	; 0x02
    28ce:	89 83       	std	Y+1, r24	; 0x01
    28d0:	e9 81       	ldd	r30, Y+1	; 0x01
    28d2:	fa 81       	ldd	r31, Y+2	; 0x02
    28d4:	01 80       	ldd	r0, Z+1	; 0x01
    28d6:	f2 81       	ldd	r31, Z+2	; 0x02
    28d8:	e0 2d       	mov	r30, r0
    28da:	82 81       	ldd	r24, Z+2	; 0x02
    28dc:	93 81       	ldd	r25, Z+3	; 0x03
    28de:	e9 81       	ldd	r30, Y+1	; 0x01
    28e0:	fa 81       	ldd	r31, Y+2	; 0x02
    28e2:	92 83       	std	Z+2, r25	; 0x02
    28e4:	81 83       	std	Z+1, r24	; 0x01
    28e6:	e9 81       	ldd	r30, Y+1	; 0x01
    28e8:	fa 81       	ldd	r31, Y+2	; 0x02
    28ea:	21 81       	ldd	r18, Z+1	; 0x01
    28ec:	32 81       	ldd	r19, Z+2	; 0x02
    28ee:	89 81       	ldd	r24, Y+1	; 0x01
    28f0:	9a 81       	ldd	r25, Y+2	; 0x02
    28f2:	03 96       	adiw	r24, 0x03	; 3
    28f4:	28 17       	cp	r18, r24
    28f6:	39 07       	cpc	r19, r25
    28f8:	59 f4       	brne	.+22     	; 0x2910 <vCoRoutineSchedule+0xb0>
    28fa:	e9 81       	ldd	r30, Y+1	; 0x01
    28fc:	fa 81       	ldd	r31, Y+2	; 0x02
    28fe:	01 80       	ldd	r0, Z+1	; 0x01
    2900:	f2 81       	ldd	r31, Z+2	; 0x02
    2902:	e0 2d       	mov	r30, r0
    2904:	82 81       	ldd	r24, Z+2	; 0x02
    2906:	93 81       	ldd	r25, Z+3	; 0x03
    2908:	e9 81       	ldd	r30, Y+1	; 0x01
    290a:	fa 81       	ldd	r31, Y+2	; 0x02
    290c:	92 83       	std	Z+2, r25	; 0x02
    290e:	81 83       	std	Z+1, r24	; 0x01
    2910:	e9 81       	ldd	r30, Y+1	; 0x01
    2912:	fa 81       	ldd	r31, Y+2	; 0x02
    2914:	01 80       	ldd	r0, Z+1	; 0x01
    2916:	f2 81       	ldd	r31, Z+2	; 0x02
    2918:	e0 2d       	mov	r30, r0
    291a:	86 81       	ldd	r24, Z+6	; 0x06
    291c:	97 81       	ldd	r25, Z+7	; 0x07
    291e:	90 93 a7 00 	sts	0x00A7, r25
    2922:	80 93 a6 00 	sts	0x00A6, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2926:	e0 91 a6 00 	lds	r30, 0x00A6
    292a:	f0 91 a7 00 	lds	r31, 0x00A7
    292e:	40 81       	ld	r20, Z
    2930:	51 81       	ldd	r21, Z+1	; 0x01
    2932:	80 91 a6 00 	lds	r24, 0x00A6
    2936:	90 91 a7 00 	lds	r25, 0x00A7
    293a:	e0 91 a6 00 	lds	r30, 0x00A6
    293e:	f0 91 a7 00 	lds	r31, 0x00A7
    2942:	27 89       	ldd	r18, Z+23	; 0x17
    2944:	62 2f       	mov	r22, r18
    2946:	fa 01       	movw	r30, r20
    2948:	09 95       	icall

	return;
}
    294a:	0f 90       	pop	r0
    294c:	0f 90       	pop	r0
    294e:	cf 91       	pop	r28
    2950:	df 91       	pop	r29
    2952:	08 95       	ret

00002954 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2954:	df 93       	push	r29
    2956:	cf 93       	push	r28
    2958:	0f 92       	push	r0
    295a:	cd b7       	in	r28, 0x3d	; 61
    295c:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    295e:	19 82       	std	Y+1, r1	; 0x01
    2960:	13 c0       	rjmp	.+38     	; 0x2988 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2962:	89 81       	ldd	r24, Y+1	; 0x01
    2964:	28 2f       	mov	r18, r24
    2966:	30 e0       	ldi	r19, 0x00	; 0
    2968:	c9 01       	movw	r24, r18
    296a:	88 0f       	add	r24, r24
    296c:	99 1f       	adc	r25, r25
    296e:	88 0f       	add	r24, r24
    2970:	99 1f       	adc	r25, r25
    2972:	88 0f       	add	r24, r24
    2974:	99 1f       	adc	r25, r25
    2976:	82 0f       	add	r24, r18
    2978:	93 1f       	adc	r25, r19
    297a:	81 55       	subi	r24, 0x51	; 81
    297c:	9f 4f       	sbci	r25, 0xFF	; 255
    297e:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2982:	89 81       	ldd	r24, Y+1	; 0x01
    2984:	8f 5f       	subi	r24, 0xFF	; 255
    2986:	89 83       	std	Y+1, r24	; 0x01
    2988:	89 81       	ldd	r24, Y+1	; 0x01
    298a:	82 30       	cpi	r24, 0x02	; 2
    298c:	50 f3       	brcs	.-44     	; 0x2962 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    298e:	81 ec       	ldi	r24, 0xC1	; 193
    2990:	90 e0       	ldi	r25, 0x00	; 0
    2992:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2996:	8a ec       	ldi	r24, 0xCA	; 202
    2998:	90 e0       	ldi	r25, 0x00	; 0
    299a:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    299e:	87 ed       	ldi	r24, 0xD7	; 215
    29a0:	90 e0       	ldi	r25, 0x00	; 0
    29a2:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    29a6:	81 ec       	ldi	r24, 0xC1	; 193
    29a8:	90 e0       	ldi	r25, 0x00	; 0
    29aa:	90 93 d4 00 	sts	0x00D4, r25
    29ae:	80 93 d3 00 	sts	0x00D3, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    29b2:	8a ec       	ldi	r24, 0xCA	; 202
    29b4:	90 e0       	ldi	r25, 0x00	; 0
    29b6:	90 93 d6 00 	sts	0x00D6, r25
    29ba:	80 93 d5 00 	sts	0x00D5, r24
}
    29be:	0f 90       	pop	r0
    29c0:	cf 91       	pop	r28
    29c2:	df 91       	pop	r29
    29c4:	08 95       	ret

000029c6 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    29c6:	df 93       	push	r29
    29c8:	cf 93       	push	r28
    29ca:	00 d0       	rcall	.+0      	; 0x29cc <xCoRoutineRemoveFromEventList+0x6>
    29cc:	00 d0       	rcall	.+0      	; 0x29ce <xCoRoutineRemoveFromEventList+0x8>
    29ce:	0f 92       	push	r0
    29d0:	cd b7       	in	r28, 0x3d	; 61
    29d2:	de b7       	in	r29, 0x3e	; 62
    29d4:	9d 83       	std	Y+5, r25	; 0x05
    29d6:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    29d8:	ec 81       	ldd	r30, Y+4	; 0x04
    29da:	fd 81       	ldd	r31, Y+5	; 0x05
    29dc:	05 80       	ldd	r0, Z+5	; 0x05
    29de:	f6 81       	ldd	r31, Z+6	; 0x06
    29e0:	e0 2d       	mov	r30, r0
    29e2:	86 81       	ldd	r24, Z+6	; 0x06
    29e4:	97 81       	ldd	r25, Z+7	; 0x07
    29e6:	9b 83       	std	Y+3, r25	; 0x03
    29e8:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    29ea:	8a 81       	ldd	r24, Y+2	; 0x02
    29ec:	9b 81       	ldd	r25, Y+3	; 0x03
    29ee:	0c 96       	adiw	r24, 0x0c	; 12
    29f0:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    29f4:	8a 81       	ldd	r24, Y+2	; 0x02
    29f6:	9b 81       	ldd	r25, Y+3	; 0x03
    29f8:	9c 01       	movw	r18, r24
    29fa:	24 5f       	subi	r18, 0xF4	; 244
    29fc:	3f 4f       	sbci	r19, 0xFF	; 255
    29fe:	87 ed       	ldi	r24, 0xD7	; 215
    2a00:	90 e0       	ldi	r25, 0x00	; 0
    2a02:	b9 01       	movw	r22, r18
    2a04:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2a08:	ea 81       	ldd	r30, Y+2	; 0x02
    2a0a:	fb 81       	ldd	r31, Y+3	; 0x03
    2a0c:	96 89       	ldd	r25, Z+22	; 0x16
    2a0e:	e0 91 a6 00 	lds	r30, 0x00A6
    2a12:	f0 91 a7 00 	lds	r31, 0x00A7
    2a16:	86 89       	ldd	r24, Z+22	; 0x16
    2a18:	98 17       	cp	r25, r24
    2a1a:	18 f0       	brcs	.+6      	; 0x2a22 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2a1c:	81 e0       	ldi	r24, 0x01	; 1
    2a1e:	89 83       	std	Y+1, r24	; 0x01
    2a20:	01 c0       	rjmp	.+2      	; 0x2a24 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    2a22:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2a24:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a26:	0f 90       	pop	r0
    2a28:	0f 90       	pop	r0
    2a2a:	0f 90       	pop	r0
    2a2c:	0f 90       	pop	r0
    2a2e:	0f 90       	pop	r0
    2a30:	cf 91       	pop	r28
    2a32:	df 91       	pop	r29
    2a34:	08 95       	ret

00002a36 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2a36:	df 93       	push	r29
    2a38:	cf 93       	push	r28
    2a3a:	00 d0       	rcall	.+0      	; 0x2a3c <pvPortMalloc+0x6>
    2a3c:	00 d0       	rcall	.+0      	; 0x2a3e <pvPortMalloc+0x8>
    2a3e:	cd b7       	in	r28, 0x3d	; 61
    2a40:	de b7       	in	r29, 0x3e	; 62
    2a42:	9c 83       	std	Y+4, r25	; 0x04
    2a44:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    2a46:	1a 82       	std	Y+2, r1	; 0x02
    2a48:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2a4a:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2a4e:	80 91 e0 00 	lds	r24, 0x00E0
    2a52:	90 91 e1 00 	lds	r25, 0x00E1
    2a56:	2b 81       	ldd	r18, Y+3	; 0x03
    2a58:	3c 81       	ldd	r19, Y+4	; 0x04
    2a5a:	82 0f       	add	r24, r18
    2a5c:	93 1f       	adc	r25, r19
    2a5e:	24 e0       	ldi	r18, 0x04	; 4
    2a60:	80 3b       	cpi	r24, 0xB0	; 176
    2a62:	92 07       	cpc	r25, r18
    2a64:	18 f5       	brcc	.+70     	; 0x2aac <pvPortMalloc+0x76>
    2a66:	20 91 e0 00 	lds	r18, 0x00E0
    2a6a:	30 91 e1 00 	lds	r19, 0x00E1
    2a6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a70:	9c 81       	ldd	r25, Y+4	; 0x04
    2a72:	28 0f       	add	r18, r24
    2a74:	39 1f       	adc	r19, r25
    2a76:	80 91 e0 00 	lds	r24, 0x00E0
    2a7a:	90 91 e1 00 	lds	r25, 0x00E1
    2a7e:	82 17       	cp	r24, r18
    2a80:	93 07       	cpc	r25, r19
    2a82:	a0 f4       	brcc	.+40     	; 0x2aac <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2a84:	80 91 e0 00 	lds	r24, 0x00E0
    2a88:	90 91 e1 00 	lds	r25, 0x00E1
    2a8c:	8e 51       	subi	r24, 0x1E	; 30
    2a8e:	9f 4f       	sbci	r25, 0xFF	; 255
    2a90:	9a 83       	std	Y+2, r25	; 0x02
    2a92:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    2a94:	20 91 e0 00 	lds	r18, 0x00E0
    2a98:	30 91 e1 00 	lds	r19, 0x00E1
    2a9c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a9e:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa0:	82 0f       	add	r24, r18
    2aa2:	93 1f       	adc	r25, r19
    2aa4:	90 93 e1 00 	sts	0x00E1, r25
    2aa8:	80 93 e0 00 	sts	0x00E0, r24
		}	
	}
	xTaskResumeAll();
    2aac:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    2ab0:	89 81       	ldd	r24, Y+1	; 0x01
    2ab2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2ab4:	0f 90       	pop	r0
    2ab6:	0f 90       	pop	r0
    2ab8:	0f 90       	pop	r0
    2aba:	0f 90       	pop	r0
    2abc:	cf 91       	pop	r28
    2abe:	df 91       	pop	r29
    2ac0:	08 95       	ret

00002ac2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2ac2:	df 93       	push	r29
    2ac4:	cf 93       	push	r28
    2ac6:	00 d0       	rcall	.+0      	; 0x2ac8 <vPortFree+0x6>
    2ac8:	cd b7       	in	r28, 0x3d	; 61
    2aca:	de b7       	in	r29, 0x3e	; 62
    2acc:	9a 83       	std	Y+2, r25	; 0x02
    2ace:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    2ad0:	0f 90       	pop	r0
    2ad2:	0f 90       	pop	r0
    2ad4:	cf 91       	pop	r28
    2ad6:	df 91       	pop	r29
    2ad8:	08 95       	ret

00002ada <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2ada:	df 93       	push	r29
    2adc:	cf 93       	push	r28
    2ade:	cd b7       	in	r28, 0x3d	; 61
    2ae0:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2ae2:	10 92 e1 00 	sts	0x00E1, r1
    2ae6:	10 92 e0 00 	sts	0x00E0, r1
}
    2aea:	cf 91       	pop	r28
    2aec:	df 91       	pop	r29
    2aee:	08 95       	ret

00002af0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2af0:	df 93       	push	r29
    2af2:	cf 93       	push	r28
    2af4:	cd b7       	in	r28, 0x3d	; 61
    2af6:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2af8:	20 91 e0 00 	lds	r18, 0x00E0
    2afc:	30 91 e1 00 	lds	r19, 0x00E1
    2b00:	80 eb       	ldi	r24, 0xB0	; 176
    2b02:	94 e0       	ldi	r25, 0x04	; 4
    2b04:	82 1b       	sub	r24, r18
    2b06:	93 0b       	sbc	r25, r19
}
    2b08:	cf 91       	pop	r28
    2b0a:	df 91       	pop	r29
    2b0c:	08 95       	ret

00002b0e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2b0e:	df 93       	push	r29
    2b10:	cf 93       	push	r28
    2b12:	00 d0       	rcall	.+0      	; 0x2b14 <vListInitialise+0x6>
    2b14:	cd b7       	in	r28, 0x3d	; 61
    2b16:	de b7       	in	r29, 0x3e	; 62
    2b18:	9a 83       	std	Y+2, r25	; 0x02
    2b1a:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2b1c:	89 81       	ldd	r24, Y+1	; 0x01
    2b1e:	9a 81       	ldd	r25, Y+2	; 0x02
    2b20:	03 96       	adiw	r24, 0x03	; 3
    2b22:	e9 81       	ldd	r30, Y+1	; 0x01
    2b24:	fa 81       	ldd	r31, Y+2	; 0x02
    2b26:	92 83       	std	Z+2, r25	; 0x02
    2b28:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2b2a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b2c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b2e:	8f ef       	ldi	r24, 0xFF	; 255
    2b30:	9f ef       	ldi	r25, 0xFF	; 255
    2b32:	94 83       	std	Z+4, r25	; 0x04
    2b34:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2b36:	89 81       	ldd	r24, Y+1	; 0x01
    2b38:	9a 81       	ldd	r25, Y+2	; 0x02
    2b3a:	03 96       	adiw	r24, 0x03	; 3
    2b3c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b3e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b40:	96 83       	std	Z+6, r25	; 0x06
    2b42:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2b44:	89 81       	ldd	r24, Y+1	; 0x01
    2b46:	9a 81       	ldd	r25, Y+2	; 0x02
    2b48:	03 96       	adiw	r24, 0x03	; 3
    2b4a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b4c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b4e:	90 87       	std	Z+8, r25	; 0x08
    2b50:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2b52:	e9 81       	ldd	r30, Y+1	; 0x01
    2b54:	fa 81       	ldd	r31, Y+2	; 0x02
    2b56:	10 82       	st	Z, r1
}
    2b58:	0f 90       	pop	r0
    2b5a:	0f 90       	pop	r0
    2b5c:	cf 91       	pop	r28
    2b5e:	df 91       	pop	r29
    2b60:	08 95       	ret

00002b62 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    2b62:	df 93       	push	r29
    2b64:	cf 93       	push	r28
    2b66:	00 d0       	rcall	.+0      	; 0x2b68 <vListInitialiseItem+0x6>
    2b68:	cd b7       	in	r28, 0x3d	; 61
    2b6a:	de b7       	in	r29, 0x3e	; 62
    2b6c:	9a 83       	std	Y+2, r25	; 0x02
    2b6e:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2b70:	e9 81       	ldd	r30, Y+1	; 0x01
    2b72:	fa 81       	ldd	r31, Y+2	; 0x02
    2b74:	11 86       	std	Z+9, r1	; 0x09
    2b76:	10 86       	std	Z+8, r1	; 0x08
}
    2b78:	0f 90       	pop	r0
    2b7a:	0f 90       	pop	r0
    2b7c:	cf 91       	pop	r28
    2b7e:	df 91       	pop	r29
    2b80:	08 95       	ret

00002b82 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2b82:	df 93       	push	r29
    2b84:	cf 93       	push	r28
    2b86:	00 d0       	rcall	.+0      	; 0x2b88 <vListInsertEnd+0x6>
    2b88:	00 d0       	rcall	.+0      	; 0x2b8a <vListInsertEnd+0x8>
    2b8a:	00 d0       	rcall	.+0      	; 0x2b8c <vListInsertEnd+0xa>
    2b8c:	cd b7       	in	r28, 0x3d	; 61
    2b8e:	de b7       	in	r29, 0x3e	; 62
    2b90:	9c 83       	std	Y+4, r25	; 0x04
    2b92:	8b 83       	std	Y+3, r24	; 0x03
    2b94:	7e 83       	std	Y+6, r23	; 0x06
    2b96:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2b98:	eb 81       	ldd	r30, Y+3	; 0x03
    2b9a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b9c:	81 81       	ldd	r24, Z+1	; 0x01
    2b9e:	92 81       	ldd	r25, Z+2	; 0x02
    2ba0:	9a 83       	std	Y+2, r25	; 0x02
    2ba2:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    2ba4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ba6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ba8:	82 81       	ldd	r24, Z+2	; 0x02
    2baa:	93 81       	ldd	r25, Z+3	; 0x03
    2bac:	ed 81       	ldd	r30, Y+5	; 0x05
    2bae:	fe 81       	ldd	r31, Y+6	; 0x06
    2bb0:	93 83       	std	Z+3, r25	; 0x03
    2bb2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2bb4:	eb 81       	ldd	r30, Y+3	; 0x03
    2bb6:	fc 81       	ldd	r31, Y+4	; 0x04
    2bb8:	81 81       	ldd	r24, Z+1	; 0x01
    2bba:	92 81       	ldd	r25, Z+2	; 0x02
    2bbc:	ed 81       	ldd	r30, Y+5	; 0x05
    2bbe:	fe 81       	ldd	r31, Y+6	; 0x06
    2bc0:	95 83       	std	Z+5, r25	; 0x05
    2bc2:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2bc4:	e9 81       	ldd	r30, Y+1	; 0x01
    2bc6:	fa 81       	ldd	r31, Y+2	; 0x02
    2bc8:	02 80       	ldd	r0, Z+2	; 0x02
    2bca:	f3 81       	ldd	r31, Z+3	; 0x03
    2bcc:	e0 2d       	mov	r30, r0
    2bce:	8d 81       	ldd	r24, Y+5	; 0x05
    2bd0:	9e 81       	ldd	r25, Y+6	; 0x06
    2bd2:	95 83       	std	Z+5, r25	; 0x05
    2bd4:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2bd6:	8d 81       	ldd	r24, Y+5	; 0x05
    2bd8:	9e 81       	ldd	r25, Y+6	; 0x06
    2bda:	e9 81       	ldd	r30, Y+1	; 0x01
    2bdc:	fa 81       	ldd	r31, Y+2	; 0x02
    2bde:	93 83       	std	Z+3, r25	; 0x03
    2be0:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2be2:	8d 81       	ldd	r24, Y+5	; 0x05
    2be4:	9e 81       	ldd	r25, Y+6	; 0x06
    2be6:	eb 81       	ldd	r30, Y+3	; 0x03
    2be8:	fc 81       	ldd	r31, Y+4	; 0x04
    2bea:	92 83       	std	Z+2, r25	; 0x02
    2bec:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2bee:	ed 81       	ldd	r30, Y+5	; 0x05
    2bf0:	fe 81       	ldd	r31, Y+6	; 0x06
    2bf2:	8b 81       	ldd	r24, Y+3	; 0x03
    2bf4:	9c 81       	ldd	r25, Y+4	; 0x04
    2bf6:	91 87       	std	Z+9, r25	; 0x09
    2bf8:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2bfa:	eb 81       	ldd	r30, Y+3	; 0x03
    2bfc:	fc 81       	ldd	r31, Y+4	; 0x04
    2bfe:	80 81       	ld	r24, Z
    2c00:	8f 5f       	subi	r24, 0xFF	; 255
    2c02:	eb 81       	ldd	r30, Y+3	; 0x03
    2c04:	fc 81       	ldd	r31, Y+4	; 0x04
    2c06:	80 83       	st	Z, r24
}
    2c08:	26 96       	adiw	r28, 0x06	; 6
    2c0a:	0f b6       	in	r0, 0x3f	; 63
    2c0c:	f8 94       	cli
    2c0e:	de bf       	out	0x3e, r29	; 62
    2c10:	0f be       	out	0x3f, r0	; 63
    2c12:	cd bf       	out	0x3d, r28	; 61
    2c14:	cf 91       	pop	r28
    2c16:	df 91       	pop	r29
    2c18:	08 95       	ret

00002c1a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2c1a:	df 93       	push	r29
    2c1c:	cf 93       	push	r28
    2c1e:	cd b7       	in	r28, 0x3d	; 61
    2c20:	de b7       	in	r29, 0x3e	; 62
    2c22:	28 97       	sbiw	r28, 0x08	; 8
    2c24:	0f b6       	in	r0, 0x3f	; 63
    2c26:	f8 94       	cli
    2c28:	de bf       	out	0x3e, r29	; 62
    2c2a:	0f be       	out	0x3f, r0	; 63
    2c2c:	cd bf       	out	0x3d, r28	; 61
    2c2e:	9e 83       	std	Y+6, r25	; 0x06
    2c30:	8d 83       	std	Y+5, r24	; 0x05
    2c32:	78 87       	std	Y+8, r23	; 0x08
    2c34:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2c36:	ef 81       	ldd	r30, Y+7	; 0x07
    2c38:	f8 85       	ldd	r31, Y+8	; 0x08
    2c3a:	80 81       	ld	r24, Z
    2c3c:	91 81       	ldd	r25, Z+1	; 0x01
    2c3e:	9a 83       	std	Y+2, r25	; 0x02
    2c40:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2c42:	89 81       	ldd	r24, Y+1	; 0x01
    2c44:	9a 81       	ldd	r25, Y+2	; 0x02
    2c46:	2f ef       	ldi	r18, 0xFF	; 255
    2c48:	8f 3f       	cpi	r24, 0xFF	; 255
    2c4a:	92 07       	cpc	r25, r18
    2c4c:	39 f4       	brne	.+14     	; 0x2c5c <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2c4e:	ed 81       	ldd	r30, Y+5	; 0x05
    2c50:	fe 81       	ldd	r31, Y+6	; 0x06
    2c52:	87 81       	ldd	r24, Z+7	; 0x07
    2c54:	90 85       	ldd	r25, Z+8	; 0x08
    2c56:	9c 83       	std	Y+4, r25	; 0x04
    2c58:	8b 83       	std	Y+3, r24	; 0x03
    2c5a:	18 c0       	rjmp	.+48     	; 0x2c8c <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2c5c:	8d 81       	ldd	r24, Y+5	; 0x05
    2c5e:	9e 81       	ldd	r25, Y+6	; 0x06
    2c60:	03 96       	adiw	r24, 0x03	; 3
    2c62:	9c 83       	std	Y+4, r25	; 0x04
    2c64:	8b 83       	std	Y+3, r24	; 0x03
    2c66:	06 c0       	rjmp	.+12     	; 0x2c74 <vListInsert+0x5a>
    2c68:	eb 81       	ldd	r30, Y+3	; 0x03
    2c6a:	fc 81       	ldd	r31, Y+4	; 0x04
    2c6c:	82 81       	ldd	r24, Z+2	; 0x02
    2c6e:	93 81       	ldd	r25, Z+3	; 0x03
    2c70:	9c 83       	std	Y+4, r25	; 0x04
    2c72:	8b 83       	std	Y+3, r24	; 0x03
    2c74:	eb 81       	ldd	r30, Y+3	; 0x03
    2c76:	fc 81       	ldd	r31, Y+4	; 0x04
    2c78:	02 80       	ldd	r0, Z+2	; 0x02
    2c7a:	f3 81       	ldd	r31, Z+3	; 0x03
    2c7c:	e0 2d       	mov	r30, r0
    2c7e:	20 81       	ld	r18, Z
    2c80:	31 81       	ldd	r19, Z+1	; 0x01
    2c82:	89 81       	ldd	r24, Y+1	; 0x01
    2c84:	9a 81       	ldd	r25, Y+2	; 0x02
    2c86:	82 17       	cp	r24, r18
    2c88:	93 07       	cpc	r25, r19
    2c8a:	70 f7       	brcc	.-36     	; 0x2c68 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2c8c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c8e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c90:	82 81       	ldd	r24, Z+2	; 0x02
    2c92:	93 81       	ldd	r25, Z+3	; 0x03
    2c94:	ef 81       	ldd	r30, Y+7	; 0x07
    2c96:	f8 85       	ldd	r31, Y+8	; 0x08
    2c98:	93 83       	std	Z+3, r25	; 0x03
    2c9a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2c9c:	ef 81       	ldd	r30, Y+7	; 0x07
    2c9e:	f8 85       	ldd	r31, Y+8	; 0x08
    2ca0:	02 80       	ldd	r0, Z+2	; 0x02
    2ca2:	f3 81       	ldd	r31, Z+3	; 0x03
    2ca4:	e0 2d       	mov	r30, r0
    2ca6:	8f 81       	ldd	r24, Y+7	; 0x07
    2ca8:	98 85       	ldd	r25, Y+8	; 0x08
    2caa:	95 83       	std	Z+5, r25	; 0x05
    2cac:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2cae:	ef 81       	ldd	r30, Y+7	; 0x07
    2cb0:	f8 85       	ldd	r31, Y+8	; 0x08
    2cb2:	8b 81       	ldd	r24, Y+3	; 0x03
    2cb4:	9c 81       	ldd	r25, Y+4	; 0x04
    2cb6:	95 83       	std	Z+5, r25	; 0x05
    2cb8:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2cba:	8f 81       	ldd	r24, Y+7	; 0x07
    2cbc:	98 85       	ldd	r25, Y+8	; 0x08
    2cbe:	eb 81       	ldd	r30, Y+3	; 0x03
    2cc0:	fc 81       	ldd	r31, Y+4	; 0x04
    2cc2:	93 83       	std	Z+3, r25	; 0x03
    2cc4:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2cc6:	ef 81       	ldd	r30, Y+7	; 0x07
    2cc8:	f8 85       	ldd	r31, Y+8	; 0x08
    2cca:	8d 81       	ldd	r24, Y+5	; 0x05
    2ccc:	9e 81       	ldd	r25, Y+6	; 0x06
    2cce:	91 87       	std	Z+9, r25	; 0x09
    2cd0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2cd2:	ed 81       	ldd	r30, Y+5	; 0x05
    2cd4:	fe 81       	ldd	r31, Y+6	; 0x06
    2cd6:	80 81       	ld	r24, Z
    2cd8:	8f 5f       	subi	r24, 0xFF	; 255
    2cda:	ed 81       	ldd	r30, Y+5	; 0x05
    2cdc:	fe 81       	ldd	r31, Y+6	; 0x06
    2cde:	80 83       	st	Z, r24
}
    2ce0:	28 96       	adiw	r28, 0x08	; 8
    2ce2:	0f b6       	in	r0, 0x3f	; 63
    2ce4:	f8 94       	cli
    2ce6:	de bf       	out	0x3e, r29	; 62
    2ce8:	0f be       	out	0x3f, r0	; 63
    2cea:	cd bf       	out	0x3d, r28	; 61
    2cec:	cf 91       	pop	r28
    2cee:	df 91       	pop	r29
    2cf0:	08 95       	ret

00002cf2 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2cf2:	df 93       	push	r29
    2cf4:	cf 93       	push	r28
    2cf6:	00 d0       	rcall	.+0      	; 0x2cf8 <vListRemove+0x6>
    2cf8:	00 d0       	rcall	.+0      	; 0x2cfa <vListRemove+0x8>
    2cfa:	cd b7       	in	r28, 0x3d	; 61
    2cfc:	de b7       	in	r29, 0x3e	; 62
    2cfe:	9c 83       	std	Y+4, r25	; 0x04
    2d00:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2d02:	eb 81       	ldd	r30, Y+3	; 0x03
    2d04:	fc 81       	ldd	r31, Y+4	; 0x04
    2d06:	a2 81       	ldd	r26, Z+2	; 0x02
    2d08:	b3 81       	ldd	r27, Z+3	; 0x03
    2d0a:	eb 81       	ldd	r30, Y+3	; 0x03
    2d0c:	fc 81       	ldd	r31, Y+4	; 0x04
    2d0e:	84 81       	ldd	r24, Z+4	; 0x04
    2d10:	95 81       	ldd	r25, Z+5	; 0x05
    2d12:	15 96       	adiw	r26, 0x05	; 5
    2d14:	9c 93       	st	X, r25
    2d16:	8e 93       	st	-X, r24
    2d18:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2d1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2d1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2d1e:	a4 81       	ldd	r26, Z+4	; 0x04
    2d20:	b5 81       	ldd	r27, Z+5	; 0x05
    2d22:	eb 81       	ldd	r30, Y+3	; 0x03
    2d24:	fc 81       	ldd	r31, Y+4	; 0x04
    2d26:	82 81       	ldd	r24, Z+2	; 0x02
    2d28:	93 81       	ldd	r25, Z+3	; 0x03
    2d2a:	13 96       	adiw	r26, 0x03	; 3
    2d2c:	9c 93       	st	X, r25
    2d2e:	8e 93       	st	-X, r24
    2d30:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    2d32:	eb 81       	ldd	r30, Y+3	; 0x03
    2d34:	fc 81       	ldd	r31, Y+4	; 0x04
    2d36:	80 85       	ldd	r24, Z+8	; 0x08
    2d38:	91 85       	ldd	r25, Z+9	; 0x09
    2d3a:	9a 83       	std	Y+2, r25	; 0x02
    2d3c:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2d3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d40:	fa 81       	ldd	r31, Y+2	; 0x02
    2d42:	21 81       	ldd	r18, Z+1	; 0x01
    2d44:	32 81       	ldd	r19, Z+2	; 0x02
    2d46:	8b 81       	ldd	r24, Y+3	; 0x03
    2d48:	9c 81       	ldd	r25, Y+4	; 0x04
    2d4a:	28 17       	cp	r18, r24
    2d4c:	39 07       	cpc	r19, r25
    2d4e:	41 f4       	brne	.+16     	; 0x2d60 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2d50:	eb 81       	ldd	r30, Y+3	; 0x03
    2d52:	fc 81       	ldd	r31, Y+4	; 0x04
    2d54:	84 81       	ldd	r24, Z+4	; 0x04
    2d56:	95 81       	ldd	r25, Z+5	; 0x05
    2d58:	e9 81       	ldd	r30, Y+1	; 0x01
    2d5a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d5c:	92 83       	std	Z+2, r25	; 0x02
    2d5e:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    2d60:	eb 81       	ldd	r30, Y+3	; 0x03
    2d62:	fc 81       	ldd	r31, Y+4	; 0x04
    2d64:	11 86       	std	Z+9, r1	; 0x09
    2d66:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2d68:	e9 81       	ldd	r30, Y+1	; 0x01
    2d6a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d6c:	80 81       	ld	r24, Z
    2d6e:	81 50       	subi	r24, 0x01	; 1
    2d70:	e9 81       	ldd	r30, Y+1	; 0x01
    2d72:	fa 81       	ldd	r31, Y+2	; 0x02
    2d74:	80 83       	st	Z, r24
}
    2d76:	0f 90       	pop	r0
    2d78:	0f 90       	pop	r0
    2d7a:	0f 90       	pop	r0
    2d7c:	0f 90       	pop	r0
    2d7e:	cf 91       	pop	r28
    2d80:	df 91       	pop	r29
    2d82:	08 95       	ret

00002d84 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    2d84:	df 93       	push	r29
    2d86:	cf 93       	push	r28
    2d88:	cd b7       	in	r28, 0x3d	; 61
    2d8a:	de b7       	in	r29, 0x3e	; 62
    2d8c:	28 97       	sbiw	r28, 0x08	; 8
    2d8e:	0f b6       	in	r0, 0x3f	; 63
    2d90:	f8 94       	cli
    2d92:	de bf       	out	0x3e, r29	; 62
    2d94:	0f be       	out	0x3f, r0	; 63
    2d96:	cd bf       	out	0x3d, r28	; 61
    2d98:	9c 83       	std	Y+4, r25	; 0x04
    2d9a:	8b 83       	std	Y+3, r24	; 0x03
    2d9c:	7e 83       	std	Y+6, r23	; 0x06
    2d9e:	6d 83       	std	Y+5, r22	; 0x05
    2da0:	58 87       	std	Y+8, r21	; 0x08
    2da2:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2da4:	eb 81       	ldd	r30, Y+3	; 0x03
    2da6:	fc 81       	ldd	r31, Y+4	; 0x04
    2da8:	81 e1       	ldi	r24, 0x11	; 17
    2daa:	80 83       	st	Z, r24
	pxTopOfStack--;
    2dac:	8b 81       	ldd	r24, Y+3	; 0x03
    2dae:	9c 81       	ldd	r25, Y+4	; 0x04
    2db0:	01 97       	sbiw	r24, 0x01	; 1
    2db2:	9c 83       	std	Y+4, r25	; 0x04
    2db4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    2db6:	eb 81       	ldd	r30, Y+3	; 0x03
    2db8:	fc 81       	ldd	r31, Y+4	; 0x04
    2dba:	82 e2       	ldi	r24, 0x22	; 34
    2dbc:	80 83       	st	Z, r24
	pxTopOfStack--;
    2dbe:	8b 81       	ldd	r24, Y+3	; 0x03
    2dc0:	9c 81       	ldd	r25, Y+4	; 0x04
    2dc2:	01 97       	sbiw	r24, 0x01	; 1
    2dc4:	9c 83       	std	Y+4, r25	; 0x04
    2dc6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2dc8:	eb 81       	ldd	r30, Y+3	; 0x03
    2dca:	fc 81       	ldd	r31, Y+4	; 0x04
    2dcc:	83 e3       	ldi	r24, 0x33	; 51
    2dce:	80 83       	st	Z, r24
	pxTopOfStack--;
    2dd0:	8b 81       	ldd	r24, Y+3	; 0x03
    2dd2:	9c 81       	ldd	r25, Y+4	; 0x04
    2dd4:	01 97       	sbiw	r24, 0x01	; 1
    2dd6:	9c 83       	std	Y+4, r25	; 0x04
    2dd8:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    2dda:	8d 81       	ldd	r24, Y+5	; 0x05
    2ddc:	9e 81       	ldd	r25, Y+6	; 0x06
    2dde:	9a 83       	std	Y+2, r25	; 0x02
    2de0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2de2:	89 81       	ldd	r24, Y+1	; 0x01
    2de4:	eb 81       	ldd	r30, Y+3	; 0x03
    2de6:	fc 81       	ldd	r31, Y+4	; 0x04
    2de8:	80 83       	st	Z, r24
	pxTopOfStack--;
    2dea:	8b 81       	ldd	r24, Y+3	; 0x03
    2dec:	9c 81       	ldd	r25, Y+4	; 0x04
    2dee:	01 97       	sbiw	r24, 0x01	; 1
    2df0:	9c 83       	std	Y+4, r25	; 0x04
    2df2:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2df4:	89 81       	ldd	r24, Y+1	; 0x01
    2df6:	9a 81       	ldd	r25, Y+2	; 0x02
    2df8:	89 2f       	mov	r24, r25
    2dfa:	99 27       	eor	r25, r25
    2dfc:	9a 83       	std	Y+2, r25	; 0x02
    2dfe:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2e00:	89 81       	ldd	r24, Y+1	; 0x01
    2e02:	eb 81       	ldd	r30, Y+3	; 0x03
    2e04:	fc 81       	ldd	r31, Y+4	; 0x04
    2e06:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e08:	8b 81       	ldd	r24, Y+3	; 0x03
    2e0a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e0c:	01 97       	sbiw	r24, 0x01	; 1
    2e0e:	9c 83       	std	Y+4, r25	; 0x04
    2e10:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    2e12:	eb 81       	ldd	r30, Y+3	; 0x03
    2e14:	fc 81       	ldd	r31, Y+4	; 0x04
    2e16:	10 82       	st	Z, r1
	pxTopOfStack--;
    2e18:	8b 81       	ldd	r24, Y+3	; 0x03
    2e1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e1c:	01 97       	sbiw	r24, 0x01	; 1
    2e1e:	9c 83       	std	Y+4, r25	; 0x04
    2e20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    2e22:	eb 81       	ldd	r30, Y+3	; 0x03
    2e24:	fc 81       	ldd	r31, Y+4	; 0x04
    2e26:	80 e8       	ldi	r24, 0x80	; 128
    2e28:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e2e:	01 97       	sbiw	r24, 0x01	; 1
    2e30:	9c 83       	std	Y+4, r25	; 0x04
    2e32:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    2e34:	eb 81       	ldd	r30, Y+3	; 0x03
    2e36:	fc 81       	ldd	r31, Y+4	; 0x04
    2e38:	10 82       	st	Z, r1
	pxTopOfStack--;
    2e3a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e3c:	9c 81       	ldd	r25, Y+4	; 0x04
    2e3e:	01 97       	sbiw	r24, 0x01	; 1
    2e40:	9c 83       	std	Y+4, r25	; 0x04
    2e42:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    2e44:	eb 81       	ldd	r30, Y+3	; 0x03
    2e46:	fc 81       	ldd	r31, Y+4	; 0x04
    2e48:	82 e0       	ldi	r24, 0x02	; 2
    2e4a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e4c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e4e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e50:	01 97       	sbiw	r24, 0x01	; 1
    2e52:	9c 83       	std	Y+4, r25	; 0x04
    2e54:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    2e56:	eb 81       	ldd	r30, Y+3	; 0x03
    2e58:	fc 81       	ldd	r31, Y+4	; 0x04
    2e5a:	83 e0       	ldi	r24, 0x03	; 3
    2e5c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e5e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e60:	9c 81       	ldd	r25, Y+4	; 0x04
    2e62:	01 97       	sbiw	r24, 0x01	; 1
    2e64:	9c 83       	std	Y+4, r25	; 0x04
    2e66:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2e68:	eb 81       	ldd	r30, Y+3	; 0x03
    2e6a:	fc 81       	ldd	r31, Y+4	; 0x04
    2e6c:	84 e0       	ldi	r24, 0x04	; 4
    2e6e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e70:	8b 81       	ldd	r24, Y+3	; 0x03
    2e72:	9c 81       	ldd	r25, Y+4	; 0x04
    2e74:	01 97       	sbiw	r24, 0x01	; 1
    2e76:	9c 83       	std	Y+4, r25	; 0x04
    2e78:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2e7a:	eb 81       	ldd	r30, Y+3	; 0x03
    2e7c:	fc 81       	ldd	r31, Y+4	; 0x04
    2e7e:	85 e0       	ldi	r24, 0x05	; 5
    2e80:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e82:	8b 81       	ldd	r24, Y+3	; 0x03
    2e84:	9c 81       	ldd	r25, Y+4	; 0x04
    2e86:	01 97       	sbiw	r24, 0x01	; 1
    2e88:	9c 83       	std	Y+4, r25	; 0x04
    2e8a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2e8c:	eb 81       	ldd	r30, Y+3	; 0x03
    2e8e:	fc 81       	ldd	r31, Y+4	; 0x04
    2e90:	86 e0       	ldi	r24, 0x06	; 6
    2e92:	80 83       	st	Z, r24
	pxTopOfStack--;
    2e94:	8b 81       	ldd	r24, Y+3	; 0x03
    2e96:	9c 81       	ldd	r25, Y+4	; 0x04
    2e98:	01 97       	sbiw	r24, 0x01	; 1
    2e9a:	9c 83       	std	Y+4, r25	; 0x04
    2e9c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2e9e:	eb 81       	ldd	r30, Y+3	; 0x03
    2ea0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ea2:	87 e0       	ldi	r24, 0x07	; 7
    2ea4:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ea6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea8:	9c 81       	ldd	r25, Y+4	; 0x04
    2eaa:	01 97       	sbiw	r24, 0x01	; 1
    2eac:	9c 83       	std	Y+4, r25	; 0x04
    2eae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2eb0:	eb 81       	ldd	r30, Y+3	; 0x03
    2eb2:	fc 81       	ldd	r31, Y+4	; 0x04
    2eb4:	88 e0       	ldi	r24, 0x08	; 8
    2eb6:	80 83       	st	Z, r24
	pxTopOfStack--;
    2eb8:	8b 81       	ldd	r24, Y+3	; 0x03
    2eba:	9c 81       	ldd	r25, Y+4	; 0x04
    2ebc:	01 97       	sbiw	r24, 0x01	; 1
    2ebe:	9c 83       	std	Y+4, r25	; 0x04
    2ec0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2ec2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ec4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ec6:	89 e0       	ldi	r24, 0x09	; 9
    2ec8:	80 83       	st	Z, r24
	pxTopOfStack--;
    2eca:	8b 81       	ldd	r24, Y+3	; 0x03
    2ecc:	9c 81       	ldd	r25, Y+4	; 0x04
    2ece:	01 97       	sbiw	r24, 0x01	; 1
    2ed0:	9c 83       	std	Y+4, r25	; 0x04
    2ed2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    2ed4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ed6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ed8:	80 e1       	ldi	r24, 0x10	; 16
    2eda:	80 83       	st	Z, r24
	pxTopOfStack--;
    2edc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ede:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee0:	01 97       	sbiw	r24, 0x01	; 1
    2ee2:	9c 83       	std	Y+4, r25	; 0x04
    2ee4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2ee6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ee8:	fc 81       	ldd	r31, Y+4	; 0x04
    2eea:	81 e1       	ldi	r24, 0x11	; 17
    2eec:	80 83       	st	Z, r24
	pxTopOfStack--;
    2eee:	8b 81       	ldd	r24, Y+3	; 0x03
    2ef0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ef2:	01 97       	sbiw	r24, 0x01	; 1
    2ef4:	9c 83       	std	Y+4, r25	; 0x04
    2ef6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    2ef8:	eb 81       	ldd	r30, Y+3	; 0x03
    2efa:	fc 81       	ldd	r31, Y+4	; 0x04
    2efc:	82 e1       	ldi	r24, 0x12	; 18
    2efe:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f00:	8b 81       	ldd	r24, Y+3	; 0x03
    2f02:	9c 81       	ldd	r25, Y+4	; 0x04
    2f04:	01 97       	sbiw	r24, 0x01	; 1
    2f06:	9c 83       	std	Y+4, r25	; 0x04
    2f08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2f0a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f0c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f0e:	83 e1       	ldi	r24, 0x13	; 19
    2f10:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f12:	8b 81       	ldd	r24, Y+3	; 0x03
    2f14:	9c 81       	ldd	r25, Y+4	; 0x04
    2f16:	01 97       	sbiw	r24, 0x01	; 1
    2f18:	9c 83       	std	Y+4, r25	; 0x04
    2f1a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    2f1c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f1e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f20:	84 e1       	ldi	r24, 0x14	; 20
    2f22:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f24:	8b 81       	ldd	r24, Y+3	; 0x03
    2f26:	9c 81       	ldd	r25, Y+4	; 0x04
    2f28:	01 97       	sbiw	r24, 0x01	; 1
    2f2a:	9c 83       	std	Y+4, r25	; 0x04
    2f2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2f2e:	eb 81       	ldd	r30, Y+3	; 0x03
    2f30:	fc 81       	ldd	r31, Y+4	; 0x04
    2f32:	85 e1       	ldi	r24, 0x15	; 21
    2f34:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f36:	8b 81       	ldd	r24, Y+3	; 0x03
    2f38:	9c 81       	ldd	r25, Y+4	; 0x04
    2f3a:	01 97       	sbiw	r24, 0x01	; 1
    2f3c:	9c 83       	std	Y+4, r25	; 0x04
    2f3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    2f40:	eb 81       	ldd	r30, Y+3	; 0x03
    2f42:	fc 81       	ldd	r31, Y+4	; 0x04
    2f44:	86 e1       	ldi	r24, 0x16	; 22
    2f46:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f48:	8b 81       	ldd	r24, Y+3	; 0x03
    2f4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f4c:	01 97       	sbiw	r24, 0x01	; 1
    2f4e:	9c 83       	std	Y+4, r25	; 0x04
    2f50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2f52:	eb 81       	ldd	r30, Y+3	; 0x03
    2f54:	fc 81       	ldd	r31, Y+4	; 0x04
    2f56:	87 e1       	ldi	r24, 0x17	; 23
    2f58:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f5e:	01 97       	sbiw	r24, 0x01	; 1
    2f60:	9c 83       	std	Y+4, r25	; 0x04
    2f62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2f64:	eb 81       	ldd	r30, Y+3	; 0x03
    2f66:	fc 81       	ldd	r31, Y+4	; 0x04
    2f68:	88 e1       	ldi	r24, 0x18	; 24
    2f6a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f6c:	8b 81       	ldd	r24, Y+3	; 0x03
    2f6e:	9c 81       	ldd	r25, Y+4	; 0x04
    2f70:	01 97       	sbiw	r24, 0x01	; 1
    2f72:	9c 83       	std	Y+4, r25	; 0x04
    2f74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2f76:	eb 81       	ldd	r30, Y+3	; 0x03
    2f78:	fc 81       	ldd	r31, Y+4	; 0x04
    2f7a:	89 e1       	ldi	r24, 0x19	; 25
    2f7c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f7e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f80:	9c 81       	ldd	r25, Y+4	; 0x04
    2f82:	01 97       	sbiw	r24, 0x01	; 1
    2f84:	9c 83       	std	Y+4, r25	; 0x04
    2f86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2f88:	eb 81       	ldd	r30, Y+3	; 0x03
    2f8a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f8c:	80 e2       	ldi	r24, 0x20	; 32
    2f8e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2f90:	8b 81       	ldd	r24, Y+3	; 0x03
    2f92:	9c 81       	ldd	r25, Y+4	; 0x04
    2f94:	01 97       	sbiw	r24, 0x01	; 1
    2f96:	9c 83       	std	Y+4, r25	; 0x04
    2f98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2f9a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f9c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f9e:	81 e2       	ldi	r24, 0x21	; 33
    2fa0:	80 83       	st	Z, r24
	pxTopOfStack--;
    2fa2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fa6:	01 97       	sbiw	r24, 0x01	; 1
    2fa8:	9c 83       	std	Y+4, r25	; 0x04
    2faa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2fac:	eb 81       	ldd	r30, Y+3	; 0x03
    2fae:	fc 81       	ldd	r31, Y+4	; 0x04
    2fb0:	82 e2       	ldi	r24, 0x22	; 34
    2fb2:	80 83       	st	Z, r24
	pxTopOfStack--;
    2fb4:	8b 81       	ldd	r24, Y+3	; 0x03
    2fb6:	9c 81       	ldd	r25, Y+4	; 0x04
    2fb8:	01 97       	sbiw	r24, 0x01	; 1
    2fba:	9c 83       	std	Y+4, r25	; 0x04
    2fbc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2fbe:	eb 81       	ldd	r30, Y+3	; 0x03
    2fc0:	fc 81       	ldd	r31, Y+4	; 0x04
    2fc2:	83 e2       	ldi	r24, 0x23	; 35
    2fc4:	80 83       	st	Z, r24
	pxTopOfStack--;
    2fc6:	8b 81       	ldd	r24, Y+3	; 0x03
    2fc8:	9c 81       	ldd	r25, Y+4	; 0x04
    2fca:	01 97       	sbiw	r24, 0x01	; 1
    2fcc:	9c 83       	std	Y+4, r25	; 0x04
    2fce:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    2fd0:	8f 81       	ldd	r24, Y+7	; 0x07
    2fd2:	98 85       	ldd	r25, Y+8	; 0x08
    2fd4:	9a 83       	std	Y+2, r25	; 0x02
    2fd6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2fd8:	89 81       	ldd	r24, Y+1	; 0x01
    2fda:	eb 81       	ldd	r30, Y+3	; 0x03
    2fdc:	fc 81       	ldd	r31, Y+4	; 0x04
    2fde:	80 83       	st	Z, r24
	pxTopOfStack--;
    2fe0:	8b 81       	ldd	r24, Y+3	; 0x03
    2fe2:	9c 81       	ldd	r25, Y+4	; 0x04
    2fe4:	01 97       	sbiw	r24, 0x01	; 1
    2fe6:	9c 83       	std	Y+4, r25	; 0x04
    2fe8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2fea:	89 81       	ldd	r24, Y+1	; 0x01
    2fec:	9a 81       	ldd	r25, Y+2	; 0x02
    2fee:	89 2f       	mov	r24, r25
    2ff0:	99 27       	eor	r25, r25
    2ff2:	9a 83       	std	Y+2, r25	; 0x02
    2ff4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2ff6:	89 81       	ldd	r24, Y+1	; 0x01
    2ff8:	eb 81       	ldd	r30, Y+3	; 0x03
    2ffa:	fc 81       	ldd	r31, Y+4	; 0x04
    2ffc:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ffe:	8b 81       	ldd	r24, Y+3	; 0x03
    3000:	9c 81       	ldd	r25, Y+4	; 0x04
    3002:	01 97       	sbiw	r24, 0x01	; 1
    3004:	9c 83       	std	Y+4, r25	; 0x04
    3006:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    3008:	eb 81       	ldd	r30, Y+3	; 0x03
    300a:	fc 81       	ldd	r31, Y+4	; 0x04
    300c:	86 e2       	ldi	r24, 0x26	; 38
    300e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3010:	8b 81       	ldd	r24, Y+3	; 0x03
    3012:	9c 81       	ldd	r25, Y+4	; 0x04
    3014:	01 97       	sbiw	r24, 0x01	; 1
    3016:	9c 83       	std	Y+4, r25	; 0x04
    3018:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    301a:	eb 81       	ldd	r30, Y+3	; 0x03
    301c:	fc 81       	ldd	r31, Y+4	; 0x04
    301e:	87 e2       	ldi	r24, 0x27	; 39
    3020:	80 83       	st	Z, r24
	pxTopOfStack--;
    3022:	8b 81       	ldd	r24, Y+3	; 0x03
    3024:	9c 81       	ldd	r25, Y+4	; 0x04
    3026:	01 97       	sbiw	r24, 0x01	; 1
    3028:	9c 83       	std	Y+4, r25	; 0x04
    302a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    302c:	eb 81       	ldd	r30, Y+3	; 0x03
    302e:	fc 81       	ldd	r31, Y+4	; 0x04
    3030:	88 e2       	ldi	r24, 0x28	; 40
    3032:	80 83       	st	Z, r24
	pxTopOfStack--;
    3034:	8b 81       	ldd	r24, Y+3	; 0x03
    3036:	9c 81       	ldd	r25, Y+4	; 0x04
    3038:	01 97       	sbiw	r24, 0x01	; 1
    303a:	9c 83       	std	Y+4, r25	; 0x04
    303c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    303e:	eb 81       	ldd	r30, Y+3	; 0x03
    3040:	fc 81       	ldd	r31, Y+4	; 0x04
    3042:	89 e2       	ldi	r24, 0x29	; 41
    3044:	80 83       	st	Z, r24
	pxTopOfStack--;
    3046:	8b 81       	ldd	r24, Y+3	; 0x03
    3048:	9c 81       	ldd	r25, Y+4	; 0x04
    304a:	01 97       	sbiw	r24, 0x01	; 1
    304c:	9c 83       	std	Y+4, r25	; 0x04
    304e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    3050:	eb 81       	ldd	r30, Y+3	; 0x03
    3052:	fc 81       	ldd	r31, Y+4	; 0x04
    3054:	80 e3       	ldi	r24, 0x30	; 48
    3056:	80 83       	st	Z, r24
	pxTopOfStack--;
    3058:	8b 81       	ldd	r24, Y+3	; 0x03
    305a:	9c 81       	ldd	r25, Y+4	; 0x04
    305c:	01 97       	sbiw	r24, 0x01	; 1
    305e:	9c 83       	std	Y+4, r25	; 0x04
    3060:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    3062:	eb 81       	ldd	r30, Y+3	; 0x03
    3064:	fc 81       	ldd	r31, Y+4	; 0x04
    3066:	81 e3       	ldi	r24, 0x31	; 49
    3068:	80 83       	st	Z, r24
	pxTopOfStack--;
    306a:	8b 81       	ldd	r24, Y+3	; 0x03
    306c:	9c 81       	ldd	r25, Y+4	; 0x04
    306e:	01 97       	sbiw	r24, 0x01	; 1
    3070:	9c 83       	std	Y+4, r25	; 0x04
    3072:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3074:	8b 81       	ldd	r24, Y+3	; 0x03
    3076:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3078:	28 96       	adiw	r28, 0x08	; 8
    307a:	0f b6       	in	r0, 0x3f	; 63
    307c:	f8 94       	cli
    307e:	de bf       	out	0x3e, r29	; 62
    3080:	0f be       	out	0x3f, r0	; 63
    3082:	cd bf       	out	0x3d, r28	; 61
    3084:	cf 91       	pop	r28
    3086:	df 91       	pop	r29
    3088:	08 95       	ret

0000308a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    308a:	df 93       	push	r29
    308c:	cf 93       	push	r28
    308e:	cd b7       	in	r28, 0x3d	; 61
    3090:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3092:	0e 94 35 19 	call	0x326a	; 0x326a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3096:	a0 91 92 05 	lds	r26, 0x0592
    309a:	b0 91 93 05 	lds	r27, 0x0593
    309e:	cd 91       	ld	r28, X+
    30a0:	cd bf       	out	0x3d, r28	; 61
    30a2:	dd 91       	ld	r29, X+
    30a4:	de bf       	out	0x3e, r29	; 62
    30a6:	ff 91       	pop	r31
    30a8:	ef 91       	pop	r30
    30aa:	df 91       	pop	r29
    30ac:	cf 91       	pop	r28
    30ae:	bf 91       	pop	r27
    30b0:	af 91       	pop	r26
    30b2:	9f 91       	pop	r25
    30b4:	8f 91       	pop	r24
    30b6:	7f 91       	pop	r23
    30b8:	6f 91       	pop	r22
    30ba:	5f 91       	pop	r21
    30bc:	4f 91       	pop	r20
    30be:	3f 91       	pop	r19
    30c0:	2f 91       	pop	r18
    30c2:	1f 91       	pop	r17
    30c4:	0f 91       	pop	r16
    30c6:	ff 90       	pop	r15
    30c8:	ef 90       	pop	r14
    30ca:	df 90       	pop	r13
    30cc:	cf 90       	pop	r12
    30ce:	bf 90       	pop	r11
    30d0:	af 90       	pop	r10
    30d2:	9f 90       	pop	r9
    30d4:	8f 90       	pop	r8
    30d6:	7f 90       	pop	r7
    30d8:	6f 90       	pop	r6
    30da:	5f 90       	pop	r5
    30dc:	4f 90       	pop	r4
    30de:	3f 90       	pop	r3
    30e0:	2f 90       	pop	r2
    30e2:	1f 90       	pop	r1
    30e4:	0f 90       	pop	r0
    30e6:	0f be       	out	0x3f, r0	; 63
    30e8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    30ea:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    30ec:	81 e0       	ldi	r24, 0x01	; 1
}
    30ee:	cf 91       	pop	r28
    30f0:	df 91       	pop	r29
    30f2:	08 95       	ret

000030f4 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    30f4:	df 93       	push	r29
    30f6:	cf 93       	push	r28
    30f8:	cd b7       	in	r28, 0x3d	; 61
    30fa:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    30fc:	cf 91       	pop	r28
    30fe:	df 91       	pop	r29
    3100:	08 95       	ret

00003102 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3102:	0f 92       	push	r0
    3104:	0f b6       	in	r0, 0x3f	; 63
    3106:	f8 94       	cli
    3108:	0f 92       	push	r0
    310a:	1f 92       	push	r1
    310c:	11 24       	eor	r1, r1
    310e:	2f 92       	push	r2
    3110:	3f 92       	push	r3
    3112:	4f 92       	push	r4
    3114:	5f 92       	push	r5
    3116:	6f 92       	push	r6
    3118:	7f 92       	push	r7
    311a:	8f 92       	push	r8
    311c:	9f 92       	push	r9
    311e:	af 92       	push	r10
    3120:	bf 92       	push	r11
    3122:	cf 92       	push	r12
    3124:	df 92       	push	r13
    3126:	ef 92       	push	r14
    3128:	ff 92       	push	r15
    312a:	0f 93       	push	r16
    312c:	1f 93       	push	r17
    312e:	2f 93       	push	r18
    3130:	3f 93       	push	r19
    3132:	4f 93       	push	r20
    3134:	5f 93       	push	r21
    3136:	6f 93       	push	r22
    3138:	7f 93       	push	r23
    313a:	8f 93       	push	r24
    313c:	9f 93       	push	r25
    313e:	af 93       	push	r26
    3140:	bf 93       	push	r27
    3142:	cf 93       	push	r28
    3144:	df 93       	push	r29
    3146:	ef 93       	push	r30
    3148:	ff 93       	push	r31
    314a:	a0 91 92 05 	lds	r26, 0x0592
    314e:	b0 91 93 05 	lds	r27, 0x0593
    3152:	0d b6       	in	r0, 0x3d	; 61
    3154:	0d 92       	st	X+, r0
    3156:	0e b6       	in	r0, 0x3e	; 62
    3158:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    315a:	0e 94 6f 23 	call	0x46de	; 0x46de <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    315e:	a0 91 92 05 	lds	r26, 0x0592
    3162:	b0 91 93 05 	lds	r27, 0x0593
    3166:	cd 91       	ld	r28, X+
    3168:	cd bf       	out	0x3d, r28	; 61
    316a:	dd 91       	ld	r29, X+
    316c:	de bf       	out	0x3e, r29	; 62
    316e:	ff 91       	pop	r31
    3170:	ef 91       	pop	r30
    3172:	df 91       	pop	r29
    3174:	cf 91       	pop	r28
    3176:	bf 91       	pop	r27
    3178:	af 91       	pop	r26
    317a:	9f 91       	pop	r25
    317c:	8f 91       	pop	r24
    317e:	7f 91       	pop	r23
    3180:	6f 91       	pop	r22
    3182:	5f 91       	pop	r21
    3184:	4f 91       	pop	r20
    3186:	3f 91       	pop	r19
    3188:	2f 91       	pop	r18
    318a:	1f 91       	pop	r17
    318c:	0f 91       	pop	r16
    318e:	ff 90       	pop	r15
    3190:	ef 90       	pop	r14
    3192:	df 90       	pop	r13
    3194:	cf 90       	pop	r12
    3196:	bf 90       	pop	r11
    3198:	af 90       	pop	r10
    319a:	9f 90       	pop	r9
    319c:	8f 90       	pop	r8
    319e:	7f 90       	pop	r7
    31a0:	6f 90       	pop	r6
    31a2:	5f 90       	pop	r5
    31a4:	4f 90       	pop	r4
    31a6:	3f 90       	pop	r3
    31a8:	2f 90       	pop	r2
    31aa:	1f 90       	pop	r1
    31ac:	0f 90       	pop	r0
    31ae:	0f be       	out	0x3f, r0	; 63
    31b0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    31b2:	08 95       	ret

000031b4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    31b4:	0f 92       	push	r0
    31b6:	0f b6       	in	r0, 0x3f	; 63
    31b8:	f8 94       	cli
    31ba:	0f 92       	push	r0
    31bc:	1f 92       	push	r1
    31be:	11 24       	eor	r1, r1
    31c0:	2f 92       	push	r2
    31c2:	3f 92       	push	r3
    31c4:	4f 92       	push	r4
    31c6:	5f 92       	push	r5
    31c8:	6f 92       	push	r6
    31ca:	7f 92       	push	r7
    31cc:	8f 92       	push	r8
    31ce:	9f 92       	push	r9
    31d0:	af 92       	push	r10
    31d2:	bf 92       	push	r11
    31d4:	cf 92       	push	r12
    31d6:	df 92       	push	r13
    31d8:	ef 92       	push	r14
    31da:	ff 92       	push	r15
    31dc:	0f 93       	push	r16
    31de:	1f 93       	push	r17
    31e0:	2f 93       	push	r18
    31e2:	3f 93       	push	r19
    31e4:	4f 93       	push	r20
    31e6:	5f 93       	push	r21
    31e8:	6f 93       	push	r22
    31ea:	7f 93       	push	r23
    31ec:	8f 93       	push	r24
    31ee:	9f 93       	push	r25
    31f0:	af 93       	push	r26
    31f2:	bf 93       	push	r27
    31f4:	cf 93       	push	r28
    31f6:	df 93       	push	r29
    31f8:	ef 93       	push	r30
    31fa:	ff 93       	push	r31
    31fc:	a0 91 92 05 	lds	r26, 0x0592
    3200:	b0 91 93 05 	lds	r27, 0x0593
    3204:	0d b6       	in	r0, 0x3d	; 61
    3206:	0d 92       	st	X+, r0
    3208:	0e b6       	in	r0, 0x3e	; 62
    320a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    320c:	0e 94 9a 22 	call	0x4534	; 0x4534 <vTaskIncrementTick>
	vTaskSwitchContext();
    3210:	0e 94 6f 23 	call	0x46de	; 0x46de <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3214:	a0 91 92 05 	lds	r26, 0x0592
    3218:	b0 91 93 05 	lds	r27, 0x0593
    321c:	cd 91       	ld	r28, X+
    321e:	cd bf       	out	0x3d, r28	; 61
    3220:	dd 91       	ld	r29, X+
    3222:	de bf       	out	0x3e, r29	; 62
    3224:	ff 91       	pop	r31
    3226:	ef 91       	pop	r30
    3228:	df 91       	pop	r29
    322a:	cf 91       	pop	r28
    322c:	bf 91       	pop	r27
    322e:	af 91       	pop	r26
    3230:	9f 91       	pop	r25
    3232:	8f 91       	pop	r24
    3234:	7f 91       	pop	r23
    3236:	6f 91       	pop	r22
    3238:	5f 91       	pop	r21
    323a:	4f 91       	pop	r20
    323c:	3f 91       	pop	r19
    323e:	2f 91       	pop	r18
    3240:	1f 91       	pop	r17
    3242:	0f 91       	pop	r16
    3244:	ff 90       	pop	r15
    3246:	ef 90       	pop	r14
    3248:	df 90       	pop	r13
    324a:	cf 90       	pop	r12
    324c:	bf 90       	pop	r11
    324e:	af 90       	pop	r10
    3250:	9f 90       	pop	r9
    3252:	8f 90       	pop	r8
    3254:	7f 90       	pop	r7
    3256:	6f 90       	pop	r6
    3258:	5f 90       	pop	r5
    325a:	4f 90       	pop	r4
    325c:	3f 90       	pop	r3
    325e:	2f 90       	pop	r2
    3260:	1f 90       	pop	r1
    3262:	0f 90       	pop	r0
    3264:	0f be       	out	0x3f, r0	; 63
    3266:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3268:	08 95       	ret

0000326a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    326a:	df 93       	push	r29
    326c:	cf 93       	push	r28
    326e:	00 d0       	rcall	.+0      	; 0x3270 <prvSetupTimerInterrupt+0x6>
    3270:	00 d0       	rcall	.+0      	; 0x3272 <prvSetupTimerInterrupt+0x8>
    3272:	00 d0       	rcall	.+0      	; 0x3274 <prvSetupTimerInterrupt+0xa>
    3274:	cd b7       	in	r28, 0x3d	; 61
    3276:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3278:	80 e8       	ldi	r24, 0x80	; 128
    327a:	9e e3       	ldi	r25, 0x3E	; 62
    327c:	a0 e0       	ldi	r26, 0x00	; 0
    327e:	b0 e0       	ldi	r27, 0x00	; 0
    3280:	8b 83       	std	Y+3, r24	; 0x03
    3282:	9c 83       	std	Y+4, r25	; 0x04
    3284:	ad 83       	std	Y+5, r26	; 0x05
    3286:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3288:	8b 81       	ldd	r24, Y+3	; 0x03
    328a:	9c 81       	ldd	r25, Y+4	; 0x04
    328c:	ad 81       	ldd	r26, Y+5	; 0x05
    328e:	be 81       	ldd	r27, Y+6	; 0x06
    3290:	68 94       	set
    3292:	15 f8       	bld	r1, 5
    3294:	b6 95       	lsr	r27
    3296:	a7 95       	ror	r26
    3298:	97 95       	ror	r25
    329a:	87 95       	ror	r24
    329c:	16 94       	lsr	r1
    329e:	d1 f7       	brne	.-12     	; 0x3294 <prvSetupTimerInterrupt+0x2a>
    32a0:	8b 83       	std	Y+3, r24	; 0x03
    32a2:	9c 83       	std	Y+4, r25	; 0x04
    32a4:	ad 83       	std	Y+5, r26	; 0x05
    32a6:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    32a8:	8b 81       	ldd	r24, Y+3	; 0x03
    32aa:	9c 81       	ldd	r25, Y+4	; 0x04
    32ac:	ad 81       	ldd	r26, Y+5	; 0x05
    32ae:	be 81       	ldd	r27, Y+6	; 0x06
    32b0:	01 97       	sbiw	r24, 0x01	; 1
    32b2:	a1 09       	sbc	r26, r1
    32b4:	b1 09       	sbc	r27, r1
    32b6:	8b 83       	std	Y+3, r24	; 0x03
    32b8:	9c 83       	std	Y+4, r25	; 0x04
    32ba:	ad 83       	std	Y+5, r26	; 0x05
    32bc:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    32be:	8b 81       	ldd	r24, Y+3	; 0x03
    32c0:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    32c2:	8b 81       	ldd	r24, Y+3	; 0x03
    32c4:	9c 81       	ldd	r25, Y+4	; 0x04
    32c6:	ad 81       	ldd	r26, Y+5	; 0x05
    32c8:	be 81       	ldd	r27, Y+6	; 0x06
    32ca:	89 2f       	mov	r24, r25
    32cc:	9a 2f       	mov	r25, r26
    32ce:	ab 2f       	mov	r26, r27
    32d0:	bb 27       	eor	r27, r27
    32d2:	8b 83       	std	Y+3, r24	; 0x03
    32d4:	9c 83       	std	Y+4, r25	; 0x04
    32d6:	ad 83       	std	Y+5, r26	; 0x05
    32d8:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    32da:	8b 81       	ldd	r24, Y+3	; 0x03
    32dc:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    32de:	eb e4       	ldi	r30, 0x4B	; 75
    32e0:	f0 e0       	ldi	r31, 0x00	; 0
    32e2:	8a 81       	ldd	r24, Y+2	; 0x02
    32e4:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    32e6:	ea e4       	ldi	r30, 0x4A	; 74
    32e8:	f0 e0       	ldi	r31, 0x00	; 0
    32ea:	89 81       	ldd	r24, Y+1	; 0x01
    32ec:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    32ee:	8b e0       	ldi	r24, 0x0B	; 11
    32f0:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    32f2:	ee e4       	ldi	r30, 0x4E	; 78
    32f4:	f0 e0       	ldi	r31, 0x00	; 0
    32f6:	89 81       	ldd	r24, Y+1	; 0x01
    32f8:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    32fa:	e9 e5       	ldi	r30, 0x59	; 89
    32fc:	f0 e0       	ldi	r31, 0x00	; 0
    32fe:	80 81       	ld	r24, Z
    3300:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3302:	89 81       	ldd	r24, Y+1	; 0x01
    3304:	80 61       	ori	r24, 0x10	; 16
    3306:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    3308:	e9 e5       	ldi	r30, 0x59	; 89
    330a:	f0 e0       	ldi	r31, 0x00	; 0
    330c:	89 81       	ldd	r24, Y+1	; 0x01
    330e:	80 83       	st	Z, r24
}
    3310:	26 96       	adiw	r28, 0x06	; 6
    3312:	0f b6       	in	r0, 0x3f	; 63
    3314:	f8 94       	cli
    3316:	de bf       	out	0x3e, r29	; 62
    3318:	0f be       	out	0x3f, r0	; 63
    331a:	cd bf       	out	0x3d, r28	; 61
    331c:	cf 91       	pop	r28
    331e:	df 91       	pop	r29
    3320:	08 95       	ret

00003322 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    3322:	0e 94 da 18 	call	0x31b4	; 0x31b4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3326:	18 95       	reti

00003328 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    3328:	df 93       	push	r29
    332a:	cf 93       	push	r28
    332c:	cd b7       	in	r28, 0x3d	; 61
    332e:	de b7       	in	r29, 0x3e	; 62
    3330:	28 97       	sbiw	r28, 0x08	; 8
    3332:	0f b6       	in	r0, 0x3f	; 63
    3334:	f8 94       	cli
    3336:	de bf       	out	0x3e, r29	; 62
    3338:	0f be       	out	0x3f, r0	; 63
    333a:	cd bf       	out	0x3d, r28	; 61
    333c:	8f 83       	std	Y+7, r24	; 0x07
    333e:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    3340:	1a 82       	std	Y+2, r1	; 0x02
    3342:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    3344:	8f 81       	ldd	r24, Y+7	; 0x07
    3346:	88 23       	and	r24, r24
    3348:	09 f4       	brne	.+2      	; 0x334c <xQueueCreate+0x24>
    334a:	8c c0       	rjmp	.+280    	; 0x3464 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    334c:	8f e1       	ldi	r24, 0x1F	; 31
    334e:	90 e0       	ldi	r25, 0x00	; 0
    3350:	0e 94 1b 15 	call	0x2a36	; 0x2a36 <pvPortMalloc>
    3354:	9e 83       	std	Y+6, r25	; 0x06
    3356:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    3358:	8d 81       	ldd	r24, Y+5	; 0x05
    335a:	9e 81       	ldd	r25, Y+6	; 0x06
    335c:	00 97       	sbiw	r24, 0x00	; 0
    335e:	09 f4       	brne	.+2      	; 0x3362 <xQueueCreate+0x3a>
    3360:	81 c0       	rjmp	.+258    	; 0x3464 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    3362:	8f 81       	ldd	r24, Y+7	; 0x07
    3364:	28 2f       	mov	r18, r24
    3366:	30 e0       	ldi	r19, 0x00	; 0
    3368:	88 85       	ldd	r24, Y+8	; 0x08
    336a:	88 2f       	mov	r24, r24
    336c:	90 e0       	ldi	r25, 0x00	; 0
    336e:	ac 01       	movw	r20, r24
    3370:	24 9f       	mul	r18, r20
    3372:	c0 01       	movw	r24, r0
    3374:	25 9f       	mul	r18, r21
    3376:	90 0d       	add	r25, r0
    3378:	34 9f       	mul	r19, r20
    337a:	90 0d       	add	r25, r0
    337c:	11 24       	eor	r1, r1
    337e:	01 96       	adiw	r24, 0x01	; 1
    3380:	9c 83       	std	Y+4, r25	; 0x04
    3382:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    3384:	8b 81       	ldd	r24, Y+3	; 0x03
    3386:	9c 81       	ldd	r25, Y+4	; 0x04
    3388:	0e 94 1b 15 	call	0x2a36	; 0x2a36 <pvPortMalloc>
    338c:	ed 81       	ldd	r30, Y+5	; 0x05
    338e:	fe 81       	ldd	r31, Y+6	; 0x06
    3390:	91 83       	std	Z+1, r25	; 0x01
    3392:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    3394:	ed 81       	ldd	r30, Y+5	; 0x05
    3396:	fe 81       	ldd	r31, Y+6	; 0x06
    3398:	80 81       	ld	r24, Z
    339a:	91 81       	ldd	r25, Z+1	; 0x01
    339c:	00 97       	sbiw	r24, 0x00	; 0
    339e:	09 f4       	brne	.+2      	; 0x33a2 <xQueueCreate+0x7a>
    33a0:	5d c0       	rjmp	.+186    	; 0x345c <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    33a2:	ed 81       	ldd	r30, Y+5	; 0x05
    33a4:	fe 81       	ldd	r31, Y+6	; 0x06
    33a6:	40 81       	ld	r20, Z
    33a8:	51 81       	ldd	r21, Z+1	; 0x01
    33aa:	8f 81       	ldd	r24, Y+7	; 0x07
    33ac:	28 2f       	mov	r18, r24
    33ae:	30 e0       	ldi	r19, 0x00	; 0
    33b0:	88 85       	ldd	r24, Y+8	; 0x08
    33b2:	88 2f       	mov	r24, r24
    33b4:	90 e0       	ldi	r25, 0x00	; 0
    33b6:	bc 01       	movw	r22, r24
    33b8:	26 9f       	mul	r18, r22
    33ba:	c0 01       	movw	r24, r0
    33bc:	27 9f       	mul	r18, r23
    33be:	90 0d       	add	r25, r0
    33c0:	36 9f       	mul	r19, r22
    33c2:	90 0d       	add	r25, r0
    33c4:	11 24       	eor	r1, r1
    33c6:	84 0f       	add	r24, r20
    33c8:	95 1f       	adc	r25, r21
    33ca:	ed 81       	ldd	r30, Y+5	; 0x05
    33cc:	fe 81       	ldd	r31, Y+6	; 0x06
    33ce:	93 83       	std	Z+3, r25	; 0x03
    33d0:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    33d2:	ed 81       	ldd	r30, Y+5	; 0x05
    33d4:	fe 81       	ldd	r31, Y+6	; 0x06
    33d6:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    33d8:	ed 81       	ldd	r30, Y+5	; 0x05
    33da:	fe 81       	ldd	r31, Y+6	; 0x06
    33dc:	80 81       	ld	r24, Z
    33de:	91 81       	ldd	r25, Z+1	; 0x01
    33e0:	ed 81       	ldd	r30, Y+5	; 0x05
    33e2:	fe 81       	ldd	r31, Y+6	; 0x06
    33e4:	95 83       	std	Z+5, r25	; 0x05
    33e6:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    33e8:	ed 81       	ldd	r30, Y+5	; 0x05
    33ea:	fe 81       	ldd	r31, Y+6	; 0x06
    33ec:	40 81       	ld	r20, Z
    33ee:	51 81       	ldd	r21, Z+1	; 0x01
    33f0:	8f 81       	ldd	r24, Y+7	; 0x07
    33f2:	88 2f       	mov	r24, r24
    33f4:	90 e0       	ldi	r25, 0x00	; 0
    33f6:	9c 01       	movw	r18, r24
    33f8:	21 50       	subi	r18, 0x01	; 1
    33fa:	30 40       	sbci	r19, 0x00	; 0
    33fc:	88 85       	ldd	r24, Y+8	; 0x08
    33fe:	88 2f       	mov	r24, r24
    3400:	90 e0       	ldi	r25, 0x00	; 0
    3402:	bc 01       	movw	r22, r24
    3404:	26 9f       	mul	r18, r22
    3406:	c0 01       	movw	r24, r0
    3408:	27 9f       	mul	r18, r23
    340a:	90 0d       	add	r25, r0
    340c:	36 9f       	mul	r19, r22
    340e:	90 0d       	add	r25, r0
    3410:	11 24       	eor	r1, r1
    3412:	84 0f       	add	r24, r20
    3414:	95 1f       	adc	r25, r21
    3416:	ed 81       	ldd	r30, Y+5	; 0x05
    3418:	fe 81       	ldd	r31, Y+6	; 0x06
    341a:	97 83       	std	Z+7, r25	; 0x07
    341c:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    341e:	ed 81       	ldd	r30, Y+5	; 0x05
    3420:	fe 81       	ldd	r31, Y+6	; 0x06
    3422:	8f 81       	ldd	r24, Y+7	; 0x07
    3424:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    3426:	ed 81       	ldd	r30, Y+5	; 0x05
    3428:	fe 81       	ldd	r31, Y+6	; 0x06
    342a:	88 85       	ldd	r24, Y+8	; 0x08
    342c:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    342e:	ed 81       	ldd	r30, Y+5	; 0x05
    3430:	fe 81       	ldd	r31, Y+6	; 0x06
    3432:	8f ef       	ldi	r24, 0xFF	; 255
    3434:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    3436:	ed 81       	ldd	r30, Y+5	; 0x05
    3438:	fe 81       	ldd	r31, Y+6	; 0x06
    343a:	8f ef       	ldi	r24, 0xFF	; 255
    343c:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    343e:	8d 81       	ldd	r24, Y+5	; 0x05
    3440:	9e 81       	ldd	r25, Y+6	; 0x06
    3442:	08 96       	adiw	r24, 0x08	; 8
    3444:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3448:	8d 81       	ldd	r24, Y+5	; 0x05
    344a:	9e 81       	ldd	r25, Y+6	; 0x06
    344c:	41 96       	adiw	r24, 0x11	; 17
    344e:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3452:	8d 81       	ldd	r24, Y+5	; 0x05
    3454:	9e 81       	ldd	r25, Y+6	; 0x06
    3456:	9a 83       	std	Y+2, r25	; 0x02
    3458:	89 83       	std	Y+1, r24	; 0x01
    345a:	04 c0       	rjmp	.+8      	; 0x3464 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    345c:	8d 81       	ldd	r24, Y+5	; 0x05
    345e:	9e 81       	ldd	r25, Y+6	; 0x06
    3460:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    3464:	89 81       	ldd	r24, Y+1	; 0x01
    3466:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3468:	28 96       	adiw	r28, 0x08	; 8
    346a:	0f b6       	in	r0, 0x3f	; 63
    346c:	f8 94       	cli
    346e:	de bf       	out	0x3e, r29	; 62
    3470:	0f be       	out	0x3f, r0	; 63
    3472:	cd bf       	out	0x3d, r28	; 61
    3474:	cf 91       	pop	r28
    3476:	df 91       	pop	r29
    3478:	08 95       	ret

0000347a <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if configUSE_COUNTING_SEMAPHORES == 1

	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
	{
    347a:	df 93       	push	r29
    347c:	cf 93       	push	r28
    347e:	00 d0       	rcall	.+0      	; 0x3480 <xQueueCreateCountingSemaphore+0x6>
    3480:	00 d0       	rcall	.+0      	; 0x3482 <xQueueCreateCountingSemaphore+0x8>
    3482:	cd b7       	in	r28, 0x3d	; 61
    3484:	de b7       	in	r29, 0x3e	; 62
    3486:	8b 83       	std	Y+3, r24	; 0x03
    3488:	6c 83       	std	Y+4, r22	; 0x04
	xQueueHandle pxHandle;

		pxHandle = xQueueCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH );
    348a:	8b 81       	ldd	r24, Y+3	; 0x03
    348c:	60 e0       	ldi	r22, 0x00	; 0
    348e:	0e 94 94 19 	call	0x3328	; 0x3328 <xQueueCreate>
    3492:	9a 83       	std	Y+2, r25	; 0x02
    3494:	89 83       	std	Y+1, r24	; 0x01

		if( pxHandle != NULL )
    3496:	89 81       	ldd	r24, Y+1	; 0x01
    3498:	9a 81       	ldd	r25, Y+2	; 0x02
    349a:	00 97       	sbiw	r24, 0x00	; 0
    349c:	21 f0       	breq	.+8      	; 0x34a6 <xQueueCreateCountingSemaphore+0x2c>
		{
			pxHandle->uxMessagesWaiting = uxInitialCount;
    349e:	e9 81       	ldd	r30, Y+1	; 0x01
    34a0:	fa 81       	ldd	r31, Y+2	; 0x02
    34a2:	8c 81       	ldd	r24, Y+4	; 0x04
    34a4:	82 8f       	std	Z+26, r24	; 0x1a
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		configASSERT( pxHandle );
		return pxHandle;
    34a6:	89 81       	ldd	r24, Y+1	; 0x01
    34a8:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    34aa:	0f 90       	pop	r0
    34ac:	0f 90       	pop	r0
    34ae:	0f 90       	pop	r0
    34b0:	0f 90       	pop	r0
    34b2:	cf 91       	pop	r28
    34b4:	df 91       	pop	r29
    34b6:	08 95       	ret

000034b8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    34b8:	df 93       	push	r29
    34ba:	cf 93       	push	r28
    34bc:	cd b7       	in	r28, 0x3d	; 61
    34be:	de b7       	in	r29, 0x3e	; 62
    34c0:	2c 97       	sbiw	r28, 0x0c	; 12
    34c2:	0f b6       	in	r0, 0x3f	; 63
    34c4:	f8 94       	cli
    34c6:	de bf       	out	0x3e, r29	; 62
    34c8:	0f be       	out	0x3f, r0	; 63
    34ca:	cd bf       	out	0x3d, r28	; 61
    34cc:	9e 83       	std	Y+6, r25	; 0x06
    34ce:	8d 83       	std	Y+5, r24	; 0x05
    34d0:	78 87       	std	Y+8, r23	; 0x08
    34d2:	6f 83       	std	Y+7, r22	; 0x07
    34d4:	5a 87       	std	Y+10, r21	; 0x0a
    34d6:	49 87       	std	Y+9, r20	; 0x09
    34d8:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    34da:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    34dc:	0f b6       	in	r0, 0x3f	; 63
    34de:	f8 94       	cli
    34e0:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    34e2:	ed 81       	ldd	r30, Y+5	; 0x05
    34e4:	fe 81       	ldd	r31, Y+6	; 0x06
    34e6:	92 8d       	ldd	r25, Z+26	; 0x1a
    34e8:	ed 81       	ldd	r30, Y+5	; 0x05
    34ea:	fe 81       	ldd	r31, Y+6	; 0x06
    34ec:	83 8d       	ldd	r24, Z+27	; 0x1b
    34ee:	98 17       	cp	r25, r24
    34f0:	d8 f4       	brcc	.+54     	; 0x3528 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    34f2:	8d 81       	ldd	r24, Y+5	; 0x05
    34f4:	9e 81       	ldd	r25, Y+6	; 0x06
    34f6:	2f 81       	ldd	r18, Y+7	; 0x07
    34f8:	38 85       	ldd	r19, Y+8	; 0x08
    34fa:	b9 01       	movw	r22, r18
    34fc:	4b 85       	ldd	r20, Y+11	; 0x0b
    34fe:	0e 94 97 1c 	call	0x392e	; 0x392e <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3502:	ed 81       	ldd	r30, Y+5	; 0x05
    3504:	fe 81       	ldd	r31, Y+6	; 0x06
    3506:	81 89       	ldd	r24, Z+17	; 0x11
    3508:	88 23       	and	r24, r24
    350a:	49 f0       	breq	.+18     	; 0x351e <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    350c:	8d 81       	ldd	r24, Y+5	; 0x05
    350e:	9e 81       	ldd	r25, Y+6	; 0x06
    3510:	41 96       	adiw	r24, 0x11	; 17
    3512:	0e 94 1e 24 	call	0x483c	; 0x483c <xTaskRemoveFromEventList>
    3516:	81 30       	cpi	r24, 0x01	; 1
    3518:	11 f4       	brne	.+4      	; 0x351e <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    351a:	0e 94 81 18 	call	0x3102	; 0x3102 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    351e:	0f 90       	pop	r0
    3520:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    3522:	81 e0       	ldi	r24, 0x01	; 1
    3524:	8c 87       	std	Y+12, r24	; 0x0c
    3526:	5c c0       	rjmp	.+184    	; 0x35e0 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3528:	89 85       	ldd	r24, Y+9	; 0x09
    352a:	9a 85       	ldd	r25, Y+10	; 0x0a
    352c:	00 97       	sbiw	r24, 0x00	; 0
    352e:	21 f4       	brne	.+8      	; 0x3538 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3530:	0f 90       	pop	r0
    3532:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3534:	1c 86       	std	Y+12, r1	; 0x0c
    3536:	54 c0       	rjmp	.+168    	; 0x35e0 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    3538:	89 81       	ldd	r24, Y+1	; 0x01
    353a:	88 23       	and	r24, r24
    353c:	31 f4       	brne	.+12     	; 0x354a <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    353e:	ce 01       	movw	r24, r28
    3540:	02 96       	adiw	r24, 0x02	; 2
    3542:	0e 94 86 24 	call	0x490c	; 0x490c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3546:	81 e0       	ldi	r24, 0x01	; 1
    3548:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    354a:	0f 90       	pop	r0
    354c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    354e:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3552:	0f b6       	in	r0, 0x3f	; 63
    3554:	f8 94       	cli
    3556:	0f 92       	push	r0
    3558:	ed 81       	ldd	r30, Y+5	; 0x05
    355a:	fe 81       	ldd	r31, Y+6	; 0x06
    355c:	85 8d       	ldd	r24, Z+29	; 0x1d
    355e:	8f 3f       	cpi	r24, 0xFF	; 255
    3560:	19 f4       	brne	.+6      	; 0x3568 <xQueueGenericSend+0xb0>
    3562:	ed 81       	ldd	r30, Y+5	; 0x05
    3564:	fe 81       	ldd	r31, Y+6	; 0x06
    3566:	15 8e       	std	Z+29, r1	; 0x1d
    3568:	ed 81       	ldd	r30, Y+5	; 0x05
    356a:	fe 81       	ldd	r31, Y+6	; 0x06
    356c:	86 8d       	ldd	r24, Z+30	; 0x1e
    356e:	8f 3f       	cpi	r24, 0xFF	; 255
    3570:	19 f4       	brne	.+6      	; 0x3578 <xQueueGenericSend+0xc0>
    3572:	ed 81       	ldd	r30, Y+5	; 0x05
    3574:	fe 81       	ldd	r31, Y+6	; 0x06
    3576:	16 8e       	std	Z+30, r1	; 0x1e
    3578:	0f 90       	pop	r0
    357a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    357c:	ce 01       	movw	r24, r28
    357e:	02 96       	adiw	r24, 0x02	; 2
    3580:	9e 01       	movw	r18, r28
    3582:	27 5f       	subi	r18, 0xF7	; 247
    3584:	3f 4f       	sbci	r19, 0xFF	; 255
    3586:	b9 01       	movw	r22, r18
    3588:	0e 94 9f 24 	call	0x493e	; 0x493e <xTaskCheckForTimeOut>
    358c:	88 23       	and	r24, r24
    358e:	09 f5       	brne	.+66     	; 0x35d2 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3590:	8d 81       	ldd	r24, Y+5	; 0x05
    3592:	9e 81       	ldd	r25, Y+6	; 0x06
    3594:	0e 94 fb 1d 	call	0x3bf6	; 0x3bf6 <prvIsQueueFull>
    3598:	88 23       	and	r24, r24
    359a:	a1 f0       	breq	.+40     	; 0x35c4 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    359c:	8d 81       	ldd	r24, Y+5	; 0x05
    359e:	9e 81       	ldd	r25, Y+6	; 0x06
    35a0:	08 96       	adiw	r24, 0x08	; 8
    35a2:	29 85       	ldd	r18, Y+9	; 0x09
    35a4:	3a 85       	ldd	r19, Y+10	; 0x0a
    35a6:	b9 01       	movw	r22, r18
    35a8:	0e 94 d5 23 	call	0x47aa	; 0x47aa <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    35ac:	8d 81       	ldd	r24, Y+5	; 0x05
    35ae:	9e 81       	ldd	r25, Y+6	; 0x06
    35b0:	0e 94 74 1d 	call	0x3ae8	; 0x3ae8 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    35b4:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
    35b8:	88 23       	and	r24, r24
    35ba:	09 f0       	breq	.+2      	; 0x35be <xQueueGenericSend+0x106>
    35bc:	8f cf       	rjmp	.-226    	; 0x34dc <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    35be:	0e 94 81 18 	call	0x3102	; 0x3102 <vPortYield>
    35c2:	8c cf       	rjmp	.-232    	; 0x34dc <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    35c4:	8d 81       	ldd	r24, Y+5	; 0x05
    35c6:	9e 81       	ldd	r25, Y+6	; 0x06
    35c8:	0e 94 74 1d 	call	0x3ae8	; 0x3ae8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    35cc:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
    35d0:	85 cf       	rjmp	.-246    	; 0x34dc <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    35d2:	8d 81       	ldd	r24, Y+5	; 0x05
    35d4:	9e 81       	ldd	r25, Y+6	; 0x06
    35d6:	0e 94 74 1d 	call	0x3ae8	; 0x3ae8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    35da:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    35de:	1c 86       	std	Y+12, r1	; 0x0c
    35e0:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    35e2:	2c 96       	adiw	r28, 0x0c	; 12
    35e4:	0f b6       	in	r0, 0x3f	; 63
    35e6:	f8 94       	cli
    35e8:	de bf       	out	0x3e, r29	; 62
    35ea:	0f be       	out	0x3f, r0	; 63
    35ec:	cd bf       	out	0x3d, r28	; 61
    35ee:	cf 91       	pop	r28
    35f0:	df 91       	pop	r29
    35f2:	08 95       	ret

000035f4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    35f4:	df 93       	push	r29
    35f6:	cf 93       	push	r28
    35f8:	cd b7       	in	r28, 0x3d	; 61
    35fa:	de b7       	in	r29, 0x3e	; 62
    35fc:	29 97       	sbiw	r28, 0x09	; 9
    35fe:	0f b6       	in	r0, 0x3f	; 63
    3600:	f8 94       	cli
    3602:	de bf       	out	0x3e, r29	; 62
    3604:	0f be       	out	0x3f, r0	; 63
    3606:	cd bf       	out	0x3d, r28	; 61
    3608:	9c 83       	std	Y+4, r25	; 0x04
    360a:	8b 83       	std	Y+3, r24	; 0x03
    360c:	7e 83       	std	Y+6, r23	; 0x06
    360e:	6d 83       	std	Y+5, r22	; 0x05
    3610:	58 87       	std	Y+8, r21	; 0x08
    3612:	4f 83       	std	Y+7, r20	; 0x07
    3614:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3616:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3618:	eb 81       	ldd	r30, Y+3	; 0x03
    361a:	fc 81       	ldd	r31, Y+4	; 0x04
    361c:	92 8d       	ldd	r25, Z+26	; 0x1a
    361e:	eb 81       	ldd	r30, Y+3	; 0x03
    3620:	fc 81       	ldd	r31, Y+4	; 0x04
    3622:	83 8d       	ldd	r24, Z+27	; 0x1b
    3624:	98 17       	cp	r25, r24
    3626:	40 f5       	brcc	.+80     	; 0x3678 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3628:	8b 81       	ldd	r24, Y+3	; 0x03
    362a:	9c 81       	ldd	r25, Y+4	; 0x04
    362c:	2d 81       	ldd	r18, Y+5	; 0x05
    362e:	3e 81       	ldd	r19, Y+6	; 0x06
    3630:	b9 01       	movw	r22, r18
    3632:	49 85       	ldd	r20, Y+9	; 0x09
    3634:	0e 94 97 1c 	call	0x392e	; 0x392e <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3638:	eb 81       	ldd	r30, Y+3	; 0x03
    363a:	fc 81       	ldd	r31, Y+4	; 0x04
    363c:	86 8d       	ldd	r24, Z+30	; 0x1e
    363e:	8f 3f       	cpi	r24, 0xFF	; 255
    3640:	89 f4       	brne	.+34     	; 0x3664 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3642:	eb 81       	ldd	r30, Y+3	; 0x03
    3644:	fc 81       	ldd	r31, Y+4	; 0x04
    3646:	81 89       	ldd	r24, Z+17	; 0x11
    3648:	88 23       	and	r24, r24
    364a:	99 f0       	breq	.+38     	; 0x3672 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    364c:	8b 81       	ldd	r24, Y+3	; 0x03
    364e:	9c 81       	ldd	r25, Y+4	; 0x04
    3650:	41 96       	adiw	r24, 0x11	; 17
    3652:	0e 94 1e 24 	call	0x483c	; 0x483c <xTaskRemoveFromEventList>
    3656:	88 23       	and	r24, r24
    3658:	61 f0       	breq	.+24     	; 0x3672 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    365a:	ef 81       	ldd	r30, Y+7	; 0x07
    365c:	f8 85       	ldd	r31, Y+8	; 0x08
    365e:	81 e0       	ldi	r24, 0x01	; 1
    3660:	80 83       	st	Z, r24
    3662:	07 c0       	rjmp	.+14     	; 0x3672 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3664:	eb 81       	ldd	r30, Y+3	; 0x03
    3666:	fc 81       	ldd	r31, Y+4	; 0x04
    3668:	86 8d       	ldd	r24, Z+30	; 0x1e
    366a:	8f 5f       	subi	r24, 0xFF	; 255
    366c:	eb 81       	ldd	r30, Y+3	; 0x03
    366e:	fc 81       	ldd	r31, Y+4	; 0x04
    3670:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3672:	81 e0       	ldi	r24, 0x01	; 1
    3674:	8a 83       	std	Y+2, r24	; 0x02
    3676:	01 c0       	rjmp	.+2      	; 0x367a <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3678:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    367a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    367c:	29 96       	adiw	r28, 0x09	; 9
    367e:	0f b6       	in	r0, 0x3f	; 63
    3680:	f8 94       	cli
    3682:	de bf       	out	0x3e, r29	; 62
    3684:	0f be       	out	0x3f, r0	; 63
    3686:	cd bf       	out	0x3d, r28	; 61
    3688:	cf 91       	pop	r28
    368a:	df 91       	pop	r29
    368c:	08 95       	ret

0000368e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    368e:	df 93       	push	r29
    3690:	cf 93       	push	r28
    3692:	cd b7       	in	r28, 0x3d	; 61
    3694:	de b7       	in	r29, 0x3e	; 62
    3696:	2e 97       	sbiw	r28, 0x0e	; 14
    3698:	0f b6       	in	r0, 0x3f	; 63
    369a:	f8 94       	cli
    369c:	de bf       	out	0x3e, r29	; 62
    369e:	0f be       	out	0x3f, r0	; 63
    36a0:	cd bf       	out	0x3d, r28	; 61
    36a2:	98 87       	std	Y+8, r25	; 0x08
    36a4:	8f 83       	std	Y+7, r24	; 0x07
    36a6:	7a 87       	std	Y+10, r23	; 0x0a
    36a8:	69 87       	std	Y+9, r22	; 0x09
    36aa:	5c 87       	std	Y+12, r21	; 0x0c
    36ac:	4b 87       	std	Y+11, r20	; 0x0b
    36ae:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    36b0:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    36b2:	0f b6       	in	r0, 0x3f	; 63
    36b4:	f8 94       	cli
    36b6:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    36b8:	ef 81       	ldd	r30, Y+7	; 0x07
    36ba:	f8 85       	ldd	r31, Y+8	; 0x08
    36bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    36be:	88 23       	and	r24, r24
    36c0:	09 f4       	brne	.+2      	; 0x36c4 <xQueueGenericReceive+0x36>
    36c2:	3f c0       	rjmp	.+126    	; 0x3742 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    36c4:	ef 81       	ldd	r30, Y+7	; 0x07
    36c6:	f8 85       	ldd	r31, Y+8	; 0x08
    36c8:	86 81       	ldd	r24, Z+6	; 0x06
    36ca:	97 81       	ldd	r25, Z+7	; 0x07
    36cc:	9a 83       	std	Y+2, r25	; 0x02
    36ce:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    36d0:	8f 81       	ldd	r24, Y+7	; 0x07
    36d2:	98 85       	ldd	r25, Y+8	; 0x08
    36d4:	29 85       	ldd	r18, Y+9	; 0x09
    36d6:	3a 85       	ldd	r19, Y+10	; 0x0a
    36d8:	b9 01       	movw	r22, r18
    36da:	0e 94 2c 1d 	call	0x3a58	; 0x3a58 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    36de:	8d 85       	ldd	r24, Y+13	; 0x0d
    36e0:	88 23       	and	r24, r24
    36e2:	b1 f4       	brne	.+44     	; 0x3710 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    36e4:	ef 81       	ldd	r30, Y+7	; 0x07
    36e6:	f8 85       	ldd	r31, Y+8	; 0x08
    36e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    36ea:	81 50       	subi	r24, 0x01	; 1
    36ec:	ef 81       	ldd	r30, Y+7	; 0x07
    36ee:	f8 85       	ldd	r31, Y+8	; 0x08
    36f0:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    36f2:	ef 81       	ldd	r30, Y+7	; 0x07
    36f4:	f8 85       	ldd	r31, Y+8	; 0x08
    36f6:	80 85       	ldd	r24, Z+8	; 0x08
    36f8:	88 23       	and	r24, r24
    36fa:	f1 f0       	breq	.+60     	; 0x3738 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    36fc:	8f 81       	ldd	r24, Y+7	; 0x07
    36fe:	98 85       	ldd	r25, Y+8	; 0x08
    3700:	08 96       	adiw	r24, 0x08	; 8
    3702:	0e 94 1e 24 	call	0x483c	; 0x483c <xTaskRemoveFromEventList>
    3706:	81 30       	cpi	r24, 0x01	; 1
    3708:	b9 f4       	brne	.+46     	; 0x3738 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    370a:	0e 94 81 18 	call	0x3102	; 0x3102 <vPortYield>
    370e:	14 c0       	rjmp	.+40     	; 0x3738 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    3710:	ef 81       	ldd	r30, Y+7	; 0x07
    3712:	f8 85       	ldd	r31, Y+8	; 0x08
    3714:	89 81       	ldd	r24, Y+1	; 0x01
    3716:	9a 81       	ldd	r25, Y+2	; 0x02
    3718:	97 83       	std	Z+7, r25	; 0x07
    371a:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    371c:	ef 81       	ldd	r30, Y+7	; 0x07
    371e:	f8 85       	ldd	r31, Y+8	; 0x08
    3720:	81 89       	ldd	r24, Z+17	; 0x11
    3722:	88 23       	and	r24, r24
    3724:	49 f0       	breq	.+18     	; 0x3738 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3726:	8f 81       	ldd	r24, Y+7	; 0x07
    3728:	98 85       	ldd	r25, Y+8	; 0x08
    372a:	41 96       	adiw	r24, 0x11	; 17
    372c:	0e 94 1e 24 	call	0x483c	; 0x483c <xTaskRemoveFromEventList>
    3730:	88 23       	and	r24, r24
    3732:	11 f0       	breq	.+4      	; 0x3738 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    3734:	0e 94 81 18 	call	0x3102	; 0x3102 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    3738:	0f 90       	pop	r0
    373a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    373c:	81 e0       	ldi	r24, 0x01	; 1
    373e:	8e 87       	std	Y+14, r24	; 0x0e
    3740:	5c c0       	rjmp	.+184    	; 0x37fa <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3742:	8b 85       	ldd	r24, Y+11	; 0x0b
    3744:	9c 85       	ldd	r25, Y+12	; 0x0c
    3746:	00 97       	sbiw	r24, 0x00	; 0
    3748:	21 f4       	brne	.+8      	; 0x3752 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    374a:	0f 90       	pop	r0
    374c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    374e:	1e 86       	std	Y+14, r1	; 0x0e
    3750:	54 c0       	rjmp	.+168    	; 0x37fa <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    3752:	8b 81       	ldd	r24, Y+3	; 0x03
    3754:	88 23       	and	r24, r24
    3756:	31 f4       	brne	.+12     	; 0x3764 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3758:	ce 01       	movw	r24, r28
    375a:	04 96       	adiw	r24, 0x04	; 4
    375c:	0e 94 86 24 	call	0x490c	; 0x490c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3760:	81 e0       	ldi	r24, 0x01	; 1
    3762:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    3764:	0f 90       	pop	r0
    3766:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3768:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    376c:	0f b6       	in	r0, 0x3f	; 63
    376e:	f8 94       	cli
    3770:	0f 92       	push	r0
    3772:	ef 81       	ldd	r30, Y+7	; 0x07
    3774:	f8 85       	ldd	r31, Y+8	; 0x08
    3776:	85 8d       	ldd	r24, Z+29	; 0x1d
    3778:	8f 3f       	cpi	r24, 0xFF	; 255
    377a:	19 f4       	brne	.+6      	; 0x3782 <xQueueGenericReceive+0xf4>
    377c:	ef 81       	ldd	r30, Y+7	; 0x07
    377e:	f8 85       	ldd	r31, Y+8	; 0x08
    3780:	15 8e       	std	Z+29, r1	; 0x1d
    3782:	ef 81       	ldd	r30, Y+7	; 0x07
    3784:	f8 85       	ldd	r31, Y+8	; 0x08
    3786:	86 8d       	ldd	r24, Z+30	; 0x1e
    3788:	8f 3f       	cpi	r24, 0xFF	; 255
    378a:	19 f4       	brne	.+6      	; 0x3792 <xQueueGenericReceive+0x104>
    378c:	ef 81       	ldd	r30, Y+7	; 0x07
    378e:	f8 85       	ldd	r31, Y+8	; 0x08
    3790:	16 8e       	std	Z+30, r1	; 0x1e
    3792:	0f 90       	pop	r0
    3794:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3796:	ce 01       	movw	r24, r28
    3798:	04 96       	adiw	r24, 0x04	; 4
    379a:	9e 01       	movw	r18, r28
    379c:	25 5f       	subi	r18, 0xF5	; 245
    379e:	3f 4f       	sbci	r19, 0xFF	; 255
    37a0:	b9 01       	movw	r22, r18
    37a2:	0e 94 9f 24 	call	0x493e	; 0x493e <xTaskCheckForTimeOut>
    37a6:	88 23       	and	r24, r24
    37a8:	09 f5       	brne	.+66     	; 0x37ec <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    37aa:	8f 81       	ldd	r24, Y+7	; 0x07
    37ac:	98 85       	ldd	r25, Y+8	; 0x08
    37ae:	0e 94 c8 1d 	call	0x3b90	; 0x3b90 <prvIsQueueEmpty>
    37b2:	88 23       	and	r24, r24
    37b4:	a1 f0       	breq	.+40     	; 0x37de <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    37b6:	8f 81       	ldd	r24, Y+7	; 0x07
    37b8:	98 85       	ldd	r25, Y+8	; 0x08
    37ba:	41 96       	adiw	r24, 0x11	; 17
    37bc:	2b 85       	ldd	r18, Y+11	; 0x0b
    37be:	3c 85       	ldd	r19, Y+12	; 0x0c
    37c0:	b9 01       	movw	r22, r18
    37c2:	0e 94 d5 23 	call	0x47aa	; 0x47aa <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    37c6:	8f 81       	ldd	r24, Y+7	; 0x07
    37c8:	98 85       	ldd	r25, Y+8	; 0x08
    37ca:	0e 94 74 1d 	call	0x3ae8	; 0x3ae8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    37ce:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
    37d2:	88 23       	and	r24, r24
    37d4:	09 f0       	breq	.+2      	; 0x37d8 <xQueueGenericReceive+0x14a>
    37d6:	6d cf       	rjmp	.-294    	; 0x36b2 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    37d8:	0e 94 81 18 	call	0x3102	; 0x3102 <vPortYield>
    37dc:	6a cf       	rjmp	.-300    	; 0x36b2 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    37de:	8f 81       	ldd	r24, Y+7	; 0x07
    37e0:	98 85       	ldd	r25, Y+8	; 0x08
    37e2:	0e 94 74 1d 	call	0x3ae8	; 0x3ae8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    37e6:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
    37ea:	63 cf       	rjmp	.-314    	; 0x36b2 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    37ec:	8f 81       	ldd	r24, Y+7	; 0x07
    37ee:	98 85       	ldd	r25, Y+8	; 0x08
    37f0:	0e 94 74 1d 	call	0x3ae8	; 0x3ae8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    37f4:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    37f8:	1e 86       	std	Y+14, r1	; 0x0e
    37fa:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    37fc:	2e 96       	adiw	r28, 0x0e	; 14
    37fe:	0f b6       	in	r0, 0x3f	; 63
    3800:	f8 94       	cli
    3802:	de bf       	out	0x3e, r29	; 62
    3804:	0f be       	out	0x3f, r0	; 63
    3806:	cd bf       	out	0x3d, r28	; 61
    3808:	cf 91       	pop	r28
    380a:	df 91       	pop	r29
    380c:	08 95       	ret

0000380e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    380e:	df 93       	push	r29
    3810:	cf 93       	push	r28
    3812:	cd b7       	in	r28, 0x3d	; 61
    3814:	de b7       	in	r29, 0x3e	; 62
    3816:	28 97       	sbiw	r28, 0x08	; 8
    3818:	0f b6       	in	r0, 0x3f	; 63
    381a:	f8 94       	cli
    381c:	de bf       	out	0x3e, r29	; 62
    381e:	0f be       	out	0x3f, r0	; 63
    3820:	cd bf       	out	0x3d, r28	; 61
    3822:	9c 83       	std	Y+4, r25	; 0x04
    3824:	8b 83       	std	Y+3, r24	; 0x03
    3826:	7e 83       	std	Y+6, r23	; 0x06
    3828:	6d 83       	std	Y+5, r22	; 0x05
    382a:	58 87       	std	Y+8, r21	; 0x08
    382c:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    382e:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3830:	eb 81       	ldd	r30, Y+3	; 0x03
    3832:	fc 81       	ldd	r31, Y+4	; 0x04
    3834:	82 8d       	ldd	r24, Z+26	; 0x1a
    3836:	88 23       	and	r24, r24
    3838:	71 f1       	breq	.+92     	; 0x3896 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    383a:	8b 81       	ldd	r24, Y+3	; 0x03
    383c:	9c 81       	ldd	r25, Y+4	; 0x04
    383e:	2d 81       	ldd	r18, Y+5	; 0x05
    3840:	3e 81       	ldd	r19, Y+6	; 0x06
    3842:	b9 01       	movw	r22, r18
    3844:	0e 94 2c 1d 	call	0x3a58	; 0x3a58 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3848:	eb 81       	ldd	r30, Y+3	; 0x03
    384a:	fc 81       	ldd	r31, Y+4	; 0x04
    384c:	82 8d       	ldd	r24, Z+26	; 0x1a
    384e:	81 50       	subi	r24, 0x01	; 1
    3850:	eb 81       	ldd	r30, Y+3	; 0x03
    3852:	fc 81       	ldd	r31, Y+4	; 0x04
    3854:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    3856:	eb 81       	ldd	r30, Y+3	; 0x03
    3858:	fc 81       	ldd	r31, Y+4	; 0x04
    385a:	85 8d       	ldd	r24, Z+29	; 0x1d
    385c:	8f 3f       	cpi	r24, 0xFF	; 255
    385e:	89 f4       	brne	.+34     	; 0x3882 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3860:	eb 81       	ldd	r30, Y+3	; 0x03
    3862:	fc 81       	ldd	r31, Y+4	; 0x04
    3864:	80 85       	ldd	r24, Z+8	; 0x08
    3866:	88 23       	and	r24, r24
    3868:	99 f0       	breq	.+38     	; 0x3890 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    386a:	8b 81       	ldd	r24, Y+3	; 0x03
    386c:	9c 81       	ldd	r25, Y+4	; 0x04
    386e:	08 96       	adiw	r24, 0x08	; 8
    3870:	0e 94 1e 24 	call	0x483c	; 0x483c <xTaskRemoveFromEventList>
    3874:	88 23       	and	r24, r24
    3876:	61 f0       	breq	.+24     	; 0x3890 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    3878:	ef 81       	ldd	r30, Y+7	; 0x07
    387a:	f8 85       	ldd	r31, Y+8	; 0x08
    387c:	81 e0       	ldi	r24, 0x01	; 1
    387e:	80 83       	st	Z, r24
    3880:	07 c0       	rjmp	.+14     	; 0x3890 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3882:	eb 81       	ldd	r30, Y+3	; 0x03
    3884:	fc 81       	ldd	r31, Y+4	; 0x04
    3886:	85 8d       	ldd	r24, Z+29	; 0x1d
    3888:	8f 5f       	subi	r24, 0xFF	; 255
    388a:	eb 81       	ldd	r30, Y+3	; 0x03
    388c:	fc 81       	ldd	r31, Y+4	; 0x04
    388e:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3890:	81 e0       	ldi	r24, 0x01	; 1
    3892:	8a 83       	std	Y+2, r24	; 0x02
    3894:	01 c0       	rjmp	.+2      	; 0x3898 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    3896:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3898:	8a 81       	ldd	r24, Y+2	; 0x02
}
    389a:	28 96       	adiw	r28, 0x08	; 8
    389c:	0f b6       	in	r0, 0x3f	; 63
    389e:	f8 94       	cli
    38a0:	de bf       	out	0x3e, r29	; 62
    38a2:	0f be       	out	0x3f, r0	; 63
    38a4:	cd bf       	out	0x3d, r28	; 61
    38a6:	cf 91       	pop	r28
    38a8:	df 91       	pop	r29
    38aa:	08 95       	ret

000038ac <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    38ac:	df 93       	push	r29
    38ae:	cf 93       	push	r28
    38b0:	00 d0       	rcall	.+0      	; 0x38b2 <uxQueueMessagesWaiting+0x6>
    38b2:	0f 92       	push	r0
    38b4:	cd b7       	in	r28, 0x3d	; 61
    38b6:	de b7       	in	r29, 0x3e	; 62
    38b8:	9b 83       	std	Y+3, r25	; 0x03
    38ba:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    38bc:	0f b6       	in	r0, 0x3f	; 63
    38be:	f8 94       	cli
    38c0:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    38c2:	ea 81       	ldd	r30, Y+2	; 0x02
    38c4:	fb 81       	ldd	r31, Y+3	; 0x03
    38c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    38c8:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    38ca:	0f 90       	pop	r0
    38cc:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    38ce:	89 81       	ldd	r24, Y+1	; 0x01
}
    38d0:	0f 90       	pop	r0
    38d2:	0f 90       	pop	r0
    38d4:	0f 90       	pop	r0
    38d6:	cf 91       	pop	r28
    38d8:	df 91       	pop	r29
    38da:	08 95       	ret

000038dc <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    38dc:	df 93       	push	r29
    38de:	cf 93       	push	r28
    38e0:	00 d0       	rcall	.+0      	; 0x38e2 <uxQueueMessagesWaitingFromISR+0x6>
    38e2:	0f 92       	push	r0
    38e4:	cd b7       	in	r28, 0x3d	; 61
    38e6:	de b7       	in	r29, 0x3e	; 62
    38e8:	9b 83       	std	Y+3, r25	; 0x03
    38ea:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    38ec:	ea 81       	ldd	r30, Y+2	; 0x02
    38ee:	fb 81       	ldd	r31, Y+3	; 0x03
    38f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    38f2:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    38f4:	89 81       	ldd	r24, Y+1	; 0x01
}
    38f6:	0f 90       	pop	r0
    38f8:	0f 90       	pop	r0
    38fa:	0f 90       	pop	r0
    38fc:	cf 91       	pop	r28
    38fe:	df 91       	pop	r29
    3900:	08 95       	ret

00003902 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    3902:	df 93       	push	r29
    3904:	cf 93       	push	r28
    3906:	00 d0       	rcall	.+0      	; 0x3908 <vQueueDelete+0x6>
    3908:	cd b7       	in	r28, 0x3d	; 61
    390a:	de b7       	in	r29, 0x3e	; 62
    390c:	9a 83       	std	Y+2, r25	; 0x02
    390e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    3910:	e9 81       	ldd	r30, Y+1	; 0x01
    3912:	fa 81       	ldd	r31, Y+2	; 0x02
    3914:	80 81       	ld	r24, Z
    3916:	91 81       	ldd	r25, Z+1	; 0x01
    3918:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <vPortFree>
	vPortFree( pxQueue );
    391c:	89 81       	ldd	r24, Y+1	; 0x01
    391e:	9a 81       	ldd	r25, Y+2	; 0x02
    3920:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <vPortFree>
}
    3924:	0f 90       	pop	r0
    3926:	0f 90       	pop	r0
    3928:	cf 91       	pop	r28
    392a:	df 91       	pop	r29
    392c:	08 95       	ret

0000392e <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    392e:	df 93       	push	r29
    3930:	cf 93       	push	r28
    3932:	00 d0       	rcall	.+0      	; 0x3934 <prvCopyDataToQueue+0x6>
    3934:	00 d0       	rcall	.+0      	; 0x3936 <prvCopyDataToQueue+0x8>
    3936:	0f 92       	push	r0
    3938:	cd b7       	in	r28, 0x3d	; 61
    393a:	de b7       	in	r29, 0x3e	; 62
    393c:	9a 83       	std	Y+2, r25	; 0x02
    393e:	89 83       	std	Y+1, r24	; 0x01
    3940:	7c 83       	std	Y+4, r23	; 0x04
    3942:	6b 83       	std	Y+3, r22	; 0x03
    3944:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    3946:	e9 81       	ldd	r30, Y+1	; 0x01
    3948:	fa 81       	ldd	r31, Y+2	; 0x02
    394a:	84 8d       	ldd	r24, Z+28	; 0x1c
    394c:	88 23       	and	r24, r24
    394e:	09 f4       	brne	.+2      	; 0x3952 <prvCopyDataToQueue+0x24>
    3950:	74 c0       	rjmp	.+232    	; 0x3a3a <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    3952:	8d 81       	ldd	r24, Y+5	; 0x05
    3954:	88 23       	and	r24, r24
    3956:	99 f5       	brne	.+102    	; 0x39be <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3958:	e9 81       	ldd	r30, Y+1	; 0x01
    395a:	fa 81       	ldd	r31, Y+2	; 0x02
    395c:	64 81       	ldd	r22, Z+4	; 0x04
    395e:	75 81       	ldd	r23, Z+5	; 0x05
    3960:	e9 81       	ldd	r30, Y+1	; 0x01
    3962:	fa 81       	ldd	r31, Y+2	; 0x02
    3964:	84 8d       	ldd	r24, Z+28	; 0x1c
    3966:	48 2f       	mov	r20, r24
    3968:	50 e0       	ldi	r21, 0x00	; 0
    396a:	2b 81       	ldd	r18, Y+3	; 0x03
    396c:	3c 81       	ldd	r19, Y+4	; 0x04
    396e:	cb 01       	movw	r24, r22
    3970:	b9 01       	movw	r22, r18
    3972:	0e 94 cd 27 	call	0x4f9a	; 0x4f9a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3976:	e9 81       	ldd	r30, Y+1	; 0x01
    3978:	fa 81       	ldd	r31, Y+2	; 0x02
    397a:	24 81       	ldd	r18, Z+4	; 0x04
    397c:	35 81       	ldd	r19, Z+5	; 0x05
    397e:	e9 81       	ldd	r30, Y+1	; 0x01
    3980:	fa 81       	ldd	r31, Y+2	; 0x02
    3982:	84 8d       	ldd	r24, Z+28	; 0x1c
    3984:	88 2f       	mov	r24, r24
    3986:	90 e0       	ldi	r25, 0x00	; 0
    3988:	82 0f       	add	r24, r18
    398a:	93 1f       	adc	r25, r19
    398c:	e9 81       	ldd	r30, Y+1	; 0x01
    398e:	fa 81       	ldd	r31, Y+2	; 0x02
    3990:	95 83       	std	Z+5, r25	; 0x05
    3992:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    3994:	e9 81       	ldd	r30, Y+1	; 0x01
    3996:	fa 81       	ldd	r31, Y+2	; 0x02
    3998:	24 81       	ldd	r18, Z+4	; 0x04
    399a:	35 81       	ldd	r19, Z+5	; 0x05
    399c:	e9 81       	ldd	r30, Y+1	; 0x01
    399e:	fa 81       	ldd	r31, Y+2	; 0x02
    39a0:	82 81       	ldd	r24, Z+2	; 0x02
    39a2:	93 81       	ldd	r25, Z+3	; 0x03
    39a4:	28 17       	cp	r18, r24
    39a6:	39 07       	cpc	r19, r25
    39a8:	08 f4       	brcc	.+2      	; 0x39ac <prvCopyDataToQueue+0x7e>
    39aa:	47 c0       	rjmp	.+142    	; 0x3a3a <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    39ac:	e9 81       	ldd	r30, Y+1	; 0x01
    39ae:	fa 81       	ldd	r31, Y+2	; 0x02
    39b0:	80 81       	ld	r24, Z
    39b2:	91 81       	ldd	r25, Z+1	; 0x01
    39b4:	e9 81       	ldd	r30, Y+1	; 0x01
    39b6:	fa 81       	ldd	r31, Y+2	; 0x02
    39b8:	95 83       	std	Z+5, r25	; 0x05
    39ba:	84 83       	std	Z+4, r24	; 0x04
    39bc:	3e c0       	rjmp	.+124    	; 0x3a3a <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    39be:	e9 81       	ldd	r30, Y+1	; 0x01
    39c0:	fa 81       	ldd	r31, Y+2	; 0x02
    39c2:	66 81       	ldd	r22, Z+6	; 0x06
    39c4:	77 81       	ldd	r23, Z+7	; 0x07
    39c6:	e9 81       	ldd	r30, Y+1	; 0x01
    39c8:	fa 81       	ldd	r31, Y+2	; 0x02
    39ca:	84 8d       	ldd	r24, Z+28	; 0x1c
    39cc:	48 2f       	mov	r20, r24
    39ce:	50 e0       	ldi	r21, 0x00	; 0
    39d0:	2b 81       	ldd	r18, Y+3	; 0x03
    39d2:	3c 81       	ldd	r19, Y+4	; 0x04
    39d4:	cb 01       	movw	r24, r22
    39d6:	b9 01       	movw	r22, r18
    39d8:	0e 94 cd 27 	call	0x4f9a	; 0x4f9a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    39dc:	e9 81       	ldd	r30, Y+1	; 0x01
    39de:	fa 81       	ldd	r31, Y+2	; 0x02
    39e0:	26 81       	ldd	r18, Z+6	; 0x06
    39e2:	37 81       	ldd	r19, Z+7	; 0x07
    39e4:	e9 81       	ldd	r30, Y+1	; 0x01
    39e6:	fa 81       	ldd	r31, Y+2	; 0x02
    39e8:	84 8d       	ldd	r24, Z+28	; 0x1c
    39ea:	88 2f       	mov	r24, r24
    39ec:	90 e0       	ldi	r25, 0x00	; 0
    39ee:	90 95       	com	r25
    39f0:	81 95       	neg	r24
    39f2:	9f 4f       	sbci	r25, 0xFF	; 255
    39f4:	82 0f       	add	r24, r18
    39f6:	93 1f       	adc	r25, r19
    39f8:	e9 81       	ldd	r30, Y+1	; 0x01
    39fa:	fa 81       	ldd	r31, Y+2	; 0x02
    39fc:	97 83       	std	Z+7, r25	; 0x07
    39fe:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    3a00:	e9 81       	ldd	r30, Y+1	; 0x01
    3a02:	fa 81       	ldd	r31, Y+2	; 0x02
    3a04:	26 81       	ldd	r18, Z+6	; 0x06
    3a06:	37 81       	ldd	r19, Z+7	; 0x07
    3a08:	e9 81       	ldd	r30, Y+1	; 0x01
    3a0a:	fa 81       	ldd	r31, Y+2	; 0x02
    3a0c:	80 81       	ld	r24, Z
    3a0e:	91 81       	ldd	r25, Z+1	; 0x01
    3a10:	28 17       	cp	r18, r24
    3a12:	39 07       	cpc	r19, r25
    3a14:	90 f4       	brcc	.+36     	; 0x3a3a <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    3a16:	e9 81       	ldd	r30, Y+1	; 0x01
    3a18:	fa 81       	ldd	r31, Y+2	; 0x02
    3a1a:	22 81       	ldd	r18, Z+2	; 0x02
    3a1c:	33 81       	ldd	r19, Z+3	; 0x03
    3a1e:	e9 81       	ldd	r30, Y+1	; 0x01
    3a20:	fa 81       	ldd	r31, Y+2	; 0x02
    3a22:	84 8d       	ldd	r24, Z+28	; 0x1c
    3a24:	88 2f       	mov	r24, r24
    3a26:	90 e0       	ldi	r25, 0x00	; 0
    3a28:	90 95       	com	r25
    3a2a:	81 95       	neg	r24
    3a2c:	9f 4f       	sbci	r25, 0xFF	; 255
    3a2e:	82 0f       	add	r24, r18
    3a30:	93 1f       	adc	r25, r19
    3a32:	e9 81       	ldd	r30, Y+1	; 0x01
    3a34:	fa 81       	ldd	r31, Y+2	; 0x02
    3a36:	97 83       	std	Z+7, r25	; 0x07
    3a38:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    3a3a:	e9 81       	ldd	r30, Y+1	; 0x01
    3a3c:	fa 81       	ldd	r31, Y+2	; 0x02
    3a3e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a40:	8f 5f       	subi	r24, 0xFF	; 255
    3a42:	e9 81       	ldd	r30, Y+1	; 0x01
    3a44:	fa 81       	ldd	r31, Y+2	; 0x02
    3a46:	82 8f       	std	Z+26, r24	; 0x1a
}
    3a48:	0f 90       	pop	r0
    3a4a:	0f 90       	pop	r0
    3a4c:	0f 90       	pop	r0
    3a4e:	0f 90       	pop	r0
    3a50:	0f 90       	pop	r0
    3a52:	cf 91       	pop	r28
    3a54:	df 91       	pop	r29
    3a56:	08 95       	ret

00003a58 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    3a58:	df 93       	push	r29
    3a5a:	cf 93       	push	r28
    3a5c:	00 d0       	rcall	.+0      	; 0x3a5e <prvCopyDataFromQueue+0x6>
    3a5e:	00 d0       	rcall	.+0      	; 0x3a60 <prvCopyDataFromQueue+0x8>
    3a60:	cd b7       	in	r28, 0x3d	; 61
    3a62:	de b7       	in	r29, 0x3e	; 62
    3a64:	9a 83       	std	Y+2, r25	; 0x02
    3a66:	89 83       	std	Y+1, r24	; 0x01
    3a68:	7c 83       	std	Y+4, r23	; 0x04
    3a6a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    3a6c:	e9 81       	ldd	r30, Y+1	; 0x01
    3a6e:	fa 81       	ldd	r31, Y+2	; 0x02
    3a70:	80 81       	ld	r24, Z
    3a72:	91 81       	ldd	r25, Z+1	; 0x01
    3a74:	00 97       	sbiw	r24, 0x00	; 0
    3a76:	89 f1       	breq	.+98     	; 0x3ada <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    3a78:	e9 81       	ldd	r30, Y+1	; 0x01
    3a7a:	fa 81       	ldd	r31, Y+2	; 0x02
    3a7c:	26 81       	ldd	r18, Z+6	; 0x06
    3a7e:	37 81       	ldd	r19, Z+7	; 0x07
    3a80:	e9 81       	ldd	r30, Y+1	; 0x01
    3a82:	fa 81       	ldd	r31, Y+2	; 0x02
    3a84:	84 8d       	ldd	r24, Z+28	; 0x1c
    3a86:	88 2f       	mov	r24, r24
    3a88:	90 e0       	ldi	r25, 0x00	; 0
    3a8a:	82 0f       	add	r24, r18
    3a8c:	93 1f       	adc	r25, r19
    3a8e:	e9 81       	ldd	r30, Y+1	; 0x01
    3a90:	fa 81       	ldd	r31, Y+2	; 0x02
    3a92:	97 83       	std	Z+7, r25	; 0x07
    3a94:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    3a96:	e9 81       	ldd	r30, Y+1	; 0x01
    3a98:	fa 81       	ldd	r31, Y+2	; 0x02
    3a9a:	26 81       	ldd	r18, Z+6	; 0x06
    3a9c:	37 81       	ldd	r19, Z+7	; 0x07
    3a9e:	e9 81       	ldd	r30, Y+1	; 0x01
    3aa0:	fa 81       	ldd	r31, Y+2	; 0x02
    3aa2:	82 81       	ldd	r24, Z+2	; 0x02
    3aa4:	93 81       	ldd	r25, Z+3	; 0x03
    3aa6:	28 17       	cp	r18, r24
    3aa8:	39 07       	cpc	r19, r25
    3aaa:	40 f0       	brcs	.+16     	; 0x3abc <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    3aac:	e9 81       	ldd	r30, Y+1	; 0x01
    3aae:	fa 81       	ldd	r31, Y+2	; 0x02
    3ab0:	80 81       	ld	r24, Z
    3ab2:	91 81       	ldd	r25, Z+1	; 0x01
    3ab4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ab6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ab8:	97 83       	std	Z+7, r25	; 0x07
    3aba:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3abc:	e9 81       	ldd	r30, Y+1	; 0x01
    3abe:	fa 81       	ldd	r31, Y+2	; 0x02
    3ac0:	46 81       	ldd	r20, Z+6	; 0x06
    3ac2:	57 81       	ldd	r21, Z+7	; 0x07
    3ac4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ac6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ac8:	84 8d       	ldd	r24, Z+28	; 0x1c
    3aca:	28 2f       	mov	r18, r24
    3acc:	30 e0       	ldi	r19, 0x00	; 0
    3ace:	8b 81       	ldd	r24, Y+3	; 0x03
    3ad0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ad2:	ba 01       	movw	r22, r20
    3ad4:	a9 01       	movw	r20, r18
    3ad6:	0e 94 cd 27 	call	0x4f9a	; 0x4f9a <memcpy>
	}
}
    3ada:	0f 90       	pop	r0
    3adc:	0f 90       	pop	r0
    3ade:	0f 90       	pop	r0
    3ae0:	0f 90       	pop	r0
    3ae2:	cf 91       	pop	r28
    3ae4:	df 91       	pop	r29
    3ae6:	08 95       	ret

00003ae8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    3ae8:	df 93       	push	r29
    3aea:	cf 93       	push	r28
    3aec:	00 d0       	rcall	.+0      	; 0x3aee <prvUnlockQueue+0x6>
    3aee:	cd b7       	in	r28, 0x3d	; 61
    3af0:	de b7       	in	r29, 0x3e	; 62
    3af2:	9a 83       	std	Y+2, r25	; 0x02
    3af4:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3af6:	0f b6       	in	r0, 0x3f	; 63
    3af8:	f8 94       	cli
    3afa:	0f 92       	push	r0
    3afc:	15 c0       	rjmp	.+42     	; 0x3b28 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3afe:	e9 81       	ldd	r30, Y+1	; 0x01
    3b00:	fa 81       	ldd	r31, Y+2	; 0x02
    3b02:	81 89       	ldd	r24, Z+17	; 0x11
    3b04:	88 23       	and	r24, r24
    3b06:	a9 f0       	breq	.+42     	; 0x3b32 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3b08:	89 81       	ldd	r24, Y+1	; 0x01
    3b0a:	9a 81       	ldd	r25, Y+2	; 0x02
    3b0c:	41 96       	adiw	r24, 0x11	; 17
    3b0e:	0e 94 1e 24 	call	0x483c	; 0x483c <xTaskRemoveFromEventList>
    3b12:	88 23       	and	r24, r24
    3b14:	11 f0       	breq	.+4      	; 0x3b1a <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    3b16:	0e 94 06 25 	call	0x4a0c	; 0x4a0c <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    3b1a:	e9 81       	ldd	r30, Y+1	; 0x01
    3b1c:	fa 81       	ldd	r31, Y+2	; 0x02
    3b1e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b20:	81 50       	subi	r24, 0x01	; 1
    3b22:	e9 81       	ldd	r30, Y+1	; 0x01
    3b24:	fa 81       	ldd	r31, Y+2	; 0x02
    3b26:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3b28:	e9 81       	ldd	r30, Y+1	; 0x01
    3b2a:	fa 81       	ldd	r31, Y+2	; 0x02
    3b2c:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b2e:	18 16       	cp	r1, r24
    3b30:	34 f3       	brlt	.-52     	; 0x3afe <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3b32:	e9 81       	ldd	r30, Y+1	; 0x01
    3b34:	fa 81       	ldd	r31, Y+2	; 0x02
    3b36:	8f ef       	ldi	r24, 0xFF	; 255
    3b38:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3b3a:	0f 90       	pop	r0
    3b3c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3b3e:	0f b6       	in	r0, 0x3f	; 63
    3b40:	f8 94       	cli
    3b42:	0f 92       	push	r0
    3b44:	15 c0       	rjmp	.+42     	; 0x3b70 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3b46:	e9 81       	ldd	r30, Y+1	; 0x01
    3b48:	fa 81       	ldd	r31, Y+2	; 0x02
    3b4a:	80 85       	ldd	r24, Z+8	; 0x08
    3b4c:	88 23       	and	r24, r24
    3b4e:	a9 f0       	breq	.+42     	; 0x3b7a <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3b50:	89 81       	ldd	r24, Y+1	; 0x01
    3b52:	9a 81       	ldd	r25, Y+2	; 0x02
    3b54:	08 96       	adiw	r24, 0x08	; 8
    3b56:	0e 94 1e 24 	call	0x483c	; 0x483c <xTaskRemoveFromEventList>
    3b5a:	88 23       	and	r24, r24
    3b5c:	11 f0       	breq	.+4      	; 0x3b62 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    3b5e:	0e 94 06 25 	call	0x4a0c	; 0x4a0c <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    3b62:	e9 81       	ldd	r30, Y+1	; 0x01
    3b64:	fa 81       	ldd	r31, Y+2	; 0x02
    3b66:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b68:	81 50       	subi	r24, 0x01	; 1
    3b6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3b6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3b6e:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3b70:	e9 81       	ldd	r30, Y+1	; 0x01
    3b72:	fa 81       	ldd	r31, Y+2	; 0x02
    3b74:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b76:	18 16       	cp	r1, r24
    3b78:	34 f3       	brlt	.-52     	; 0x3b46 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3b7a:	e9 81       	ldd	r30, Y+1	; 0x01
    3b7c:	fa 81       	ldd	r31, Y+2	; 0x02
    3b7e:	8f ef       	ldi	r24, 0xFF	; 255
    3b80:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    3b82:	0f 90       	pop	r0
    3b84:	0f be       	out	0x3f, r0	; 63
}
    3b86:	0f 90       	pop	r0
    3b88:	0f 90       	pop	r0
    3b8a:	cf 91       	pop	r28
    3b8c:	df 91       	pop	r29
    3b8e:	08 95       	ret

00003b90 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    3b90:	df 93       	push	r29
    3b92:	cf 93       	push	r28
    3b94:	00 d0       	rcall	.+0      	; 0x3b96 <prvIsQueueEmpty+0x6>
    3b96:	0f 92       	push	r0
    3b98:	cd b7       	in	r28, 0x3d	; 61
    3b9a:	de b7       	in	r29, 0x3e	; 62
    3b9c:	9b 83       	std	Y+3, r25	; 0x03
    3b9e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3ba0:	0f b6       	in	r0, 0x3f	; 63
    3ba2:	f8 94       	cli
    3ba4:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    3ba6:	ea 81       	ldd	r30, Y+2	; 0x02
    3ba8:	fb 81       	ldd	r31, Y+3	; 0x03
    3baa:	82 8d       	ldd	r24, Z+26	; 0x1a
    3bac:	19 82       	std	Y+1, r1	; 0x01
    3bae:	88 23       	and	r24, r24
    3bb0:	11 f4       	brne	.+4      	; 0x3bb6 <prvIsQueueEmpty+0x26>
    3bb2:	81 e0       	ldi	r24, 0x01	; 1
    3bb4:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3bb6:	0f 90       	pop	r0
    3bb8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3bba:	89 81       	ldd	r24, Y+1	; 0x01
}
    3bbc:	0f 90       	pop	r0
    3bbe:	0f 90       	pop	r0
    3bc0:	0f 90       	pop	r0
    3bc2:	cf 91       	pop	r28
    3bc4:	df 91       	pop	r29
    3bc6:	08 95       	ret

00003bc8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    3bc8:	df 93       	push	r29
    3bca:	cf 93       	push	r28
    3bcc:	00 d0       	rcall	.+0      	; 0x3bce <xQueueIsQueueEmptyFromISR+0x6>
    3bce:	0f 92       	push	r0
    3bd0:	cd b7       	in	r28, 0x3d	; 61
    3bd2:	de b7       	in	r29, 0x3e	; 62
    3bd4:	9b 83       	std	Y+3, r25	; 0x03
    3bd6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    3bd8:	ea 81       	ldd	r30, Y+2	; 0x02
    3bda:	fb 81       	ldd	r31, Y+3	; 0x03
    3bdc:	82 8d       	ldd	r24, Z+26	; 0x1a
    3bde:	19 82       	std	Y+1, r1	; 0x01
    3be0:	88 23       	and	r24, r24
    3be2:	11 f4       	brne	.+4      	; 0x3be8 <xQueueIsQueueEmptyFromISR+0x20>
    3be4:	81 e0       	ldi	r24, 0x01	; 1
    3be6:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    3be8:	89 81       	ldd	r24, Y+1	; 0x01
}
    3bea:	0f 90       	pop	r0
    3bec:	0f 90       	pop	r0
    3bee:	0f 90       	pop	r0
    3bf0:	cf 91       	pop	r28
    3bf2:	df 91       	pop	r29
    3bf4:	08 95       	ret

00003bf6 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    3bf6:	df 93       	push	r29
    3bf8:	cf 93       	push	r28
    3bfa:	00 d0       	rcall	.+0      	; 0x3bfc <prvIsQueueFull+0x6>
    3bfc:	0f 92       	push	r0
    3bfe:	cd b7       	in	r28, 0x3d	; 61
    3c00:	de b7       	in	r29, 0x3e	; 62
    3c02:	9b 83       	std	Y+3, r25	; 0x03
    3c04:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3c06:	0f b6       	in	r0, 0x3f	; 63
    3c08:	f8 94       	cli
    3c0a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3c0c:	ea 81       	ldd	r30, Y+2	; 0x02
    3c0e:	fb 81       	ldd	r31, Y+3	; 0x03
    3c10:	92 8d       	ldd	r25, Z+26	; 0x1a
    3c12:	ea 81       	ldd	r30, Y+2	; 0x02
    3c14:	fb 81       	ldd	r31, Y+3	; 0x03
    3c16:	83 8d       	ldd	r24, Z+27	; 0x1b
    3c18:	19 82       	std	Y+1, r1	; 0x01
    3c1a:	98 17       	cp	r25, r24
    3c1c:	11 f4       	brne	.+4      	; 0x3c22 <prvIsQueueFull+0x2c>
    3c1e:	81 e0       	ldi	r24, 0x01	; 1
    3c20:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3c22:	0f 90       	pop	r0
    3c24:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3c26:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c28:	0f 90       	pop	r0
    3c2a:	0f 90       	pop	r0
    3c2c:	0f 90       	pop	r0
    3c2e:	cf 91       	pop	r28
    3c30:	df 91       	pop	r29
    3c32:	08 95       	ret

00003c34 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    3c34:	df 93       	push	r29
    3c36:	cf 93       	push	r28
    3c38:	00 d0       	rcall	.+0      	; 0x3c3a <xQueueIsQueueFullFromISR+0x6>
    3c3a:	0f 92       	push	r0
    3c3c:	cd b7       	in	r28, 0x3d	; 61
    3c3e:	de b7       	in	r29, 0x3e	; 62
    3c40:	9b 83       	std	Y+3, r25	; 0x03
    3c42:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3c44:	ea 81       	ldd	r30, Y+2	; 0x02
    3c46:	fb 81       	ldd	r31, Y+3	; 0x03
    3c48:	92 8d       	ldd	r25, Z+26	; 0x1a
    3c4a:	ea 81       	ldd	r30, Y+2	; 0x02
    3c4c:	fb 81       	ldd	r31, Y+3	; 0x03
    3c4e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3c50:	19 82       	std	Y+1, r1	; 0x01
    3c52:	98 17       	cp	r25, r24
    3c54:	11 f4       	brne	.+4      	; 0x3c5a <xQueueIsQueueFullFromISR+0x26>
    3c56:	81 e0       	ldi	r24, 0x01	; 1
    3c58:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    3c5a:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c5c:	0f 90       	pop	r0
    3c5e:	0f 90       	pop	r0
    3c60:	0f 90       	pop	r0
    3c62:	cf 91       	pop	r28
    3c64:	df 91       	pop	r29
    3c66:	08 95       	ret

00003c68 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    3c68:	af 92       	push	r10
    3c6a:	bf 92       	push	r11
    3c6c:	cf 92       	push	r12
    3c6e:	df 92       	push	r13
    3c70:	ef 92       	push	r14
    3c72:	ff 92       	push	r15
    3c74:	0f 93       	push	r16
    3c76:	1f 93       	push	r17
    3c78:	df 93       	push	r29
    3c7a:	cf 93       	push	r28
    3c7c:	cd b7       	in	r28, 0x3d	; 61
    3c7e:	de b7       	in	r29, 0x3e	; 62
    3c80:	64 97       	sbiw	r28, 0x14	; 20
    3c82:	0f b6       	in	r0, 0x3f	; 63
    3c84:	f8 94       	cli
    3c86:	de bf       	out	0x3e, r29	; 62
    3c88:	0f be       	out	0x3f, r0	; 63
    3c8a:	cd bf       	out	0x3d, r28	; 61
    3c8c:	9f 83       	std	Y+7, r25	; 0x07
    3c8e:	8e 83       	std	Y+6, r24	; 0x06
    3c90:	79 87       	std	Y+9, r23	; 0x09
    3c92:	68 87       	std	Y+8, r22	; 0x08
    3c94:	5b 87       	std	Y+11, r21	; 0x0b
    3c96:	4a 87       	std	Y+10, r20	; 0x0a
    3c98:	3d 87       	std	Y+13, r19	; 0x0d
    3c9a:	2c 87       	std	Y+12, r18	; 0x0c
    3c9c:	0e 87       	std	Y+14, r16	; 0x0e
    3c9e:	f8 8a       	std	Y+16, r15	; 0x10
    3ca0:	ef 86       	std	Y+15, r14	; 0x0f
    3ca2:	da 8a       	std	Y+18, r13	; 0x12
    3ca4:	c9 8a       	std	Y+17, r12	; 0x11
    3ca6:	bc 8a       	std	Y+20, r11	; 0x14
    3ca8:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    3caa:	8a 85       	ldd	r24, Y+10	; 0x0a
    3cac:	9b 85       	ldd	r25, Y+11	; 0x0b
    3cae:	29 89       	ldd	r18, Y+17	; 0x11
    3cb0:	3a 89       	ldd	r19, Y+18	; 0x12
    3cb2:	b9 01       	movw	r22, r18
    3cb4:	0e 94 39 26 	call	0x4c72	; 0x4c72 <prvAllocateTCBAndStack>
    3cb8:	9c 83       	std	Y+4, r25	; 0x04
    3cba:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    3cbc:	8b 81       	ldd	r24, Y+3	; 0x03
    3cbe:	9c 81       	ldd	r25, Y+4	; 0x04
    3cc0:	00 97       	sbiw	r24, 0x00	; 0
    3cc2:	09 f4       	brne	.+2      	; 0x3cc6 <xTaskGenericCreate+0x5e>
    3cc4:	99 c0       	rjmp	.+306    	; 0x3df8 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    3cc6:	eb 81       	ldd	r30, Y+3	; 0x03
    3cc8:	fc 81       	ldd	r31, Y+4	; 0x04
    3cca:	27 89       	ldd	r18, Z+23	; 0x17
    3ccc:	30 8d       	ldd	r19, Z+24	; 0x18
    3cce:	8a 85       	ldd	r24, Y+10	; 0x0a
    3cd0:	9b 85       	ldd	r25, Y+11	; 0x0b
    3cd2:	01 97       	sbiw	r24, 0x01	; 1
    3cd4:	82 0f       	add	r24, r18
    3cd6:	93 1f       	adc	r25, r19
    3cd8:	9a 83       	std	Y+2, r25	; 0x02
    3cda:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    3cdc:	8b 81       	ldd	r24, Y+3	; 0x03
    3cde:	9c 81       	ldd	r25, Y+4	; 0x04
    3ce0:	28 85       	ldd	r18, Y+8	; 0x08
    3ce2:	39 85       	ldd	r19, Y+9	; 0x09
    3ce4:	eb 89       	ldd	r30, Y+19	; 0x13
    3ce6:	fc 89       	ldd	r31, Y+20	; 0x14
    3ce8:	aa 85       	ldd	r26, Y+10	; 0x0a
    3cea:	bb 85       	ldd	r27, Y+11	; 0x0b
    3cec:	b9 01       	movw	r22, r18
    3cee:	4e 85       	ldd	r20, Y+14	; 0x0e
    3cf0:	9f 01       	movw	r18, r30
    3cf2:	8d 01       	movw	r16, r26
    3cf4:	0e 94 1a 25 	call	0x4a34	; 0x4a34 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3cf8:	89 81       	ldd	r24, Y+1	; 0x01
    3cfa:	9a 81       	ldd	r25, Y+2	; 0x02
    3cfc:	2e 81       	ldd	r18, Y+6	; 0x06
    3cfe:	3f 81       	ldd	r19, Y+7	; 0x07
    3d00:	4c 85       	ldd	r20, Y+12	; 0x0c
    3d02:	5d 85       	ldd	r21, Y+13	; 0x0d
    3d04:	b9 01       	movw	r22, r18
    3d06:	0e 94 c2 16 	call	0x2d84	; 0x2d84 <pxPortInitialiseStack>
    3d0a:	eb 81       	ldd	r30, Y+3	; 0x03
    3d0c:	fc 81       	ldd	r31, Y+4	; 0x04
    3d0e:	91 83       	std	Z+1, r25	; 0x01
    3d10:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    3d12:	8f 85       	ldd	r24, Y+15	; 0x0f
    3d14:	98 89       	ldd	r25, Y+16	; 0x10
    3d16:	00 97       	sbiw	r24, 0x00	; 0
    3d18:	31 f0       	breq	.+12     	; 0x3d26 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    3d1a:	ef 85       	ldd	r30, Y+15	; 0x0f
    3d1c:	f8 89       	ldd	r31, Y+16	; 0x10
    3d1e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d20:	9c 81       	ldd	r25, Y+4	; 0x04
    3d22:	91 83       	std	Z+1, r25	; 0x01
    3d24:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    3d26:	0f b6       	in	r0, 0x3f	; 63
    3d28:	f8 94       	cli
    3d2a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3d2c:	80 91 95 05 	lds	r24, 0x0595
    3d30:	8f 5f       	subi	r24, 0xFF	; 255
    3d32:	80 93 95 05 	sts	0x0595, r24
			if( pxCurrentTCB == NULL )
    3d36:	80 91 92 05 	lds	r24, 0x0592
    3d3a:	90 91 93 05 	lds	r25, 0x0593
    3d3e:	00 97       	sbiw	r24, 0x00	; 0
    3d40:	69 f4       	brne	.+26     	; 0x3d5c <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    3d42:	8b 81       	ldd	r24, Y+3	; 0x03
    3d44:	9c 81       	ldd	r25, Y+4	; 0x04
    3d46:	90 93 93 05 	sts	0x0593, r25
    3d4a:	80 93 92 05 	sts	0x0592, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    3d4e:	80 91 95 05 	lds	r24, 0x0595
    3d52:	81 30       	cpi	r24, 0x01	; 1
    3d54:	a9 f4       	brne	.+42     	; 0x3d80 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    3d56:	0e 94 71 25 	call	0x4ae2	; 0x4ae2 <prvInitialiseTaskLists>
    3d5a:	12 c0       	rjmp	.+36     	; 0x3d80 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    3d5c:	80 91 9a 05 	lds	r24, 0x059A
    3d60:	88 23       	and	r24, r24
    3d62:	71 f4       	brne	.+28     	; 0x3d80 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    3d64:	e0 91 92 05 	lds	r30, 0x0592
    3d68:	f0 91 93 05 	lds	r31, 0x0593
    3d6c:	96 89       	ldd	r25, Z+22	; 0x16
    3d6e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3d70:	89 17       	cp	r24, r25
    3d72:	30 f0       	brcs	.+12     	; 0x3d80 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    3d74:	8b 81       	ldd	r24, Y+3	; 0x03
    3d76:	9c 81       	ldd	r25, Y+4	; 0x04
    3d78:	90 93 93 05 	sts	0x0593, r25
    3d7c:	80 93 92 05 	sts	0x0592, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    3d80:	eb 81       	ldd	r30, Y+3	; 0x03
    3d82:	fc 81       	ldd	r31, Y+4	; 0x04
    3d84:	96 89       	ldd	r25, Z+22	; 0x16
    3d86:	80 91 98 05 	lds	r24, 0x0598
    3d8a:	89 17       	cp	r24, r25
    3d8c:	28 f4       	brcc	.+10     	; 0x3d98 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    3d8e:	eb 81       	ldd	r30, Y+3	; 0x03
    3d90:	fc 81       	ldd	r31, Y+4	; 0x04
    3d92:	86 89       	ldd	r24, Z+22	; 0x16
    3d94:	80 93 98 05 	sts	0x0598, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    3d98:	80 91 9f 05 	lds	r24, 0x059F
    3d9c:	8f 5f       	subi	r24, 0xFF	; 255
    3d9e:	80 93 9f 05 	sts	0x059F, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    3da2:	eb 81       	ldd	r30, Y+3	; 0x03
    3da4:	fc 81       	ldd	r31, Y+4	; 0x04
    3da6:	96 89       	ldd	r25, Z+22	; 0x16
    3da8:	80 91 99 05 	lds	r24, 0x0599
    3dac:	89 17       	cp	r24, r25
    3dae:	28 f4       	brcc	.+10     	; 0x3dba <xTaskGenericCreate+0x152>
    3db0:	eb 81       	ldd	r30, Y+3	; 0x03
    3db2:	fc 81       	ldd	r31, Y+4	; 0x04
    3db4:	86 89       	ldd	r24, Z+22	; 0x16
    3db6:	80 93 99 05 	sts	0x0599, r24
    3dba:	eb 81       	ldd	r30, Y+3	; 0x03
    3dbc:	fc 81       	ldd	r31, Y+4	; 0x04
    3dbe:	86 89       	ldd	r24, Z+22	; 0x16
    3dc0:	28 2f       	mov	r18, r24
    3dc2:	30 e0       	ldi	r19, 0x00	; 0
    3dc4:	c9 01       	movw	r24, r18
    3dc6:	88 0f       	add	r24, r24
    3dc8:	99 1f       	adc	r25, r25
    3dca:	88 0f       	add	r24, r24
    3dcc:	99 1f       	adc	r25, r25
    3dce:	88 0f       	add	r24, r24
    3dd0:	99 1f       	adc	r25, r25
    3dd2:	82 0f       	add	r24, r18
    3dd4:	93 1f       	adc	r25, r19
    3dd6:	ac 01       	movw	r20, r24
    3dd8:	40 56       	subi	r20, 0x60	; 96
    3dda:	5a 4f       	sbci	r21, 0xFA	; 250
    3ddc:	8b 81       	ldd	r24, Y+3	; 0x03
    3dde:	9c 81       	ldd	r25, Y+4	; 0x04
    3de0:	9c 01       	movw	r18, r24
    3de2:	2e 5f       	subi	r18, 0xFE	; 254
    3de4:	3f 4f       	sbci	r19, 0xFF	; 255
    3de6:	ca 01       	movw	r24, r20
    3de8:	b9 01       	movw	r22, r18
    3dea:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>

			xReturn = pdPASS;
    3dee:	81 e0       	ldi	r24, 0x01	; 1
    3df0:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    3df2:	0f 90       	pop	r0
    3df4:	0f be       	out	0x3f, r0	; 63
    3df6:	02 c0       	rjmp	.+4      	; 0x3dfc <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3df8:	8f ef       	ldi	r24, 0xFF	; 255
    3dfa:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    3dfc:	8d 81       	ldd	r24, Y+5	; 0x05
    3dfe:	81 30       	cpi	r24, 0x01	; 1
    3e00:	71 f4       	brne	.+28     	; 0x3e1e <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    3e02:	80 91 9a 05 	lds	r24, 0x059A
    3e06:	88 23       	and	r24, r24
    3e08:	51 f0       	breq	.+20     	; 0x3e1e <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    3e0a:	e0 91 92 05 	lds	r30, 0x0592
    3e0e:	f0 91 93 05 	lds	r31, 0x0593
    3e12:	96 89       	ldd	r25, Z+22	; 0x16
    3e14:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e16:	98 17       	cp	r25, r24
    3e18:	10 f4       	brcc	.+4      	; 0x3e1e <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    3e1a:	0e 94 81 18 	call	0x3102	; 0x3102 <vPortYield>
			}
		}
	}

	return xReturn;
    3e1e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3e20:	64 96       	adiw	r28, 0x14	; 20
    3e22:	0f b6       	in	r0, 0x3f	; 63
    3e24:	f8 94       	cli
    3e26:	de bf       	out	0x3e, r29	; 62
    3e28:	0f be       	out	0x3f, r0	; 63
    3e2a:	cd bf       	out	0x3d, r28	; 61
    3e2c:	cf 91       	pop	r28
    3e2e:	df 91       	pop	r29
    3e30:	1f 91       	pop	r17
    3e32:	0f 91       	pop	r16
    3e34:	ff 90       	pop	r15
    3e36:	ef 90       	pop	r14
    3e38:	df 90       	pop	r13
    3e3a:	cf 90       	pop	r12
    3e3c:	bf 90       	pop	r11
    3e3e:	af 90       	pop	r10
    3e40:	08 95       	ret

00003e42 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    3e42:	df 93       	push	r29
    3e44:	cf 93       	push	r28
    3e46:	00 d0       	rcall	.+0      	; 0x3e48 <vTaskDelete+0x6>
    3e48:	00 d0       	rcall	.+0      	; 0x3e4a <vTaskDelete+0x8>
    3e4a:	00 d0       	rcall	.+0      	; 0x3e4c <vTaskDelete+0xa>
    3e4c:	cd b7       	in	r28, 0x3d	; 61
    3e4e:	de b7       	in	r29, 0x3e	; 62
    3e50:	9c 83       	std	Y+4, r25	; 0x04
    3e52:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    3e54:	0f b6       	in	r0, 0x3f	; 63
    3e56:	f8 94       	cli
    3e58:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    3e5a:	20 91 92 05 	lds	r18, 0x0592
    3e5e:	30 91 93 05 	lds	r19, 0x0593
    3e62:	8b 81       	ldd	r24, Y+3	; 0x03
    3e64:	9c 81       	ldd	r25, Y+4	; 0x04
    3e66:	82 17       	cp	r24, r18
    3e68:	93 07       	cpc	r25, r19
    3e6a:	11 f4       	brne	.+4      	; 0x3e70 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    3e6c:	1c 82       	std	Y+4, r1	; 0x04
    3e6e:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    3e70:	8b 81       	ldd	r24, Y+3	; 0x03
    3e72:	9c 81       	ldd	r25, Y+4	; 0x04
    3e74:	00 97       	sbiw	r24, 0x00	; 0
    3e76:	39 f4       	brne	.+14     	; 0x3e86 <vTaskDelete+0x44>
    3e78:	80 91 92 05 	lds	r24, 0x0592
    3e7c:	90 91 93 05 	lds	r25, 0x0593
    3e80:	9e 83       	std	Y+6, r25	; 0x06
    3e82:	8d 83       	std	Y+5, r24	; 0x05
    3e84:	04 c0       	rjmp	.+8      	; 0x3e8e <vTaskDelete+0x4c>
    3e86:	8b 81       	ldd	r24, Y+3	; 0x03
    3e88:	9c 81       	ldd	r25, Y+4	; 0x04
    3e8a:	9e 83       	std	Y+6, r25	; 0x06
    3e8c:	8d 83       	std	Y+5, r24	; 0x05
    3e8e:	8d 81       	ldd	r24, Y+5	; 0x05
    3e90:	9e 81       	ldd	r25, Y+6	; 0x06
    3e92:	9a 83       	std	Y+2, r25	; 0x02
    3e94:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    3e96:	89 81       	ldd	r24, Y+1	; 0x01
    3e98:	9a 81       	ldd	r25, Y+2	; 0x02
    3e9a:	02 96       	adiw	r24, 0x02	; 2
    3e9c:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    3ea0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ea2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ea4:	84 89       	ldd	r24, Z+20	; 0x14
    3ea6:	95 89       	ldd	r25, Z+21	; 0x15
    3ea8:	00 97       	sbiw	r24, 0x00	; 0
    3eaa:	29 f0       	breq	.+10     	; 0x3eb6 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    3eac:	89 81       	ldd	r24, Y+1	; 0x01
    3eae:	9a 81       	ldd	r25, Y+2	; 0x02
    3eb0:	0c 96       	adiw	r24, 0x0c	; 12
    3eb2:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    3eb6:	89 81       	ldd	r24, Y+1	; 0x01
    3eb8:	9a 81       	ldd	r25, Y+2	; 0x02
    3eba:	9c 01       	movw	r18, r24
    3ebc:	2e 5f       	subi	r18, 0xFE	; 254
    3ebe:	3f 4f       	sbci	r19, 0xFF	; 255
    3ec0:	85 ef       	ldi	r24, 0xF5	; 245
    3ec2:	95 e0       	ldi	r25, 0x05	; 5
    3ec4:	b9 01       	movw	r22, r18
    3ec6:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    3eca:	80 91 94 05 	lds	r24, 0x0594
    3ece:	8f 5f       	subi	r24, 0xFF	; 255
    3ed0:	80 93 94 05 	sts	0x0594, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    3ed4:	80 91 9f 05 	lds	r24, 0x059F
    3ed8:	8f 5f       	subi	r24, 0xFF	; 255
    3eda:	80 93 9f 05 	sts	0x059F, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    3ede:	0f 90       	pop	r0
    3ee0:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    3ee2:	80 91 9a 05 	lds	r24, 0x059A
    3ee6:	88 23       	and	r24, r24
    3ee8:	31 f0       	breq	.+12     	; 0x3ef6 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    3eea:	8b 81       	ldd	r24, Y+3	; 0x03
    3eec:	9c 81       	ldd	r25, Y+4	; 0x04
    3eee:	00 97       	sbiw	r24, 0x00	; 0
    3ef0:	11 f4       	brne	.+4      	; 0x3ef6 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    3ef2:	0e 94 81 18 	call	0x3102	; 0x3102 <vPortYield>
			}
		}
	}
    3ef6:	26 96       	adiw	r28, 0x06	; 6
    3ef8:	0f b6       	in	r0, 0x3f	; 63
    3efa:	f8 94       	cli
    3efc:	de bf       	out	0x3e, r29	; 62
    3efe:	0f be       	out	0x3f, r0	; 63
    3f00:	cd bf       	out	0x3d, r28	; 61
    3f02:	cf 91       	pop	r28
    3f04:	df 91       	pop	r29
    3f06:	08 95       	ret

00003f08 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    3f08:	df 93       	push	r29
    3f0a:	cf 93       	push	r28
    3f0c:	cd b7       	in	r28, 0x3d	; 61
    3f0e:	de b7       	in	r29, 0x3e	; 62
    3f10:	28 97       	sbiw	r28, 0x08	; 8
    3f12:	0f b6       	in	r0, 0x3f	; 63
    3f14:	f8 94       	cli
    3f16:	de bf       	out	0x3e, r29	; 62
    3f18:	0f be       	out	0x3f, r0	; 63
    3f1a:	cd bf       	out	0x3d, r28	; 61
    3f1c:	9e 83       	std	Y+6, r25	; 0x06
    3f1e:	8d 83       	std	Y+5, r24	; 0x05
    3f20:	78 87       	std	Y+8, r23	; 0x08
    3f22:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    3f24:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    3f26:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3f2a:	ed 81       	ldd	r30, Y+5	; 0x05
    3f2c:	fe 81       	ldd	r31, Y+6	; 0x06
    3f2e:	20 81       	ld	r18, Z
    3f30:	31 81       	ldd	r19, Z+1	; 0x01
    3f32:	8f 81       	ldd	r24, Y+7	; 0x07
    3f34:	98 85       	ldd	r25, Y+8	; 0x08
    3f36:	82 0f       	add	r24, r18
    3f38:	93 1f       	adc	r25, r19
    3f3a:	9c 83       	std	Y+4, r25	; 0x04
    3f3c:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    3f3e:	ed 81       	ldd	r30, Y+5	; 0x05
    3f40:	fe 81       	ldd	r31, Y+6	; 0x06
    3f42:	20 81       	ld	r18, Z
    3f44:	31 81       	ldd	r19, Z+1	; 0x01
    3f46:	80 91 96 05 	lds	r24, 0x0596
    3f4a:	90 91 97 05 	lds	r25, 0x0597
    3f4e:	82 17       	cp	r24, r18
    3f50:	93 07       	cpc	r25, r19
    3f52:	a8 f4       	brcc	.+42     	; 0x3f7e <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    3f54:	ed 81       	ldd	r30, Y+5	; 0x05
    3f56:	fe 81       	ldd	r31, Y+6	; 0x06
    3f58:	20 81       	ld	r18, Z
    3f5a:	31 81       	ldd	r19, Z+1	; 0x01
    3f5c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f5e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f60:	82 17       	cp	r24, r18
    3f62:	93 07       	cpc	r25, r19
    3f64:	00 f5       	brcc	.+64     	; 0x3fa6 <vTaskDelayUntil+0x9e>
    3f66:	20 91 96 05 	lds	r18, 0x0596
    3f6a:	30 91 97 05 	lds	r19, 0x0597
    3f6e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f70:	9c 81       	ldd	r25, Y+4	; 0x04
    3f72:	28 17       	cp	r18, r24
    3f74:	39 07       	cpc	r19, r25
    3f76:	b8 f4       	brcc	.+46     	; 0x3fa6 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3f78:	81 e0       	ldi	r24, 0x01	; 1
    3f7a:	89 83       	std	Y+1, r24	; 0x01
    3f7c:	14 c0       	rjmp	.+40     	; 0x3fa6 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    3f7e:	ed 81       	ldd	r30, Y+5	; 0x05
    3f80:	fe 81       	ldd	r31, Y+6	; 0x06
    3f82:	20 81       	ld	r18, Z
    3f84:	31 81       	ldd	r19, Z+1	; 0x01
    3f86:	8b 81       	ldd	r24, Y+3	; 0x03
    3f88:	9c 81       	ldd	r25, Y+4	; 0x04
    3f8a:	82 17       	cp	r24, r18
    3f8c:	93 07       	cpc	r25, r19
    3f8e:	48 f0       	brcs	.+18     	; 0x3fa2 <vTaskDelayUntil+0x9a>
    3f90:	20 91 96 05 	lds	r18, 0x0596
    3f94:	30 91 97 05 	lds	r19, 0x0597
    3f98:	8b 81       	ldd	r24, Y+3	; 0x03
    3f9a:	9c 81       	ldd	r25, Y+4	; 0x04
    3f9c:	28 17       	cp	r18, r24
    3f9e:	39 07       	cpc	r19, r25
    3fa0:	10 f4       	brcc	.+4      	; 0x3fa6 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3fa2:	81 e0       	ldi	r24, 0x01	; 1
    3fa4:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3fa6:	ed 81       	ldd	r30, Y+5	; 0x05
    3fa8:	fe 81       	ldd	r31, Y+6	; 0x06
    3faa:	8b 81       	ldd	r24, Y+3	; 0x03
    3fac:	9c 81       	ldd	r25, Y+4	; 0x04
    3fae:	91 83       	std	Z+1, r25	; 0x01
    3fb0:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    3fb2:	89 81       	ldd	r24, Y+1	; 0x01
    3fb4:	88 23       	and	r24, r24
    3fb6:	59 f0       	breq	.+22     	; 0x3fce <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3fb8:	80 91 92 05 	lds	r24, 0x0592
    3fbc:	90 91 93 05 	lds	r25, 0x0593
    3fc0:	02 96       	adiw	r24, 0x02	; 2
    3fc2:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3fc6:	8b 81       	ldd	r24, Y+3	; 0x03
    3fc8:	9c 81       	ldd	r25, Y+4	; 0x04
    3fca:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3fce:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
    3fd2:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3fd4:	8a 81       	ldd	r24, Y+2	; 0x02
    3fd6:	88 23       	and	r24, r24
    3fd8:	11 f4       	brne	.+4      	; 0x3fde <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    3fda:	0e 94 81 18 	call	0x3102	; 0x3102 <vPortYield>
		}
	}
    3fde:	28 96       	adiw	r28, 0x08	; 8
    3fe0:	0f b6       	in	r0, 0x3f	; 63
    3fe2:	f8 94       	cli
    3fe4:	de bf       	out	0x3e, r29	; 62
    3fe6:	0f be       	out	0x3f, r0	; 63
    3fe8:	cd bf       	out	0x3d, r28	; 61
    3fea:	cf 91       	pop	r28
    3fec:	df 91       	pop	r29
    3fee:	08 95       	ret

00003ff0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    3ff0:	df 93       	push	r29
    3ff2:	cf 93       	push	r28
    3ff4:	00 d0       	rcall	.+0      	; 0x3ff6 <vTaskDelay+0x6>
    3ff6:	00 d0       	rcall	.+0      	; 0x3ff8 <vTaskDelay+0x8>
    3ff8:	0f 92       	push	r0
    3ffa:	cd b7       	in	r28, 0x3d	; 61
    3ffc:	de b7       	in	r29, 0x3e	; 62
    3ffe:	9d 83       	std	Y+5, r25	; 0x05
    4000:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    4002:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    4004:	8c 81       	ldd	r24, Y+4	; 0x04
    4006:	9d 81       	ldd	r25, Y+5	; 0x05
    4008:	00 97       	sbiw	r24, 0x00	; 0
    400a:	d1 f0       	breq	.+52     	; 0x4040 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    400c:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    4010:	20 91 96 05 	lds	r18, 0x0596
    4014:	30 91 97 05 	lds	r19, 0x0597
    4018:	8c 81       	ldd	r24, Y+4	; 0x04
    401a:	9d 81       	ldd	r25, Y+5	; 0x05
    401c:	82 0f       	add	r24, r18
    401e:	93 1f       	adc	r25, r19
    4020:	9b 83       	std	Y+3, r25	; 0x03
    4022:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4024:	80 91 92 05 	lds	r24, 0x0592
    4028:	90 91 93 05 	lds	r25, 0x0593
    402c:	02 96       	adiw	r24, 0x02	; 2
    402e:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4032:	8a 81       	ldd	r24, Y+2	; 0x02
    4034:	9b 81       	ldd	r25, Y+3	; 0x03
    4036:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    403a:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>
    403e:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4040:	89 81       	ldd	r24, Y+1	; 0x01
    4042:	88 23       	and	r24, r24
    4044:	11 f4       	brne	.+4      	; 0x404a <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    4046:	0e 94 81 18 	call	0x3102	; 0x3102 <vPortYield>
		}
	}
    404a:	0f 90       	pop	r0
    404c:	0f 90       	pop	r0
    404e:	0f 90       	pop	r0
    4050:	0f 90       	pop	r0
    4052:	0f 90       	pop	r0
    4054:	cf 91       	pop	r28
    4056:	df 91       	pop	r29
    4058:	08 95       	ret

0000405a <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    405a:	df 93       	push	r29
    405c:	cf 93       	push	r28
    405e:	00 d0       	rcall	.+0      	; 0x4060 <vTaskSuspend+0x6>
    4060:	00 d0       	rcall	.+0      	; 0x4062 <vTaskSuspend+0x8>
    4062:	00 d0       	rcall	.+0      	; 0x4064 <vTaskSuspend+0xa>
    4064:	cd b7       	in	r28, 0x3d	; 61
    4066:	de b7       	in	r29, 0x3e	; 62
    4068:	9c 83       	std	Y+4, r25	; 0x04
    406a:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    406c:	0f b6       	in	r0, 0x3f	; 63
    406e:	f8 94       	cli
    4070:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    4072:	20 91 92 05 	lds	r18, 0x0592
    4076:	30 91 93 05 	lds	r19, 0x0593
    407a:	8b 81       	ldd	r24, Y+3	; 0x03
    407c:	9c 81       	ldd	r25, Y+4	; 0x04
    407e:	82 17       	cp	r24, r18
    4080:	93 07       	cpc	r25, r19
    4082:	11 f4       	brne	.+4      	; 0x4088 <vTaskSuspend+0x2e>
			{
				pxTaskToSuspend = NULL;
    4084:	1c 82       	std	Y+4, r1	; 0x04
    4086:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    4088:	8b 81       	ldd	r24, Y+3	; 0x03
    408a:	9c 81       	ldd	r25, Y+4	; 0x04
    408c:	00 97       	sbiw	r24, 0x00	; 0
    408e:	39 f4       	brne	.+14     	; 0x409e <vTaskSuspend+0x44>
    4090:	80 91 92 05 	lds	r24, 0x0592
    4094:	90 91 93 05 	lds	r25, 0x0593
    4098:	9e 83       	std	Y+6, r25	; 0x06
    409a:	8d 83       	std	Y+5, r24	; 0x05
    409c:	04 c0       	rjmp	.+8      	; 0x40a6 <vTaskSuspend+0x4c>
    409e:	8b 81       	ldd	r24, Y+3	; 0x03
    40a0:	9c 81       	ldd	r25, Y+4	; 0x04
    40a2:	9e 83       	std	Y+6, r25	; 0x06
    40a4:	8d 83       	std	Y+5, r24	; 0x05
    40a6:	8d 81       	ldd	r24, Y+5	; 0x05
    40a8:	9e 81       	ldd	r25, Y+6	; 0x06
    40aa:	9a 83       	std	Y+2, r25	; 0x02
    40ac:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    40ae:	89 81       	ldd	r24, Y+1	; 0x01
    40b0:	9a 81       	ldd	r25, Y+2	; 0x02
    40b2:	02 96       	adiw	r24, 0x02	; 2
    40b4:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    40b8:	e9 81       	ldd	r30, Y+1	; 0x01
    40ba:	fa 81       	ldd	r31, Y+2	; 0x02
    40bc:	84 89       	ldd	r24, Z+20	; 0x14
    40be:	95 89       	ldd	r25, Z+21	; 0x15
    40c0:	00 97       	sbiw	r24, 0x00	; 0
    40c2:	29 f0       	breq	.+10     	; 0x40ce <vTaskSuspend+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    40c4:	89 81       	ldd	r24, Y+1	; 0x01
    40c6:	9a 81       	ldd	r25, Y+2	; 0x02
    40c8:	0c 96       	adiw	r24, 0x0c	; 12
    40ca:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    40ce:	89 81       	ldd	r24, Y+1	; 0x01
    40d0:	9a 81       	ldd	r25, Y+2	; 0x02
    40d2:	9c 01       	movw	r18, r24
    40d4:	2e 5f       	subi	r18, 0xFE	; 254
    40d6:	3f 4f       	sbci	r19, 0xFF	; 255
    40d8:	8e ef       	ldi	r24, 0xFE	; 254
    40da:	95 e0       	ldi	r25, 0x05	; 5
    40dc:	b9 01       	movw	r22, r18
    40de:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    40e2:	0f 90       	pop	r0
    40e4:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    40e6:	8b 81       	ldd	r24, Y+3	; 0x03
    40e8:	9c 81       	ldd	r25, Y+4	; 0x04
    40ea:	00 97       	sbiw	r24, 0x00	; 0
    40ec:	a1 f4       	brne	.+40     	; 0x4116 <vTaskSuspend+0xbc>
		{
			if( xSchedulerRunning != pdFALSE )
    40ee:	80 91 9a 05 	lds	r24, 0x059A
    40f2:	88 23       	and	r24, r24
    40f4:	19 f0       	breq	.+6      	; 0x40fc <vTaskSuspend+0xa2>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    40f6:	0e 94 81 18 	call	0x3102	; 0x3102 <vPortYield>
    40fa:	0d c0       	rjmp	.+26     	; 0x4116 <vTaskSuspend+0xbc>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    40fc:	90 91 fe 05 	lds	r25, 0x05FE
    4100:	80 91 95 05 	lds	r24, 0x0595
    4104:	98 17       	cp	r25, r24
    4106:	29 f4       	brne	.+10     	; 0x4112 <vTaskSuspend+0xb8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    4108:	10 92 93 05 	sts	0x0593, r1
    410c:	10 92 92 05 	sts	0x0592, r1
    4110:	02 c0       	rjmp	.+4      	; 0x4116 <vTaskSuspend+0xbc>
				}
				else
				{
					vTaskSwitchContext();
    4112:	0e 94 6f 23 	call	0x46de	; 0x46de <vTaskSwitchContext>
				}
			}
		}
	}
    4116:	26 96       	adiw	r28, 0x06	; 6
    4118:	0f b6       	in	r0, 0x3f	; 63
    411a:	f8 94       	cli
    411c:	de bf       	out	0x3e, r29	; 62
    411e:	0f be       	out	0x3f, r0	; 63
    4120:	cd bf       	out	0x3d, r28	; 61
    4122:	cf 91       	pop	r28
    4124:	df 91       	pop	r29
    4126:	08 95       	ret

00004128 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    4128:	df 93       	push	r29
    412a:	cf 93       	push	r28
    412c:	00 d0       	rcall	.+0      	; 0x412e <xTaskIsTaskSuspended+0x6>
    412e:	00 d0       	rcall	.+0      	; 0x4130 <xTaskIsTaskSuspended+0x8>
    4130:	0f 92       	push	r0
    4132:	cd b7       	in	r28, 0x3d	; 61
    4134:	de b7       	in	r29, 0x3e	; 62
    4136:	9d 83       	std	Y+5, r25	; 0x05
    4138:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
    413a:	1b 82       	std	Y+3, r1	; 0x03
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    413c:	8c 81       	ldd	r24, Y+4	; 0x04
    413e:	9d 81       	ldd	r25, Y+5	; 0x05
    4140:	9a 83       	std	Y+2, r25	; 0x02
    4142:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    4144:	e9 81       	ldd	r30, Y+1	; 0x01
    4146:	fa 81       	ldd	r31, Y+2	; 0x02
    4148:	82 85       	ldd	r24, Z+10	; 0x0a
    414a:	93 85       	ldd	r25, Z+11	; 0x0b
    414c:	25 e0       	ldi	r18, 0x05	; 5
    414e:	8e 3f       	cpi	r24, 0xFE	; 254
    4150:	92 07       	cpc	r25, r18
    4152:	81 f4       	brne	.+32     	; 0x4174 <xTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    4154:	e9 81       	ldd	r30, Y+1	; 0x01
    4156:	fa 81       	ldd	r31, Y+2	; 0x02
    4158:	84 89       	ldd	r24, Z+20	; 0x14
    415a:	95 89       	ldd	r25, Z+21	; 0x15
    415c:	25 e0       	ldi	r18, 0x05	; 5
    415e:	8c 3e       	cpi	r24, 0xEC	; 236
    4160:	92 07       	cpc	r25, r18
    4162:	41 f0       	breq	.+16     	; 0x4174 <xTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    4164:	e9 81       	ldd	r30, Y+1	; 0x01
    4166:	fa 81       	ldd	r31, Y+2	; 0x02
    4168:	84 89       	ldd	r24, Z+20	; 0x14
    416a:	95 89       	ldd	r25, Z+21	; 0x15
    416c:	00 97       	sbiw	r24, 0x00	; 0
    416e:	11 f4       	brne	.+4      	; 0x4174 <xTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    4170:	81 e0       	ldi	r24, 0x01	; 1
    4172:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}

		return xReturn;
    4174:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4176:	0f 90       	pop	r0
    4178:	0f 90       	pop	r0
    417a:	0f 90       	pop	r0
    417c:	0f 90       	pop	r0
    417e:	0f 90       	pop	r0
    4180:	cf 91       	pop	r28
    4182:	df 91       	pop	r29
    4184:	08 95       	ret

00004186 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    4186:	df 93       	push	r29
    4188:	cf 93       	push	r28
    418a:	00 d0       	rcall	.+0      	; 0x418c <vTaskResume+0x6>
    418c:	00 d0       	rcall	.+0      	; 0x418e <vTaskResume+0x8>
    418e:	cd b7       	in	r28, 0x3d	; 61
    4190:	de b7       	in	r29, 0x3e	; 62
    4192:	9c 83       	std	Y+4, r25	; 0x04
    4194:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    4196:	8b 81       	ldd	r24, Y+3	; 0x03
    4198:	9c 81       	ldd	r25, Y+4	; 0x04
    419a:	9a 83       	std	Y+2, r25	; 0x02
    419c:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    419e:	89 81       	ldd	r24, Y+1	; 0x01
    41a0:	9a 81       	ldd	r25, Y+2	; 0x02
    41a2:	00 97       	sbiw	r24, 0x00	; 0
    41a4:	09 f4       	brne	.+2      	; 0x41a8 <vTaskResume+0x22>
    41a6:	4c c0       	rjmp	.+152    	; 0x4240 <vTaskResume+0xba>
    41a8:	20 91 92 05 	lds	r18, 0x0592
    41ac:	30 91 93 05 	lds	r19, 0x0593
    41b0:	89 81       	ldd	r24, Y+1	; 0x01
    41b2:	9a 81       	ldd	r25, Y+2	; 0x02
    41b4:	82 17       	cp	r24, r18
    41b6:	93 07       	cpc	r25, r19
    41b8:	09 f4       	brne	.+2      	; 0x41bc <vTaskResume+0x36>
    41ba:	42 c0       	rjmp	.+132    	; 0x4240 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    41bc:	0f b6       	in	r0, 0x3f	; 63
    41be:	f8 94       	cli
    41c0:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    41c2:	89 81       	ldd	r24, Y+1	; 0x01
    41c4:	9a 81       	ldd	r25, Y+2	; 0x02
    41c6:	0e 94 94 20 	call	0x4128	; 0x4128 <xTaskIsTaskSuspended>
    41ca:	81 30       	cpi	r24, 0x01	; 1
    41cc:	b9 f5       	brne	.+110    	; 0x423c <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    41ce:	89 81       	ldd	r24, Y+1	; 0x01
    41d0:	9a 81       	ldd	r25, Y+2	; 0x02
    41d2:	02 96       	adiw	r24, 0x02	; 2
    41d4:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    41d8:	e9 81       	ldd	r30, Y+1	; 0x01
    41da:	fa 81       	ldd	r31, Y+2	; 0x02
    41dc:	96 89       	ldd	r25, Z+22	; 0x16
    41de:	80 91 99 05 	lds	r24, 0x0599
    41e2:	89 17       	cp	r24, r25
    41e4:	28 f4       	brcc	.+10     	; 0x41f0 <vTaskResume+0x6a>
    41e6:	e9 81       	ldd	r30, Y+1	; 0x01
    41e8:	fa 81       	ldd	r31, Y+2	; 0x02
    41ea:	86 89       	ldd	r24, Z+22	; 0x16
    41ec:	80 93 99 05 	sts	0x0599, r24
    41f0:	e9 81       	ldd	r30, Y+1	; 0x01
    41f2:	fa 81       	ldd	r31, Y+2	; 0x02
    41f4:	86 89       	ldd	r24, Z+22	; 0x16
    41f6:	28 2f       	mov	r18, r24
    41f8:	30 e0       	ldi	r19, 0x00	; 0
    41fa:	c9 01       	movw	r24, r18
    41fc:	88 0f       	add	r24, r24
    41fe:	99 1f       	adc	r25, r25
    4200:	88 0f       	add	r24, r24
    4202:	99 1f       	adc	r25, r25
    4204:	88 0f       	add	r24, r24
    4206:	99 1f       	adc	r25, r25
    4208:	82 0f       	add	r24, r18
    420a:	93 1f       	adc	r25, r19
    420c:	ac 01       	movw	r20, r24
    420e:	40 56       	subi	r20, 0x60	; 96
    4210:	5a 4f       	sbci	r21, 0xFA	; 250
    4212:	89 81       	ldd	r24, Y+1	; 0x01
    4214:	9a 81       	ldd	r25, Y+2	; 0x02
    4216:	9c 01       	movw	r18, r24
    4218:	2e 5f       	subi	r18, 0xFE	; 254
    421a:	3f 4f       	sbci	r19, 0xFF	; 255
    421c:	ca 01       	movw	r24, r20
    421e:	b9 01       	movw	r22, r18
    4220:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4224:	e9 81       	ldd	r30, Y+1	; 0x01
    4226:	fa 81       	ldd	r31, Y+2	; 0x02
    4228:	96 89       	ldd	r25, Z+22	; 0x16
    422a:	e0 91 92 05 	lds	r30, 0x0592
    422e:	f0 91 93 05 	lds	r31, 0x0593
    4232:	86 89       	ldd	r24, Z+22	; 0x16
    4234:	98 17       	cp	r25, r24
    4236:	10 f0       	brcs	.+4      	; 0x423c <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    4238:	0e 94 81 18 	call	0x3102	; 0x3102 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    423c:	0f 90       	pop	r0
    423e:	0f be       	out	0x3f, r0	; 63
		}
	}
    4240:	0f 90       	pop	r0
    4242:	0f 90       	pop	r0
    4244:	0f 90       	pop	r0
    4246:	0f 90       	pop	r0
    4248:	cf 91       	pop	r28
    424a:	df 91       	pop	r29
    424c:	08 95       	ret

0000424e <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    424e:	df 93       	push	r29
    4250:	cf 93       	push	r28
    4252:	00 d0       	rcall	.+0      	; 0x4254 <xTaskResumeFromISR+0x6>
    4254:	00 d0       	rcall	.+0      	; 0x4256 <xTaskResumeFromISR+0x8>
    4256:	0f 92       	push	r0
    4258:	cd b7       	in	r28, 0x3d	; 61
    425a:	de b7       	in	r29, 0x3e	; 62
    425c:	9d 83       	std	Y+5, r25	; 0x05
    425e:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xYieldRequired = pdFALSE;
    4260:	1b 82       	std	Y+3, r1	; 0x03
	tskTCB *pxTCB;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
    4262:	8c 81       	ldd	r24, Y+4	; 0x04
    4264:	9d 81       	ldd	r25, Y+5	; 0x05
    4266:	9a 83       	std	Y+2, r25	; 0x02
    4268:	89 83       	std	Y+1, r24	; 0x01

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    426a:	89 81       	ldd	r24, Y+1	; 0x01
    426c:	9a 81       	ldd	r25, Y+2	; 0x02
    426e:	0e 94 94 20 	call	0x4128	; 0x4128 <xTaskIsTaskSuspended>
    4272:	81 30       	cpi	r24, 0x01	; 1
    4274:	09 f0       	breq	.+2      	; 0x4278 <xTaskResumeFromISR+0x2a>
    4276:	47 c0       	rjmp	.+142    	; 0x4306 <xTaskResumeFromISR+0xb8>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4278:	80 91 9b 05 	lds	r24, 0x059B
    427c:	88 23       	and	r24, r24
    427e:	c9 f5       	brne	.+114    	; 0x42f2 <xTaskResumeFromISR+0xa4>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    4280:	e9 81       	ldd	r30, Y+1	; 0x01
    4282:	fa 81       	ldd	r31, Y+2	; 0x02
    4284:	96 89       	ldd	r25, Z+22	; 0x16
    4286:	e0 91 92 05 	lds	r30, 0x0592
    428a:	f0 91 93 05 	lds	r31, 0x0593
    428e:	86 89       	ldd	r24, Z+22	; 0x16
    4290:	1b 82       	std	Y+3, r1	; 0x03
    4292:	98 17       	cp	r25, r24
    4294:	10 f0       	brcs	.+4      	; 0x429a <xTaskResumeFromISR+0x4c>
    4296:	81 e0       	ldi	r24, 0x01	; 1
    4298:	8b 83       	std	Y+3, r24	; 0x03
				vListRemove(  &( pxTCB->xGenericListItem ) );
    429a:	89 81       	ldd	r24, Y+1	; 0x01
    429c:	9a 81       	ldd	r25, Y+2	; 0x02
    429e:	02 96       	adiw	r24, 0x02	; 2
    42a0:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    42a4:	e9 81       	ldd	r30, Y+1	; 0x01
    42a6:	fa 81       	ldd	r31, Y+2	; 0x02
    42a8:	96 89       	ldd	r25, Z+22	; 0x16
    42aa:	80 91 99 05 	lds	r24, 0x0599
    42ae:	89 17       	cp	r24, r25
    42b0:	28 f4       	brcc	.+10     	; 0x42bc <xTaskResumeFromISR+0x6e>
    42b2:	e9 81       	ldd	r30, Y+1	; 0x01
    42b4:	fa 81       	ldd	r31, Y+2	; 0x02
    42b6:	86 89       	ldd	r24, Z+22	; 0x16
    42b8:	80 93 99 05 	sts	0x0599, r24
    42bc:	e9 81       	ldd	r30, Y+1	; 0x01
    42be:	fa 81       	ldd	r31, Y+2	; 0x02
    42c0:	86 89       	ldd	r24, Z+22	; 0x16
    42c2:	28 2f       	mov	r18, r24
    42c4:	30 e0       	ldi	r19, 0x00	; 0
    42c6:	c9 01       	movw	r24, r18
    42c8:	88 0f       	add	r24, r24
    42ca:	99 1f       	adc	r25, r25
    42cc:	88 0f       	add	r24, r24
    42ce:	99 1f       	adc	r25, r25
    42d0:	88 0f       	add	r24, r24
    42d2:	99 1f       	adc	r25, r25
    42d4:	82 0f       	add	r24, r18
    42d6:	93 1f       	adc	r25, r19
    42d8:	ac 01       	movw	r20, r24
    42da:	40 56       	subi	r20, 0x60	; 96
    42dc:	5a 4f       	sbci	r21, 0xFA	; 250
    42de:	89 81       	ldd	r24, Y+1	; 0x01
    42e0:	9a 81       	ldd	r25, Y+2	; 0x02
    42e2:	9c 01       	movw	r18, r24
    42e4:	2e 5f       	subi	r18, 0xFE	; 254
    42e6:	3f 4f       	sbci	r19, 0xFF	; 255
    42e8:	ca 01       	movw	r24, r20
    42ea:	b9 01       	movw	r22, r18
    42ec:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>
    42f0:	0a c0       	rjmp	.+20     	; 0x4306 <xTaskResumeFromISR+0xb8>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    42f2:	89 81       	ldd	r24, Y+1	; 0x01
    42f4:	9a 81       	ldd	r25, Y+2	; 0x02
    42f6:	9c 01       	movw	r18, r24
    42f8:	24 5f       	subi	r18, 0xF4	; 244
    42fa:	3f 4f       	sbci	r19, 0xFF	; 255
    42fc:	8c ee       	ldi	r24, 0xEC	; 236
    42fe:	95 e0       	ldi	r25, 0x05	; 5
    4300:	b9 01       	movw	r22, r18
    4302:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>
			}
		}

		return xYieldRequired;
    4306:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4308:	0f 90       	pop	r0
    430a:	0f 90       	pop	r0
    430c:	0f 90       	pop	r0
    430e:	0f 90       	pop	r0
    4310:	0f 90       	pop	r0
    4312:	cf 91       	pop	r28
    4314:	df 91       	pop	r29
    4316:	08 95       	ret

00004318 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    4318:	af 92       	push	r10
    431a:	bf 92       	push	r11
    431c:	cf 92       	push	r12
    431e:	df 92       	push	r13
    4320:	ef 92       	push	r14
    4322:	ff 92       	push	r15
    4324:	0f 93       	push	r16
    4326:	df 93       	push	r29
    4328:	cf 93       	push	r28
    432a:	0f 92       	push	r0
    432c:	cd b7       	in	r28, 0x3d	; 61
    432e:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    4330:	20 e6       	ldi	r18, 0x60	; 96
    4332:	30 e0       	ldi	r19, 0x00	; 0
    4334:	80 e1       	ldi	r24, 0x10	; 16
    4336:	95 e2       	ldi	r25, 0x25	; 37
    4338:	b9 01       	movw	r22, r18
    433a:	4a ef       	ldi	r20, 0xFA	; 250
    433c:	50 e0       	ldi	r21, 0x00	; 0
    433e:	20 e0       	ldi	r18, 0x00	; 0
    4340:	30 e0       	ldi	r19, 0x00	; 0
    4342:	00 e0       	ldi	r16, 0x00	; 0
    4344:	ee 24       	eor	r14, r14
    4346:	ff 24       	eor	r15, r15
    4348:	cc 24       	eor	r12, r12
    434a:	dd 24       	eor	r13, r13
    434c:	aa 24       	eor	r10, r10
    434e:	bb 24       	eor	r11, r11
    4350:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskGenericCreate>
    4354:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    4356:	89 81       	ldd	r24, Y+1	; 0x01
    4358:	81 30       	cpi	r24, 0x01	; 1
    435a:	51 f4       	brne	.+20     	; 0x4370 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    435c:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    435e:	81 e0       	ldi	r24, 0x01	; 1
    4360:	80 93 9a 05 	sts	0x059A, r24
		xTickCount = ( portTickType ) 0U;
    4364:	10 92 97 05 	sts	0x0597, r1
    4368:	10 92 96 05 	sts	0x0596, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    436c:	0e 94 45 18 	call	0x308a	; 0x308a <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    4370:	0f 90       	pop	r0
    4372:	cf 91       	pop	r28
    4374:	df 91       	pop	r29
    4376:	0f 91       	pop	r16
    4378:	ff 90       	pop	r15
    437a:	ef 90       	pop	r14
    437c:	df 90       	pop	r13
    437e:	cf 90       	pop	r12
    4380:	bf 90       	pop	r11
    4382:	af 90       	pop	r10
    4384:	08 95       	ret

00004386 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4386:	df 93       	push	r29
    4388:	cf 93       	push	r28
    438a:	cd b7       	in	r28, 0x3d	; 61
    438c:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    438e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4390:	10 92 9a 05 	sts	0x059A, r1
	vPortEndScheduler();
    4394:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <vPortEndScheduler>
}
    4398:	cf 91       	pop	r28
    439a:	df 91       	pop	r29
    439c:	08 95       	ret

0000439e <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    439e:	df 93       	push	r29
    43a0:	cf 93       	push	r28
    43a2:	cd b7       	in	r28, 0x3d	; 61
    43a4:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    43a6:	80 91 9b 05 	lds	r24, 0x059B
    43aa:	8f 5f       	subi	r24, 0xFF	; 255
    43ac:	80 93 9b 05 	sts	0x059B, r24
}
    43b0:	cf 91       	pop	r28
    43b2:	df 91       	pop	r29
    43b4:	08 95       	ret

000043b6 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    43b6:	df 93       	push	r29
    43b8:	cf 93       	push	r28
    43ba:	00 d0       	rcall	.+0      	; 0x43bc <xTaskResumeAll+0x6>
    43bc:	00 d0       	rcall	.+0      	; 0x43be <xTaskResumeAll+0x8>
    43be:	cd b7       	in	r28, 0x3d	; 61
    43c0:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    43c2:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    43c4:	0f b6       	in	r0, 0x3f	; 63
    43c6:	f8 94       	cli
    43c8:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    43ca:	80 91 9b 05 	lds	r24, 0x059B
    43ce:	81 50       	subi	r24, 0x01	; 1
    43d0:	80 93 9b 05 	sts	0x059B, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    43d4:	80 91 9b 05 	lds	r24, 0x059B
    43d8:	88 23       	and	r24, r24
    43da:	09 f0       	breq	.+2      	; 0x43de <xTaskResumeAll+0x28>
    43dc:	6c c0       	rjmp	.+216    	; 0x44b6 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    43de:	80 91 95 05 	lds	r24, 0x0595
    43e2:	88 23       	and	r24, r24
    43e4:	09 f4       	brne	.+2      	; 0x43e8 <xTaskResumeAll+0x32>
    43e6:	67 c0       	rjmp	.+206    	; 0x44b6 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    43e8:	19 82       	std	Y+1, r1	; 0x01
    43ea:	41 c0       	rjmp	.+130    	; 0x446e <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    43ec:	e0 91 f1 05 	lds	r30, 0x05F1
    43f0:	f0 91 f2 05 	lds	r31, 0x05F2
    43f4:	86 81       	ldd	r24, Z+6	; 0x06
    43f6:	97 81       	ldd	r25, Z+7	; 0x07
    43f8:	9c 83       	std	Y+4, r25	; 0x04
    43fa:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    43fc:	8b 81       	ldd	r24, Y+3	; 0x03
    43fe:	9c 81       	ldd	r25, Y+4	; 0x04
    4400:	0c 96       	adiw	r24, 0x0c	; 12
    4402:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    4406:	8b 81       	ldd	r24, Y+3	; 0x03
    4408:	9c 81       	ldd	r25, Y+4	; 0x04
    440a:	02 96       	adiw	r24, 0x02	; 2
    440c:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    4410:	eb 81       	ldd	r30, Y+3	; 0x03
    4412:	fc 81       	ldd	r31, Y+4	; 0x04
    4414:	96 89       	ldd	r25, Z+22	; 0x16
    4416:	80 91 99 05 	lds	r24, 0x0599
    441a:	89 17       	cp	r24, r25
    441c:	28 f4       	brcc	.+10     	; 0x4428 <xTaskResumeAll+0x72>
    441e:	eb 81       	ldd	r30, Y+3	; 0x03
    4420:	fc 81       	ldd	r31, Y+4	; 0x04
    4422:	86 89       	ldd	r24, Z+22	; 0x16
    4424:	80 93 99 05 	sts	0x0599, r24
    4428:	eb 81       	ldd	r30, Y+3	; 0x03
    442a:	fc 81       	ldd	r31, Y+4	; 0x04
    442c:	86 89       	ldd	r24, Z+22	; 0x16
    442e:	28 2f       	mov	r18, r24
    4430:	30 e0       	ldi	r19, 0x00	; 0
    4432:	c9 01       	movw	r24, r18
    4434:	88 0f       	add	r24, r24
    4436:	99 1f       	adc	r25, r25
    4438:	88 0f       	add	r24, r24
    443a:	99 1f       	adc	r25, r25
    443c:	88 0f       	add	r24, r24
    443e:	99 1f       	adc	r25, r25
    4440:	82 0f       	add	r24, r18
    4442:	93 1f       	adc	r25, r19
    4444:	80 56       	subi	r24, 0x60	; 96
    4446:	9a 4f       	sbci	r25, 0xFA	; 250
    4448:	2b 81       	ldd	r18, Y+3	; 0x03
    444a:	3c 81       	ldd	r19, Y+4	; 0x04
    444c:	2e 5f       	subi	r18, 0xFE	; 254
    444e:	3f 4f       	sbci	r19, 0xFF	; 255
    4450:	b9 01       	movw	r22, r18
    4452:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4456:	eb 81       	ldd	r30, Y+3	; 0x03
    4458:	fc 81       	ldd	r31, Y+4	; 0x04
    445a:	96 89       	ldd	r25, Z+22	; 0x16
    445c:	e0 91 92 05 	lds	r30, 0x0592
    4460:	f0 91 93 05 	lds	r31, 0x0593
    4464:	86 89       	ldd	r24, Z+22	; 0x16
    4466:	98 17       	cp	r25, r24
    4468:	10 f0       	brcs	.+4      	; 0x446e <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    446a:	81 e0       	ldi	r24, 0x01	; 1
    446c:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    446e:	80 91 ec 05 	lds	r24, 0x05EC
    4472:	88 23       	and	r24, r24
    4474:	09 f0       	breq	.+2      	; 0x4478 <xTaskResumeAll+0xc2>
    4476:	ba cf       	rjmp	.-140    	; 0x43ec <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4478:	80 91 9c 05 	lds	r24, 0x059C
    447c:	88 23       	and	r24, r24
    447e:	71 f0       	breq	.+28     	; 0x449c <xTaskResumeAll+0xe6>
    4480:	07 c0       	rjmp	.+14     	; 0x4490 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    4482:	0e 94 9a 22 	call	0x4534	; 0x4534 <vTaskIncrementTick>
						--uxMissedTicks;
    4486:	80 91 9c 05 	lds	r24, 0x059C
    448a:	81 50       	subi	r24, 0x01	; 1
    448c:	80 93 9c 05 	sts	0x059C, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4490:	80 91 9c 05 	lds	r24, 0x059C
    4494:	88 23       	and	r24, r24
    4496:	a9 f7       	brne	.-22     	; 0x4482 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    4498:	81 e0       	ldi	r24, 0x01	; 1
    449a:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    449c:	89 81       	ldd	r24, Y+1	; 0x01
    449e:	81 30       	cpi	r24, 0x01	; 1
    44a0:	21 f0       	breq	.+8      	; 0x44aa <xTaskResumeAll+0xf4>
    44a2:	80 91 9d 05 	lds	r24, 0x059D
    44a6:	81 30       	cpi	r24, 0x01	; 1
    44a8:	31 f4       	brne	.+12     	; 0x44b6 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    44aa:	81 e0       	ldi	r24, 0x01	; 1
    44ac:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    44ae:	10 92 9d 05 	sts	0x059D, r1
					portYIELD_WITHIN_API();
    44b2:	0e 94 81 18 	call	0x3102	; 0x3102 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    44b6:	0f 90       	pop	r0
    44b8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    44ba:	8a 81       	ldd	r24, Y+2	; 0x02
}
    44bc:	0f 90       	pop	r0
    44be:	0f 90       	pop	r0
    44c0:	0f 90       	pop	r0
    44c2:	0f 90       	pop	r0
    44c4:	cf 91       	pop	r28
    44c6:	df 91       	pop	r29
    44c8:	08 95       	ret

000044ca <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    44ca:	df 93       	push	r29
    44cc:	cf 93       	push	r28
    44ce:	00 d0       	rcall	.+0      	; 0x44d0 <xTaskGetTickCount+0x6>
    44d0:	cd b7       	in	r28, 0x3d	; 61
    44d2:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    44d4:	0f b6       	in	r0, 0x3f	; 63
    44d6:	f8 94       	cli
    44d8:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    44da:	80 91 96 05 	lds	r24, 0x0596
    44de:	90 91 97 05 	lds	r25, 0x0597
    44e2:	9a 83       	std	Y+2, r25	; 0x02
    44e4:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    44e6:	0f 90       	pop	r0
    44e8:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    44ea:	89 81       	ldd	r24, Y+1	; 0x01
    44ec:	9a 81       	ldd	r25, Y+2	; 0x02
}
    44ee:	0f 90       	pop	r0
    44f0:	0f 90       	pop	r0
    44f2:	cf 91       	pop	r28
    44f4:	df 91       	pop	r29
    44f6:	08 95       	ret

000044f8 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    44f8:	df 93       	push	r29
    44fa:	cf 93       	push	r28
    44fc:	00 d0       	rcall	.+0      	; 0x44fe <xTaskGetTickCountFromISR+0x6>
    44fe:	0f 92       	push	r0
    4500:	cd b7       	in	r28, 0x3d	; 61
    4502:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4504:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    4506:	80 91 96 05 	lds	r24, 0x0596
    450a:	90 91 97 05 	lds	r25, 0x0597
    450e:	9b 83       	std	Y+3, r25	; 0x03
    4510:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4512:	8a 81       	ldd	r24, Y+2	; 0x02
    4514:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4516:	0f 90       	pop	r0
    4518:	0f 90       	pop	r0
    451a:	0f 90       	pop	r0
    451c:	cf 91       	pop	r28
    451e:	df 91       	pop	r29
    4520:	08 95       	ret

00004522 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    4522:	df 93       	push	r29
    4524:	cf 93       	push	r28
    4526:	cd b7       	in	r28, 0x3d	; 61
    4528:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    452a:	80 91 95 05 	lds	r24, 0x0595
}
    452e:	cf 91       	pop	r28
    4530:	df 91       	pop	r29
    4532:	08 95       	ret

00004534 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    4534:	df 93       	push	r29
    4536:	cf 93       	push	r28
    4538:	00 d0       	rcall	.+0      	; 0x453a <vTaskIncrementTick+0x6>
    453a:	00 d0       	rcall	.+0      	; 0x453c <vTaskIncrementTick+0x8>
    453c:	00 d0       	rcall	.+0      	; 0x453e <vTaskIncrementTick+0xa>
    453e:	cd b7       	in	r28, 0x3d	; 61
    4540:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4542:	80 91 9b 05 	lds	r24, 0x059B
    4546:	88 23       	and	r24, r24
    4548:	09 f0       	breq	.+2      	; 0x454c <vTaskIncrementTick+0x18>
    454a:	bb c0       	rjmp	.+374    	; 0x46c2 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    454c:	80 91 96 05 	lds	r24, 0x0596
    4550:	90 91 97 05 	lds	r25, 0x0597
    4554:	01 96       	adiw	r24, 0x01	; 1
    4556:	90 93 97 05 	sts	0x0597, r25
    455a:	80 93 96 05 	sts	0x0596, r24
		if( xTickCount == ( portTickType ) 0U )
    455e:	80 91 96 05 	lds	r24, 0x0596
    4562:	90 91 97 05 	lds	r25, 0x0597
    4566:	00 97       	sbiw	r24, 0x00	; 0
    4568:	d1 f5       	brne	.+116    	; 0x45de <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    456a:	80 91 e8 05 	lds	r24, 0x05E8
    456e:	90 91 e9 05 	lds	r25, 0x05E9
    4572:	9c 83       	std	Y+4, r25	; 0x04
    4574:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    4576:	80 91 ea 05 	lds	r24, 0x05EA
    457a:	90 91 eb 05 	lds	r25, 0x05EB
    457e:	90 93 e9 05 	sts	0x05E9, r25
    4582:	80 93 e8 05 	sts	0x05E8, r24
			pxOverflowDelayedTaskList = pxTemp;
    4586:	8b 81       	ldd	r24, Y+3	; 0x03
    4588:	9c 81       	ldd	r25, Y+4	; 0x04
    458a:	90 93 eb 05 	sts	0x05EB, r25
    458e:	80 93 ea 05 	sts	0x05EA, r24
			xNumOfOverflows++;
    4592:	80 91 9e 05 	lds	r24, 0x059E
    4596:	8f 5f       	subi	r24, 0xFF	; 255
    4598:	80 93 9e 05 	sts	0x059E, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    459c:	e0 91 e8 05 	lds	r30, 0x05E8
    45a0:	f0 91 e9 05 	lds	r31, 0x05E9
    45a4:	80 81       	ld	r24, Z
    45a6:	88 23       	and	r24, r24
    45a8:	39 f4       	brne	.+14     	; 0x45b8 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    45aa:	8f ef       	ldi	r24, 0xFF	; 255
    45ac:	9f ef       	ldi	r25, 0xFF	; 255
    45ae:	90 93 a3 00 	sts	0x00A3, r25
    45b2:	80 93 a2 00 	sts	0x00A2, r24
    45b6:	13 c0       	rjmp	.+38     	; 0x45de <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    45b8:	e0 91 e8 05 	lds	r30, 0x05E8
    45bc:	f0 91 e9 05 	lds	r31, 0x05E9
    45c0:	05 80       	ldd	r0, Z+5	; 0x05
    45c2:	f6 81       	ldd	r31, Z+6	; 0x06
    45c4:	e0 2d       	mov	r30, r0
    45c6:	86 81       	ldd	r24, Z+6	; 0x06
    45c8:	97 81       	ldd	r25, Z+7	; 0x07
    45ca:	9e 83       	std	Y+6, r25	; 0x06
    45cc:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    45ce:	ed 81       	ldd	r30, Y+5	; 0x05
    45d0:	fe 81       	ldd	r31, Y+6	; 0x06
    45d2:	82 81       	ldd	r24, Z+2	; 0x02
    45d4:	93 81       	ldd	r25, Z+3	; 0x03
    45d6:	90 93 a3 00 	sts	0x00A3, r25
    45da:	80 93 a2 00 	sts	0x00A2, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    45de:	20 91 96 05 	lds	r18, 0x0596
    45e2:	30 91 97 05 	lds	r19, 0x0597
    45e6:	80 91 a2 00 	lds	r24, 0x00A2
    45ea:	90 91 a3 00 	lds	r25, 0x00A3
    45ee:	28 17       	cp	r18, r24
    45f0:	39 07       	cpc	r19, r25
    45f2:	08 f4       	brcc	.+2      	; 0x45f6 <vTaskIncrementTick+0xc2>
    45f4:	6b c0       	rjmp	.+214    	; 0x46cc <vTaskIncrementTick+0x198>
    45f6:	e0 91 e8 05 	lds	r30, 0x05E8
    45fa:	f0 91 e9 05 	lds	r31, 0x05E9
    45fe:	80 81       	ld	r24, Z
    4600:	88 23       	and	r24, r24
    4602:	39 f4       	brne	.+14     	; 0x4612 <vTaskIncrementTick+0xde>
    4604:	8f ef       	ldi	r24, 0xFF	; 255
    4606:	9f ef       	ldi	r25, 0xFF	; 255
    4608:	90 93 a3 00 	sts	0x00A3, r25
    460c:	80 93 a2 00 	sts	0x00A2, r24
    4610:	5d c0       	rjmp	.+186    	; 0x46cc <vTaskIncrementTick+0x198>
    4612:	e0 91 e8 05 	lds	r30, 0x05E8
    4616:	f0 91 e9 05 	lds	r31, 0x05E9
    461a:	05 80       	ldd	r0, Z+5	; 0x05
    461c:	f6 81       	ldd	r31, Z+6	; 0x06
    461e:	e0 2d       	mov	r30, r0
    4620:	86 81       	ldd	r24, Z+6	; 0x06
    4622:	97 81       	ldd	r25, Z+7	; 0x07
    4624:	9e 83       	std	Y+6, r25	; 0x06
    4626:	8d 83       	std	Y+5, r24	; 0x05
    4628:	ed 81       	ldd	r30, Y+5	; 0x05
    462a:	fe 81       	ldd	r31, Y+6	; 0x06
    462c:	82 81       	ldd	r24, Z+2	; 0x02
    462e:	93 81       	ldd	r25, Z+3	; 0x03
    4630:	9a 83       	std	Y+2, r25	; 0x02
    4632:	89 83       	std	Y+1, r24	; 0x01
    4634:	20 91 96 05 	lds	r18, 0x0596
    4638:	30 91 97 05 	lds	r19, 0x0597
    463c:	89 81       	ldd	r24, Y+1	; 0x01
    463e:	9a 81       	ldd	r25, Y+2	; 0x02
    4640:	28 17       	cp	r18, r24
    4642:	39 07       	cpc	r19, r25
    4644:	38 f4       	brcc	.+14     	; 0x4654 <vTaskIncrementTick+0x120>
    4646:	89 81       	ldd	r24, Y+1	; 0x01
    4648:	9a 81       	ldd	r25, Y+2	; 0x02
    464a:	90 93 a3 00 	sts	0x00A3, r25
    464e:	80 93 a2 00 	sts	0x00A2, r24
    4652:	3c c0       	rjmp	.+120    	; 0x46cc <vTaskIncrementTick+0x198>
    4654:	8d 81       	ldd	r24, Y+5	; 0x05
    4656:	9e 81       	ldd	r25, Y+6	; 0x06
    4658:	02 96       	adiw	r24, 0x02	; 2
    465a:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
    465e:	ed 81       	ldd	r30, Y+5	; 0x05
    4660:	fe 81       	ldd	r31, Y+6	; 0x06
    4662:	84 89       	ldd	r24, Z+20	; 0x14
    4664:	95 89       	ldd	r25, Z+21	; 0x15
    4666:	00 97       	sbiw	r24, 0x00	; 0
    4668:	29 f0       	breq	.+10     	; 0x4674 <vTaskIncrementTick+0x140>
    466a:	8d 81       	ldd	r24, Y+5	; 0x05
    466c:	9e 81       	ldd	r25, Y+6	; 0x06
    466e:	0c 96       	adiw	r24, 0x0c	; 12
    4670:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
    4674:	ed 81       	ldd	r30, Y+5	; 0x05
    4676:	fe 81       	ldd	r31, Y+6	; 0x06
    4678:	96 89       	ldd	r25, Z+22	; 0x16
    467a:	80 91 99 05 	lds	r24, 0x0599
    467e:	89 17       	cp	r24, r25
    4680:	28 f4       	brcc	.+10     	; 0x468c <vTaskIncrementTick+0x158>
    4682:	ed 81       	ldd	r30, Y+5	; 0x05
    4684:	fe 81       	ldd	r31, Y+6	; 0x06
    4686:	86 89       	ldd	r24, Z+22	; 0x16
    4688:	80 93 99 05 	sts	0x0599, r24
    468c:	ed 81       	ldd	r30, Y+5	; 0x05
    468e:	fe 81       	ldd	r31, Y+6	; 0x06
    4690:	86 89       	ldd	r24, Z+22	; 0x16
    4692:	28 2f       	mov	r18, r24
    4694:	30 e0       	ldi	r19, 0x00	; 0
    4696:	c9 01       	movw	r24, r18
    4698:	88 0f       	add	r24, r24
    469a:	99 1f       	adc	r25, r25
    469c:	88 0f       	add	r24, r24
    469e:	99 1f       	adc	r25, r25
    46a0:	88 0f       	add	r24, r24
    46a2:	99 1f       	adc	r25, r25
    46a4:	82 0f       	add	r24, r18
    46a6:	93 1f       	adc	r25, r19
    46a8:	ac 01       	movw	r20, r24
    46aa:	40 56       	subi	r20, 0x60	; 96
    46ac:	5a 4f       	sbci	r21, 0xFA	; 250
    46ae:	8d 81       	ldd	r24, Y+5	; 0x05
    46b0:	9e 81       	ldd	r25, Y+6	; 0x06
    46b2:	9c 01       	movw	r18, r24
    46b4:	2e 5f       	subi	r18, 0xFE	; 254
    46b6:	3f 4f       	sbci	r19, 0xFF	; 255
    46b8:	ca 01       	movw	r24, r20
    46ba:	b9 01       	movw	r22, r18
    46bc:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>
    46c0:	9a cf       	rjmp	.-204    	; 0x45f6 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    46c2:	80 91 9c 05 	lds	r24, 0x059C
    46c6:	8f 5f       	subi	r24, 0xFF	; 255
    46c8:	80 93 9c 05 	sts	0x059C, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    46cc:	26 96       	adiw	r28, 0x06	; 6
    46ce:	0f b6       	in	r0, 0x3f	; 63
    46d0:	f8 94       	cli
    46d2:	de bf       	out	0x3e, r29	; 62
    46d4:	0f be       	out	0x3f, r0	; 63
    46d6:	cd bf       	out	0x3d, r28	; 61
    46d8:	cf 91       	pop	r28
    46da:	df 91       	pop	r29
    46dc:	08 95       	ret

000046de <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    46de:	df 93       	push	r29
    46e0:	cf 93       	push	r28
    46e2:	00 d0       	rcall	.+0      	; 0x46e4 <vTaskSwitchContext+0x6>
    46e4:	cd b7       	in	r28, 0x3d	; 61
    46e6:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    46e8:	80 91 9b 05 	lds	r24, 0x059B
    46ec:	88 23       	and	r24, r24
    46ee:	49 f0       	breq	.+18     	; 0x4702 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    46f0:	81 e0       	ldi	r24, 0x01	; 1
    46f2:	80 93 9d 05 	sts	0x059D, r24
    46f6:	54 c0       	rjmp	.+168    	; 0x47a0 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    46f8:	80 91 99 05 	lds	r24, 0x0599
    46fc:	81 50       	subi	r24, 0x01	; 1
    46fe:	80 93 99 05 	sts	0x0599, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    4702:	80 91 99 05 	lds	r24, 0x0599
    4706:	28 2f       	mov	r18, r24
    4708:	30 e0       	ldi	r19, 0x00	; 0
    470a:	c9 01       	movw	r24, r18
    470c:	88 0f       	add	r24, r24
    470e:	99 1f       	adc	r25, r25
    4710:	88 0f       	add	r24, r24
    4712:	99 1f       	adc	r25, r25
    4714:	88 0f       	add	r24, r24
    4716:	99 1f       	adc	r25, r25
    4718:	82 0f       	add	r24, r18
    471a:	93 1f       	adc	r25, r19
    471c:	fc 01       	movw	r30, r24
    471e:	e0 56       	subi	r30, 0x60	; 96
    4720:	fa 4f       	sbci	r31, 0xFA	; 250
    4722:	80 81       	ld	r24, Z
    4724:	88 23       	and	r24, r24
    4726:	41 f3       	breq	.-48     	; 0x46f8 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    4728:	80 91 99 05 	lds	r24, 0x0599
    472c:	28 2f       	mov	r18, r24
    472e:	30 e0       	ldi	r19, 0x00	; 0
    4730:	c9 01       	movw	r24, r18
    4732:	88 0f       	add	r24, r24
    4734:	99 1f       	adc	r25, r25
    4736:	88 0f       	add	r24, r24
    4738:	99 1f       	adc	r25, r25
    473a:	88 0f       	add	r24, r24
    473c:	99 1f       	adc	r25, r25
    473e:	82 0f       	add	r24, r18
    4740:	93 1f       	adc	r25, r19
    4742:	80 56       	subi	r24, 0x60	; 96
    4744:	9a 4f       	sbci	r25, 0xFA	; 250
    4746:	9a 83       	std	Y+2, r25	; 0x02
    4748:	89 83       	std	Y+1, r24	; 0x01
    474a:	e9 81       	ldd	r30, Y+1	; 0x01
    474c:	fa 81       	ldd	r31, Y+2	; 0x02
    474e:	01 80       	ldd	r0, Z+1	; 0x01
    4750:	f2 81       	ldd	r31, Z+2	; 0x02
    4752:	e0 2d       	mov	r30, r0
    4754:	82 81       	ldd	r24, Z+2	; 0x02
    4756:	93 81       	ldd	r25, Z+3	; 0x03
    4758:	e9 81       	ldd	r30, Y+1	; 0x01
    475a:	fa 81       	ldd	r31, Y+2	; 0x02
    475c:	92 83       	std	Z+2, r25	; 0x02
    475e:	81 83       	std	Z+1, r24	; 0x01
    4760:	e9 81       	ldd	r30, Y+1	; 0x01
    4762:	fa 81       	ldd	r31, Y+2	; 0x02
    4764:	21 81       	ldd	r18, Z+1	; 0x01
    4766:	32 81       	ldd	r19, Z+2	; 0x02
    4768:	89 81       	ldd	r24, Y+1	; 0x01
    476a:	9a 81       	ldd	r25, Y+2	; 0x02
    476c:	03 96       	adiw	r24, 0x03	; 3
    476e:	28 17       	cp	r18, r24
    4770:	39 07       	cpc	r19, r25
    4772:	59 f4       	brne	.+22     	; 0x478a <vTaskSwitchContext+0xac>
    4774:	e9 81       	ldd	r30, Y+1	; 0x01
    4776:	fa 81       	ldd	r31, Y+2	; 0x02
    4778:	01 80       	ldd	r0, Z+1	; 0x01
    477a:	f2 81       	ldd	r31, Z+2	; 0x02
    477c:	e0 2d       	mov	r30, r0
    477e:	82 81       	ldd	r24, Z+2	; 0x02
    4780:	93 81       	ldd	r25, Z+3	; 0x03
    4782:	e9 81       	ldd	r30, Y+1	; 0x01
    4784:	fa 81       	ldd	r31, Y+2	; 0x02
    4786:	92 83       	std	Z+2, r25	; 0x02
    4788:	81 83       	std	Z+1, r24	; 0x01
    478a:	e9 81       	ldd	r30, Y+1	; 0x01
    478c:	fa 81       	ldd	r31, Y+2	; 0x02
    478e:	01 80       	ldd	r0, Z+1	; 0x01
    4790:	f2 81       	ldd	r31, Z+2	; 0x02
    4792:	e0 2d       	mov	r30, r0
    4794:	86 81       	ldd	r24, Z+6	; 0x06
    4796:	97 81       	ldd	r25, Z+7	; 0x07
    4798:	90 93 93 05 	sts	0x0593, r25
    479c:	80 93 92 05 	sts	0x0592, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    47a0:	0f 90       	pop	r0
    47a2:	0f 90       	pop	r0
    47a4:	cf 91       	pop	r28
    47a6:	df 91       	pop	r29
    47a8:	08 95       	ret

000047aa <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    47aa:	df 93       	push	r29
    47ac:	cf 93       	push	r28
    47ae:	00 d0       	rcall	.+0      	; 0x47b0 <vTaskPlaceOnEventList+0x6>
    47b0:	00 d0       	rcall	.+0      	; 0x47b2 <vTaskPlaceOnEventList+0x8>
    47b2:	00 d0       	rcall	.+0      	; 0x47b4 <vTaskPlaceOnEventList+0xa>
    47b4:	cd b7       	in	r28, 0x3d	; 61
    47b6:	de b7       	in	r29, 0x3e	; 62
    47b8:	9c 83       	std	Y+4, r25	; 0x04
    47ba:	8b 83       	std	Y+3, r24	; 0x03
    47bc:	7e 83       	std	Y+6, r23	; 0x06
    47be:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    47c0:	4b 81       	ldd	r20, Y+3	; 0x03
    47c2:	5c 81       	ldd	r21, Y+4	; 0x04
    47c4:	80 91 92 05 	lds	r24, 0x0592
    47c8:	90 91 93 05 	lds	r25, 0x0593
    47cc:	9c 01       	movw	r18, r24
    47ce:	24 5f       	subi	r18, 0xF4	; 244
    47d0:	3f 4f       	sbci	r19, 0xFF	; 255
    47d2:	ca 01       	movw	r24, r20
    47d4:	b9 01       	movw	r22, r18
    47d6:	0e 94 0d 16 	call	0x2c1a	; 0x2c1a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    47da:	80 91 92 05 	lds	r24, 0x0592
    47de:	90 91 93 05 	lds	r25, 0x0593
    47e2:	02 96       	adiw	r24, 0x02	; 2
    47e4:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    47e8:	8d 81       	ldd	r24, Y+5	; 0x05
    47ea:	9e 81       	ldd	r25, Y+6	; 0x06
    47ec:	2f ef       	ldi	r18, 0xFF	; 255
    47ee:	8f 3f       	cpi	r24, 0xFF	; 255
    47f0:	92 07       	cpc	r25, r18
    47f2:	69 f4       	brne	.+26     	; 0x480e <vTaskPlaceOnEventList+0x64>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    47f4:	80 91 92 05 	lds	r24, 0x0592
    47f8:	90 91 93 05 	lds	r25, 0x0593
    47fc:	9c 01       	movw	r18, r24
    47fe:	2e 5f       	subi	r18, 0xFE	; 254
    4800:	3f 4f       	sbci	r19, 0xFF	; 255
    4802:	8e ef       	ldi	r24, 0xFE	; 254
    4804:	95 e0       	ldi	r25, 0x05	; 5
    4806:	b9 01       	movw	r22, r18
    4808:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>
    480c:	0e c0       	rjmp	.+28     	; 0x482a <vTaskPlaceOnEventList+0x80>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    480e:	20 91 96 05 	lds	r18, 0x0596
    4812:	30 91 97 05 	lds	r19, 0x0597
    4816:	8d 81       	ldd	r24, Y+5	; 0x05
    4818:	9e 81       	ldd	r25, Y+6	; 0x06
    481a:	82 0f       	add	r24, r18
    481c:	93 1f       	adc	r25, r19
    481e:	9a 83       	std	Y+2, r25	; 0x02
    4820:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4822:	89 81       	ldd	r24, Y+1	; 0x01
    4824:	9a 81       	ldd	r25, Y+2	; 0x02
    4826:	0e 94 f0 25 	call	0x4be0	; 0x4be0 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    482a:	26 96       	adiw	r28, 0x06	; 6
    482c:	0f b6       	in	r0, 0x3f	; 63
    482e:	f8 94       	cli
    4830:	de bf       	out	0x3e, r29	; 62
    4832:	0f be       	out	0x3f, r0	; 63
    4834:	cd bf       	out	0x3d, r28	; 61
    4836:	cf 91       	pop	r28
    4838:	df 91       	pop	r29
    483a:	08 95       	ret

0000483c <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    483c:	df 93       	push	r29
    483e:	cf 93       	push	r28
    4840:	00 d0       	rcall	.+0      	; 0x4842 <xTaskRemoveFromEventList+0x6>
    4842:	00 d0       	rcall	.+0      	; 0x4844 <xTaskRemoveFromEventList+0x8>
    4844:	0f 92       	push	r0
    4846:	cd b7       	in	r28, 0x3d	; 61
    4848:	de b7       	in	r29, 0x3e	; 62
    484a:	9d 83       	std	Y+5, r25	; 0x05
    484c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    484e:	ec 81       	ldd	r30, Y+4	; 0x04
    4850:	fd 81       	ldd	r31, Y+5	; 0x05
    4852:	05 80       	ldd	r0, Z+5	; 0x05
    4854:	f6 81       	ldd	r31, Z+6	; 0x06
    4856:	e0 2d       	mov	r30, r0
    4858:	86 81       	ldd	r24, Z+6	; 0x06
    485a:	97 81       	ldd	r25, Z+7	; 0x07
    485c:	9b 83       	std	Y+3, r25	; 0x03
    485e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4860:	8a 81       	ldd	r24, Y+2	; 0x02
    4862:	9b 81       	ldd	r25, Y+3	; 0x03
    4864:	0c 96       	adiw	r24, 0x0c	; 12
    4866:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    486a:	80 91 9b 05 	lds	r24, 0x059B
    486e:	88 23       	and	r24, r24
    4870:	61 f5       	brne	.+88     	; 0x48ca <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4872:	8a 81       	ldd	r24, Y+2	; 0x02
    4874:	9b 81       	ldd	r25, Y+3	; 0x03
    4876:	02 96       	adiw	r24, 0x02	; 2
    4878:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    487c:	ea 81       	ldd	r30, Y+2	; 0x02
    487e:	fb 81       	ldd	r31, Y+3	; 0x03
    4880:	96 89       	ldd	r25, Z+22	; 0x16
    4882:	80 91 99 05 	lds	r24, 0x0599
    4886:	89 17       	cp	r24, r25
    4888:	28 f4       	brcc	.+10     	; 0x4894 <xTaskRemoveFromEventList+0x58>
    488a:	ea 81       	ldd	r30, Y+2	; 0x02
    488c:	fb 81       	ldd	r31, Y+3	; 0x03
    488e:	86 89       	ldd	r24, Z+22	; 0x16
    4890:	80 93 99 05 	sts	0x0599, r24
    4894:	ea 81       	ldd	r30, Y+2	; 0x02
    4896:	fb 81       	ldd	r31, Y+3	; 0x03
    4898:	86 89       	ldd	r24, Z+22	; 0x16
    489a:	28 2f       	mov	r18, r24
    489c:	30 e0       	ldi	r19, 0x00	; 0
    489e:	c9 01       	movw	r24, r18
    48a0:	88 0f       	add	r24, r24
    48a2:	99 1f       	adc	r25, r25
    48a4:	88 0f       	add	r24, r24
    48a6:	99 1f       	adc	r25, r25
    48a8:	88 0f       	add	r24, r24
    48aa:	99 1f       	adc	r25, r25
    48ac:	82 0f       	add	r24, r18
    48ae:	93 1f       	adc	r25, r19
    48b0:	ac 01       	movw	r20, r24
    48b2:	40 56       	subi	r20, 0x60	; 96
    48b4:	5a 4f       	sbci	r21, 0xFA	; 250
    48b6:	8a 81       	ldd	r24, Y+2	; 0x02
    48b8:	9b 81       	ldd	r25, Y+3	; 0x03
    48ba:	9c 01       	movw	r18, r24
    48bc:	2e 5f       	subi	r18, 0xFE	; 254
    48be:	3f 4f       	sbci	r19, 0xFF	; 255
    48c0:	ca 01       	movw	r24, r20
    48c2:	b9 01       	movw	r22, r18
    48c4:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>
    48c8:	0a c0       	rjmp	.+20     	; 0x48de <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    48ca:	8a 81       	ldd	r24, Y+2	; 0x02
    48cc:	9b 81       	ldd	r25, Y+3	; 0x03
    48ce:	9c 01       	movw	r18, r24
    48d0:	24 5f       	subi	r18, 0xF4	; 244
    48d2:	3f 4f       	sbci	r19, 0xFF	; 255
    48d4:	8c ee       	ldi	r24, 0xEC	; 236
    48d6:	95 e0       	ldi	r25, 0x05	; 5
    48d8:	b9 01       	movw	r22, r18
    48da:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    48de:	ea 81       	ldd	r30, Y+2	; 0x02
    48e0:	fb 81       	ldd	r31, Y+3	; 0x03
    48e2:	96 89       	ldd	r25, Z+22	; 0x16
    48e4:	e0 91 92 05 	lds	r30, 0x0592
    48e8:	f0 91 93 05 	lds	r31, 0x0593
    48ec:	86 89       	ldd	r24, Z+22	; 0x16
    48ee:	98 17       	cp	r25, r24
    48f0:	18 f0       	brcs	.+6      	; 0x48f8 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    48f2:	81 e0       	ldi	r24, 0x01	; 1
    48f4:	89 83       	std	Y+1, r24	; 0x01
    48f6:	01 c0       	rjmp	.+2      	; 0x48fa <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    48f8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    48fa:	89 81       	ldd	r24, Y+1	; 0x01
}
    48fc:	0f 90       	pop	r0
    48fe:	0f 90       	pop	r0
    4900:	0f 90       	pop	r0
    4902:	0f 90       	pop	r0
    4904:	0f 90       	pop	r0
    4906:	cf 91       	pop	r28
    4908:	df 91       	pop	r29
    490a:	08 95       	ret

0000490c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    490c:	df 93       	push	r29
    490e:	cf 93       	push	r28
    4910:	00 d0       	rcall	.+0      	; 0x4912 <vTaskSetTimeOutState+0x6>
    4912:	cd b7       	in	r28, 0x3d	; 61
    4914:	de b7       	in	r29, 0x3e	; 62
    4916:	9a 83       	std	Y+2, r25	; 0x02
    4918:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    491a:	80 91 9e 05 	lds	r24, 0x059E
    491e:	e9 81       	ldd	r30, Y+1	; 0x01
    4920:	fa 81       	ldd	r31, Y+2	; 0x02
    4922:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4924:	80 91 96 05 	lds	r24, 0x0596
    4928:	90 91 97 05 	lds	r25, 0x0597
    492c:	e9 81       	ldd	r30, Y+1	; 0x01
    492e:	fa 81       	ldd	r31, Y+2	; 0x02
    4930:	92 83       	std	Z+2, r25	; 0x02
    4932:	81 83       	std	Z+1, r24	; 0x01
}
    4934:	0f 90       	pop	r0
    4936:	0f 90       	pop	r0
    4938:	cf 91       	pop	r28
    493a:	df 91       	pop	r29
    493c:	08 95       	ret

0000493e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    493e:	df 93       	push	r29
    4940:	cf 93       	push	r28
    4942:	00 d0       	rcall	.+0      	; 0x4944 <xTaskCheckForTimeOut+0x6>
    4944:	00 d0       	rcall	.+0      	; 0x4946 <xTaskCheckForTimeOut+0x8>
    4946:	0f 92       	push	r0
    4948:	cd b7       	in	r28, 0x3d	; 61
    494a:	de b7       	in	r29, 0x3e	; 62
    494c:	9b 83       	std	Y+3, r25	; 0x03
    494e:	8a 83       	std	Y+2, r24	; 0x02
    4950:	7d 83       	std	Y+5, r23	; 0x05
    4952:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4954:	0f b6       	in	r0, 0x3f	; 63
    4956:	f8 94       	cli
    4958:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    495a:	ec 81       	ldd	r30, Y+4	; 0x04
    495c:	fd 81       	ldd	r31, Y+5	; 0x05
    495e:	80 81       	ld	r24, Z
    4960:	91 81       	ldd	r25, Z+1	; 0x01
    4962:	2f ef       	ldi	r18, 0xFF	; 255
    4964:	8f 3f       	cpi	r24, 0xFF	; 255
    4966:	92 07       	cpc	r25, r18
    4968:	11 f4       	brne	.+4      	; 0x496e <xTaskCheckForTimeOut+0x30>
			{
				xReturn = pdFALSE;
    496a:	19 82       	std	Y+1, r1	; 0x01
    496c:	44 c0       	rjmp	.+136    	; 0x49f6 <xTaskCheckForTimeOut+0xb8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    496e:	ea 81       	ldd	r30, Y+2	; 0x02
    4970:	fb 81       	ldd	r31, Y+3	; 0x03
    4972:	90 81       	ld	r25, Z
    4974:	80 91 9e 05 	lds	r24, 0x059E
    4978:	98 17       	cp	r25, r24
    497a:	71 f0       	breq	.+28     	; 0x4998 <xTaskCheckForTimeOut+0x5a>
    497c:	ea 81       	ldd	r30, Y+2	; 0x02
    497e:	fb 81       	ldd	r31, Y+3	; 0x03
    4980:	21 81       	ldd	r18, Z+1	; 0x01
    4982:	32 81       	ldd	r19, Z+2	; 0x02
    4984:	80 91 96 05 	lds	r24, 0x0596
    4988:	90 91 97 05 	lds	r25, 0x0597
    498c:	82 17       	cp	r24, r18
    498e:	93 07       	cpc	r25, r19
    4990:	18 f0       	brcs	.+6      	; 0x4998 <xTaskCheckForTimeOut+0x5a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4992:	81 e0       	ldi	r24, 0x01	; 1
    4994:	89 83       	std	Y+1, r24	; 0x01
    4996:	2f c0       	rjmp	.+94     	; 0x49f6 <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    4998:	20 91 96 05 	lds	r18, 0x0596
    499c:	30 91 97 05 	lds	r19, 0x0597
    49a0:	ea 81       	ldd	r30, Y+2	; 0x02
    49a2:	fb 81       	ldd	r31, Y+3	; 0x03
    49a4:	81 81       	ldd	r24, Z+1	; 0x01
    49a6:	92 81       	ldd	r25, Z+2	; 0x02
    49a8:	28 1b       	sub	r18, r24
    49aa:	39 0b       	sbc	r19, r25
    49ac:	ec 81       	ldd	r30, Y+4	; 0x04
    49ae:	fd 81       	ldd	r31, Y+5	; 0x05
    49b0:	80 81       	ld	r24, Z
    49b2:	91 81       	ldd	r25, Z+1	; 0x01
    49b4:	28 17       	cp	r18, r24
    49b6:	39 07       	cpc	r19, r25
    49b8:	e0 f4       	brcc	.+56     	; 0x49f2 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    49ba:	ec 81       	ldd	r30, Y+4	; 0x04
    49bc:	fd 81       	ldd	r31, Y+5	; 0x05
    49be:	40 81       	ld	r20, Z
    49c0:	51 81       	ldd	r21, Z+1	; 0x01
    49c2:	ea 81       	ldd	r30, Y+2	; 0x02
    49c4:	fb 81       	ldd	r31, Y+3	; 0x03
    49c6:	21 81       	ldd	r18, Z+1	; 0x01
    49c8:	32 81       	ldd	r19, Z+2	; 0x02
    49ca:	80 91 96 05 	lds	r24, 0x0596
    49ce:	90 91 97 05 	lds	r25, 0x0597
    49d2:	b9 01       	movw	r22, r18
    49d4:	68 1b       	sub	r22, r24
    49d6:	79 0b       	sbc	r23, r25
    49d8:	cb 01       	movw	r24, r22
    49da:	84 0f       	add	r24, r20
    49dc:	95 1f       	adc	r25, r21
    49de:	ec 81       	ldd	r30, Y+4	; 0x04
    49e0:	fd 81       	ldd	r31, Y+5	; 0x05
    49e2:	91 83       	std	Z+1, r25	; 0x01
    49e4:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    49e6:	8a 81       	ldd	r24, Y+2	; 0x02
    49e8:	9b 81       	ldd	r25, Y+3	; 0x03
    49ea:	0e 94 86 24 	call	0x490c	; 0x490c <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    49ee:	19 82       	std	Y+1, r1	; 0x01
    49f0:	02 c0       	rjmp	.+4      	; 0x49f6 <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    49f2:	81 e0       	ldi	r24, 0x01	; 1
    49f4:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    49f6:	0f 90       	pop	r0
    49f8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    49fa:	89 81       	ldd	r24, Y+1	; 0x01
}
    49fc:	0f 90       	pop	r0
    49fe:	0f 90       	pop	r0
    4a00:	0f 90       	pop	r0
    4a02:	0f 90       	pop	r0
    4a04:	0f 90       	pop	r0
    4a06:	cf 91       	pop	r28
    4a08:	df 91       	pop	r29
    4a0a:	08 95       	ret

00004a0c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4a0c:	df 93       	push	r29
    4a0e:	cf 93       	push	r28
    4a10:	cd b7       	in	r28, 0x3d	; 61
    4a12:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    4a14:	81 e0       	ldi	r24, 0x01	; 1
    4a16:	80 93 9d 05 	sts	0x059D, r24
}
    4a1a:	cf 91       	pop	r28
    4a1c:	df 91       	pop	r29
    4a1e:	08 95       	ret

00004a20 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4a20:	df 93       	push	r29
    4a22:	cf 93       	push	r28
    4a24:	00 d0       	rcall	.+0      	; 0x4a26 <prvIdleTask+0x6>
    4a26:	cd b7       	in	r28, 0x3d	; 61
    4a28:	de b7       	in	r29, 0x3e	; 62
    4a2a:	9a 83       	std	Y+2, r25	; 0x02
    4a2c:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    4a2e:	0e 94 b2 25 	call	0x4b64	; 0x4b64 <prvCheckTasksWaitingTermination>
    4a32:	fd cf       	rjmp	.-6      	; 0x4a2e <prvIdleTask+0xe>

00004a34 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    4a34:	0f 93       	push	r16
    4a36:	1f 93       	push	r17
    4a38:	df 93       	push	r29
    4a3a:	cf 93       	push	r28
    4a3c:	cd b7       	in	r28, 0x3d	; 61
    4a3e:	de b7       	in	r29, 0x3e	; 62
    4a40:	29 97       	sbiw	r28, 0x09	; 9
    4a42:	0f b6       	in	r0, 0x3f	; 63
    4a44:	f8 94       	cli
    4a46:	de bf       	out	0x3e, r29	; 62
    4a48:	0f be       	out	0x3f, r0	; 63
    4a4a:	cd bf       	out	0x3d, r28	; 61
    4a4c:	9a 83       	std	Y+2, r25	; 0x02
    4a4e:	89 83       	std	Y+1, r24	; 0x01
    4a50:	7c 83       	std	Y+4, r23	; 0x04
    4a52:	6b 83       	std	Y+3, r22	; 0x03
    4a54:	4d 83       	std	Y+5, r20	; 0x05
    4a56:	3f 83       	std	Y+7, r19	; 0x07
    4a58:	2e 83       	std	Y+6, r18	; 0x06
    4a5a:	19 87       	std	Y+9, r17	; 0x09
    4a5c:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    4a5e:	89 81       	ldd	r24, Y+1	; 0x01
    4a60:	9a 81       	ldd	r25, Y+2	; 0x02
    4a62:	49 96       	adiw	r24, 0x19	; 25
    4a64:	2b 81       	ldd	r18, Y+3	; 0x03
    4a66:	3c 81       	ldd	r19, Y+4	; 0x04
    4a68:	b9 01       	movw	r22, r18
    4a6a:	48 e0       	ldi	r20, 0x08	; 8
    4a6c:	50 e0       	ldi	r21, 0x00	; 0
    4a6e:	0e 94 dd 27 	call	0x4fba	; 0x4fba <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    4a72:	e9 81       	ldd	r30, Y+1	; 0x01
    4a74:	fa 81       	ldd	r31, Y+2	; 0x02
    4a76:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    4a78:	8d 81       	ldd	r24, Y+5	; 0x05
    4a7a:	86 30       	cpi	r24, 0x06	; 6
    4a7c:	10 f0       	brcs	.+4      	; 0x4a82 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    4a7e:	85 e0       	ldi	r24, 0x05	; 5
    4a80:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    4a82:	e9 81       	ldd	r30, Y+1	; 0x01
    4a84:	fa 81       	ldd	r31, Y+2	; 0x02
    4a86:	8d 81       	ldd	r24, Y+5	; 0x05
    4a88:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4a8a:	89 81       	ldd	r24, Y+1	; 0x01
    4a8c:	9a 81       	ldd	r25, Y+2	; 0x02
    4a8e:	02 96       	adiw	r24, 0x02	; 2
    4a90:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4a94:	89 81       	ldd	r24, Y+1	; 0x01
    4a96:	9a 81       	ldd	r25, Y+2	; 0x02
    4a98:	0c 96       	adiw	r24, 0x0c	; 12
    4a9a:	0e 94 b1 15 	call	0x2b62	; 0x2b62 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    4a9e:	e9 81       	ldd	r30, Y+1	; 0x01
    4aa0:	fa 81       	ldd	r31, Y+2	; 0x02
    4aa2:	89 81       	ldd	r24, Y+1	; 0x01
    4aa4:	9a 81       	ldd	r25, Y+2	; 0x02
    4aa6:	91 87       	std	Z+9, r25	; 0x09
    4aa8:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4aaa:	8d 81       	ldd	r24, Y+5	; 0x05
    4aac:	28 2f       	mov	r18, r24
    4aae:	30 e0       	ldi	r19, 0x00	; 0
    4ab0:	86 e0       	ldi	r24, 0x06	; 6
    4ab2:	90 e0       	ldi	r25, 0x00	; 0
    4ab4:	82 1b       	sub	r24, r18
    4ab6:	93 0b       	sbc	r25, r19
    4ab8:	e9 81       	ldd	r30, Y+1	; 0x01
    4aba:	fa 81       	ldd	r31, Y+2	; 0x02
    4abc:	95 87       	std	Z+13, r25	; 0x0d
    4abe:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    4ac0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ac2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ac4:	89 81       	ldd	r24, Y+1	; 0x01
    4ac6:	9a 81       	ldd	r25, Y+2	; 0x02
    4ac8:	93 8b       	std	Z+19, r25	; 0x13
    4aca:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    4acc:	29 96       	adiw	r28, 0x09	; 9
    4ace:	0f b6       	in	r0, 0x3f	; 63
    4ad0:	f8 94       	cli
    4ad2:	de bf       	out	0x3e, r29	; 62
    4ad4:	0f be       	out	0x3f, r0	; 63
    4ad6:	cd bf       	out	0x3d, r28	; 61
    4ad8:	cf 91       	pop	r28
    4ada:	df 91       	pop	r29
    4adc:	1f 91       	pop	r17
    4ade:	0f 91       	pop	r16
    4ae0:	08 95       	ret

00004ae2 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    4ae2:	df 93       	push	r29
    4ae4:	cf 93       	push	r28
    4ae6:	0f 92       	push	r0
    4ae8:	cd b7       	in	r28, 0x3d	; 61
    4aea:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4aec:	19 82       	std	Y+1, r1	; 0x01
    4aee:	13 c0       	rjmp	.+38     	; 0x4b16 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    4af0:	89 81       	ldd	r24, Y+1	; 0x01
    4af2:	28 2f       	mov	r18, r24
    4af4:	30 e0       	ldi	r19, 0x00	; 0
    4af6:	c9 01       	movw	r24, r18
    4af8:	88 0f       	add	r24, r24
    4afa:	99 1f       	adc	r25, r25
    4afc:	88 0f       	add	r24, r24
    4afe:	99 1f       	adc	r25, r25
    4b00:	88 0f       	add	r24, r24
    4b02:	99 1f       	adc	r25, r25
    4b04:	82 0f       	add	r24, r18
    4b06:	93 1f       	adc	r25, r19
    4b08:	80 56       	subi	r24, 0x60	; 96
    4b0a:	9a 4f       	sbci	r25, 0xFA	; 250
    4b0c:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4b10:	89 81       	ldd	r24, Y+1	; 0x01
    4b12:	8f 5f       	subi	r24, 0xFF	; 255
    4b14:	89 83       	std	Y+1, r24	; 0x01
    4b16:	89 81       	ldd	r24, Y+1	; 0x01
    4b18:	86 30       	cpi	r24, 0x06	; 6
    4b1a:	50 f3       	brcs	.-44     	; 0x4af0 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    4b1c:	86 ed       	ldi	r24, 0xD6	; 214
    4b1e:	95 e0       	ldi	r25, 0x05	; 5
    4b20:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    4b24:	8f ed       	ldi	r24, 0xDF	; 223
    4b26:	95 e0       	ldi	r25, 0x05	; 5
    4b28:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    4b2c:	8c ee       	ldi	r24, 0xEC	; 236
    4b2e:	95 e0       	ldi	r25, 0x05	; 5
    4b30:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    4b34:	85 ef       	ldi	r24, 0xF5	; 245
    4b36:	95 e0       	ldi	r25, 0x05	; 5
    4b38:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    4b3c:	8e ef       	ldi	r24, 0xFE	; 254
    4b3e:	95 e0       	ldi	r25, 0x05	; 5
    4b40:	0e 94 87 15 	call	0x2b0e	; 0x2b0e <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4b44:	86 ed       	ldi	r24, 0xD6	; 214
    4b46:	95 e0       	ldi	r25, 0x05	; 5
    4b48:	90 93 e9 05 	sts	0x05E9, r25
    4b4c:	80 93 e8 05 	sts	0x05E8, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4b50:	8f ed       	ldi	r24, 0xDF	; 223
    4b52:	95 e0       	ldi	r25, 0x05	; 5
    4b54:	90 93 eb 05 	sts	0x05EB, r25
    4b58:	80 93 ea 05 	sts	0x05EA, r24
}
    4b5c:	0f 90       	pop	r0
    4b5e:	cf 91       	pop	r28
    4b60:	df 91       	pop	r29
    4b62:	08 95       	ret

00004b64 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4b64:	df 93       	push	r29
    4b66:	cf 93       	push	r28
    4b68:	00 d0       	rcall	.+0      	; 0x4b6a <prvCheckTasksWaitingTermination+0x6>
    4b6a:	0f 92       	push	r0
    4b6c:	cd b7       	in	r28, 0x3d	; 61
    4b6e:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    4b70:	80 91 94 05 	lds	r24, 0x0594
    4b74:	88 23       	and	r24, r24
    4b76:	71 f1       	breq	.+92     	; 0x4bd4 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    4b78:	0e 94 cf 21 	call	0x439e	; 0x439e <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4b7c:	80 91 f5 05 	lds	r24, 0x05F5
    4b80:	1b 82       	std	Y+3, r1	; 0x03
    4b82:	88 23       	and	r24, r24
    4b84:	11 f4       	brne	.+4      	; 0x4b8a <prvCheckTasksWaitingTermination+0x26>
    4b86:	81 e0       	ldi	r24, 0x01	; 1
    4b88:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    4b8a:	0e 94 db 21 	call	0x43b6	; 0x43b6 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4b8e:	8b 81       	ldd	r24, Y+3	; 0x03
    4b90:	88 23       	and	r24, r24
    4b92:	01 f5       	brne	.+64     	; 0x4bd4 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    4b94:	0f b6       	in	r0, 0x3f	; 63
    4b96:	f8 94       	cli
    4b98:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    4b9a:	e0 91 fa 05 	lds	r30, 0x05FA
    4b9e:	f0 91 fb 05 	lds	r31, 0x05FB
    4ba2:	86 81       	ldd	r24, Z+6	; 0x06
    4ba4:	97 81       	ldd	r25, Z+7	; 0x07
    4ba6:	9a 83       	std	Y+2, r25	; 0x02
    4ba8:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    4baa:	89 81       	ldd	r24, Y+1	; 0x01
    4bac:	9a 81       	ldd	r25, Y+2	; 0x02
    4bae:	02 96       	adiw	r24, 0x02	; 2
    4bb0:	0e 94 79 16 	call	0x2cf2	; 0x2cf2 <vListRemove>
					--uxCurrentNumberOfTasks;
    4bb4:	80 91 95 05 	lds	r24, 0x0595
    4bb8:	81 50       	subi	r24, 0x01	; 1
    4bba:	80 93 95 05 	sts	0x0595, r24
					--uxTasksDeleted;
    4bbe:	80 91 94 05 	lds	r24, 0x0594
    4bc2:	81 50       	subi	r24, 0x01	; 1
    4bc4:	80 93 94 05 	sts	0x0594, r24
				}
				taskEXIT_CRITICAL();
    4bc8:	0f 90       	pop	r0
    4bca:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    4bcc:	89 81       	ldd	r24, Y+1	; 0x01
    4bce:	9a 81       	ldd	r25, Y+2	; 0x02
    4bd0:	0e 94 89 26 	call	0x4d12	; 0x4d12 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    4bd4:	0f 90       	pop	r0
    4bd6:	0f 90       	pop	r0
    4bd8:	0f 90       	pop	r0
    4bda:	cf 91       	pop	r28
    4bdc:	df 91       	pop	r29
    4bde:	08 95       	ret

00004be0 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    4be0:	df 93       	push	r29
    4be2:	cf 93       	push	r28
    4be4:	00 d0       	rcall	.+0      	; 0x4be6 <prvAddCurrentTaskToDelayedList+0x6>
    4be6:	cd b7       	in	r28, 0x3d	; 61
    4be8:	de b7       	in	r29, 0x3e	; 62
    4bea:	9a 83       	std	Y+2, r25	; 0x02
    4bec:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    4bee:	e0 91 92 05 	lds	r30, 0x0592
    4bf2:	f0 91 93 05 	lds	r31, 0x0593
    4bf6:	89 81       	ldd	r24, Y+1	; 0x01
    4bf8:	9a 81       	ldd	r25, Y+2	; 0x02
    4bfa:	93 83       	std	Z+3, r25	; 0x03
    4bfc:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    4bfe:	20 91 96 05 	lds	r18, 0x0596
    4c02:	30 91 97 05 	lds	r19, 0x0597
    4c06:	89 81       	ldd	r24, Y+1	; 0x01
    4c08:	9a 81       	ldd	r25, Y+2	; 0x02
    4c0a:	82 17       	cp	r24, r18
    4c0c:	93 07       	cpc	r25, r19
    4c0e:	70 f4       	brcc	.+28     	; 0x4c2c <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4c10:	80 91 ea 05 	lds	r24, 0x05EA
    4c14:	90 91 eb 05 	lds	r25, 0x05EB
    4c18:	20 91 92 05 	lds	r18, 0x0592
    4c1c:	30 91 93 05 	lds	r19, 0x0593
    4c20:	2e 5f       	subi	r18, 0xFE	; 254
    4c22:	3f 4f       	sbci	r19, 0xFF	; 255
    4c24:	b9 01       	movw	r22, r18
    4c26:	0e 94 0d 16 	call	0x2c1a	; 0x2c1a <vListInsert>
    4c2a:	1e c0       	rjmp	.+60     	; 0x4c68 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4c2c:	40 91 e8 05 	lds	r20, 0x05E8
    4c30:	50 91 e9 05 	lds	r21, 0x05E9
    4c34:	80 91 92 05 	lds	r24, 0x0592
    4c38:	90 91 93 05 	lds	r25, 0x0593
    4c3c:	9c 01       	movw	r18, r24
    4c3e:	2e 5f       	subi	r18, 0xFE	; 254
    4c40:	3f 4f       	sbci	r19, 0xFF	; 255
    4c42:	ca 01       	movw	r24, r20
    4c44:	b9 01       	movw	r22, r18
    4c46:	0e 94 0d 16 	call	0x2c1a	; 0x2c1a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    4c4a:	20 91 a2 00 	lds	r18, 0x00A2
    4c4e:	30 91 a3 00 	lds	r19, 0x00A3
    4c52:	89 81       	ldd	r24, Y+1	; 0x01
    4c54:	9a 81       	ldd	r25, Y+2	; 0x02
    4c56:	82 17       	cp	r24, r18
    4c58:	93 07       	cpc	r25, r19
    4c5a:	30 f4       	brcc	.+12     	; 0x4c68 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4c5c:	89 81       	ldd	r24, Y+1	; 0x01
    4c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    4c60:	90 93 a3 00 	sts	0x00A3, r25
    4c64:	80 93 a2 00 	sts	0x00A2, r24
		}
	}
}
    4c68:	0f 90       	pop	r0
    4c6a:	0f 90       	pop	r0
    4c6c:	cf 91       	pop	r28
    4c6e:	df 91       	pop	r29
    4c70:	08 95       	ret

00004c72 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    4c72:	df 93       	push	r29
    4c74:	cf 93       	push	r28
    4c76:	cd b7       	in	r28, 0x3d	; 61
    4c78:	de b7       	in	r29, 0x3e	; 62
    4c7a:	28 97       	sbiw	r28, 0x08	; 8
    4c7c:	0f b6       	in	r0, 0x3f	; 63
    4c7e:	f8 94       	cli
    4c80:	de bf       	out	0x3e, r29	; 62
    4c82:	0f be       	out	0x3f, r0	; 63
    4c84:	cd bf       	out	0x3d, r28	; 61
    4c86:	9c 83       	std	Y+4, r25	; 0x04
    4c88:	8b 83       	std	Y+3, r24	; 0x03
    4c8a:	7e 83       	std	Y+6, r23	; 0x06
    4c8c:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    4c8e:	81 e2       	ldi	r24, 0x21	; 33
    4c90:	90 e0       	ldi	r25, 0x00	; 0
    4c92:	0e 94 1b 15 	call	0x2a36	; 0x2a36 <pvPortMalloc>
    4c96:	9a 83       	std	Y+2, r25	; 0x02
    4c98:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4c9a:	89 81       	ldd	r24, Y+1	; 0x01
    4c9c:	9a 81       	ldd	r25, Y+2	; 0x02
    4c9e:	00 97       	sbiw	r24, 0x00	; 0
    4ca0:	69 f1       	breq	.+90     	; 0x4cfc <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    4ca2:	8d 81       	ldd	r24, Y+5	; 0x05
    4ca4:	9e 81       	ldd	r25, Y+6	; 0x06
    4ca6:	00 97       	sbiw	r24, 0x00	; 0
    4ca8:	39 f4       	brne	.+14     	; 0x4cb8 <prvAllocateTCBAndStack+0x46>
    4caa:	8b 81       	ldd	r24, Y+3	; 0x03
    4cac:	9c 81       	ldd	r25, Y+4	; 0x04
    4cae:	0e 94 1b 15 	call	0x2a36	; 0x2a36 <pvPortMalloc>
    4cb2:	98 87       	std	Y+8, r25	; 0x08
    4cb4:	8f 83       	std	Y+7, r24	; 0x07
    4cb6:	04 c0       	rjmp	.+8      	; 0x4cc0 <prvAllocateTCBAndStack+0x4e>
    4cb8:	8d 81       	ldd	r24, Y+5	; 0x05
    4cba:	9e 81       	ldd	r25, Y+6	; 0x06
    4cbc:	98 87       	std	Y+8, r25	; 0x08
    4cbe:	8f 83       	std	Y+7, r24	; 0x07
    4cc0:	e9 81       	ldd	r30, Y+1	; 0x01
    4cc2:	fa 81       	ldd	r31, Y+2	; 0x02
    4cc4:	8f 81       	ldd	r24, Y+7	; 0x07
    4cc6:	98 85       	ldd	r25, Y+8	; 0x08
    4cc8:	90 8f       	std	Z+24, r25	; 0x18
    4cca:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    4ccc:	e9 81       	ldd	r30, Y+1	; 0x01
    4cce:	fa 81       	ldd	r31, Y+2	; 0x02
    4cd0:	87 89       	ldd	r24, Z+23	; 0x17
    4cd2:	90 8d       	ldd	r25, Z+24	; 0x18
    4cd4:	00 97       	sbiw	r24, 0x00	; 0
    4cd6:	39 f4       	brne	.+14     	; 0x4ce6 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    4cd8:	89 81       	ldd	r24, Y+1	; 0x01
    4cda:	9a 81       	ldd	r25, Y+2	; 0x02
    4cdc:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <vPortFree>
			pxNewTCB = NULL;
    4ce0:	1a 82       	std	Y+2, r1	; 0x02
    4ce2:	19 82       	std	Y+1, r1	; 0x01
    4ce4:	0b c0       	rjmp	.+22     	; 0x4cfc <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    4ce6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ce8:	fa 81       	ldd	r31, Y+2	; 0x02
    4cea:	87 89       	ldd	r24, Z+23	; 0x17
    4cec:	90 8d       	ldd	r25, Z+24	; 0x18
    4cee:	2b 81       	ldd	r18, Y+3	; 0x03
    4cf0:	3c 81       	ldd	r19, Y+4	; 0x04
    4cf2:	65 ea       	ldi	r22, 0xA5	; 165
    4cf4:	70 e0       	ldi	r23, 0x00	; 0
    4cf6:	a9 01       	movw	r20, r18
    4cf8:	0e 94 d6 27 	call	0x4fac	; 0x4fac <memset>
		}
	}

	return pxNewTCB;
    4cfc:	89 81       	ldd	r24, Y+1	; 0x01
    4cfe:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4d00:	28 96       	adiw	r28, 0x08	; 8
    4d02:	0f b6       	in	r0, 0x3f	; 63
    4d04:	f8 94       	cli
    4d06:	de bf       	out	0x3e, r29	; 62
    4d08:	0f be       	out	0x3f, r0	; 63
    4d0a:	cd bf       	out	0x3d, r28	; 61
    4d0c:	cf 91       	pop	r28
    4d0e:	df 91       	pop	r29
    4d10:	08 95       	ret

00004d12 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    4d12:	df 93       	push	r29
    4d14:	cf 93       	push	r28
    4d16:	00 d0       	rcall	.+0      	; 0x4d18 <prvDeleteTCB+0x6>
    4d18:	cd b7       	in	r28, 0x3d	; 61
    4d1a:	de b7       	in	r29, 0x3e	; 62
    4d1c:	9a 83       	std	Y+2, r25	; 0x02
    4d1e:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    4d20:	e9 81       	ldd	r30, Y+1	; 0x01
    4d22:	fa 81       	ldd	r31, Y+2	; 0x02
    4d24:	87 89       	ldd	r24, Z+23	; 0x17
    4d26:	90 8d       	ldd	r25, Z+24	; 0x18
    4d28:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <vPortFree>
		vPortFree( pxTCB );
    4d2c:	89 81       	ldd	r24, Y+1	; 0x01
    4d2e:	9a 81       	ldd	r25, Y+2	; 0x02
    4d30:	0e 94 61 15 	call	0x2ac2	; 0x2ac2 <vPortFree>
	}
    4d34:	0f 90       	pop	r0
    4d36:	0f 90       	pop	r0
    4d38:	cf 91       	pop	r28
    4d3a:	df 91       	pop	r29
    4d3c:	08 95       	ret

00004d3e <main>:
#include "FreeRTOS/task.h"
#include "Tasks/Tasks_Interface.h"
#include "avr/delay.h"

int main(void)
{
    4d3e:	af 92       	push	r10
    4d40:	bf 92       	push	r11
    4d42:	cf 92       	push	r12
    4d44:	df 92       	push	r13
    4d46:	ef 92       	push	r14
    4d48:	ff 92       	push	r15
    4d4a:	0f 93       	push	r16
    4d4c:	df 93       	push	r29
    4d4e:	cf 93       	push	r28
    4d50:	cd b7       	in	r28, 0x3d	; 61
    4d52:	de b7       	in	r29, 0x3e	; 62
/************	Soil Moisture Sensor CONFIG	*****************/
			/*		OUTPUT LOW volt		*/
	DIO_SETPinDirection(PORTA_ID,PIN4_ID,OUTPUT);
    4d54:	80 e0       	ldi	r24, 0x00	; 0
    4d56:	64 e0       	ldi	r22, 0x04	; 4
    4d58:	41 e0       	ldi	r20, 0x01	; 1
    4d5a:	0e 94 2a 08 	call	0x1054	; 0x1054 <DIO_SETPinDirection>
	DIO_SETPinValue(PORTA_ID,PIN4_ID,LOW);
    4d5e:	80 e0       	ldi	r24, 0x00	; 0
    4d60:	64 e0       	ldi	r22, 0x04	; 4
    4d62:	40 e0       	ldi	r20, 0x00	; 0
    4d64:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
			/*	INPUT PULLUP Signal	*/
	DIO_SETPinDirection(PORTA_ID,PIN0_ID,INPUT);
    4d68:	80 e0       	ldi	r24, 0x00	; 0
    4d6a:	60 e0       	ldi	r22, 0x00	; 0
    4d6c:	40 e0       	ldi	r20, 0x00	; 0
    4d6e:	0e 94 2a 08 	call	0x1054	; 0x1054 <DIO_SETPinDirection>
	DIO_SETPinValue(PORTA_ID,PIN0_ID,HIGH);
    4d72:	80 e0       	ldi	r24, 0x00	; 0
    4d74:	60 e0       	ldi	r22, 0x00	; 0
    4d76:	41 e0       	ldi	r20, 0x01	; 1
    4d78:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>

/*************	Water level Sensor CONFIG	*****************/
			/*		OUTPUT LOW volt		*/
	DIO_SETPinDirection(PORTA_ID,PIN6_ID,OUTPUT);
    4d7c:	80 e0       	ldi	r24, 0x00	; 0
    4d7e:	66 e0       	ldi	r22, 0x06	; 6
    4d80:	41 e0       	ldi	r20, 0x01	; 1
    4d82:	0e 94 2a 08 	call	0x1054	; 0x1054 <DIO_SETPinDirection>
	DIO_SETPinValue(PORTA_ID,PIN6_ID,LOW);
    4d86:	80 e0       	ldi	r24, 0x00	; 0
    4d88:	66 e0       	ldi	r22, 0x06	; 6
    4d8a:	40 e0       	ldi	r20, 0x00	; 0
    4d8c:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>
			/*	INPUT PULLUP Signal	*/
	DIO_SETPinDirection(PORTA_ID,PIN7_ID,INPUT);
    4d90:	80 e0       	ldi	r24, 0x00	; 0
    4d92:	67 e0       	ldi	r22, 0x07	; 7
    4d94:	40 e0       	ldi	r20, 0x00	; 0
    4d96:	0e 94 2a 08 	call	0x1054	; 0x1054 <DIO_SETPinDirection>
	DIO_SETPinValue(PORTA_ID,PIN7_ID,HIGH);
    4d9a:	80 e0       	ldi	r24, 0x00	; 0
    4d9c:	67 e0       	ldi	r22, 0x07	; 7
    4d9e:	41 e0       	ldi	r20, 0x01	; 1
    4da0:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>

/*****************	Motor Pump CONFIG	*******************/
		/*		OUTPUT LOW volt		*/
	DIO_SETPinDirection(PORTC_ID,PIN7_ID,OUTPUT);
    4da4:	82 e0       	ldi	r24, 0x02	; 2
    4da6:	67 e0       	ldi	r22, 0x07	; 7
    4da8:	41 e0       	ldi	r20, 0x01	; 1
    4daa:	0e 94 2a 08 	call	0x1054	; 0x1054 <DIO_SETPinDirection>
	DIO_SETPinValue(PORTC_ID,PIN7_ID,LOW);
    4dae:	82 e0       	ldi	r24, 0x02	; 2
    4db0:	67 e0       	ldi	r22, 0x07	; 7
    4db2:	40 e0       	ldi	r20, 0x00	; 0
    4db4:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>

/*****************	Motor Pump CONFIG	*******************/
		/*		OUTPUT LOW volt		*/
	DIO_SETPinDirection(PORTC_ID,PIN6_ID,OUTPUT);
    4db8:	82 e0       	ldi	r24, 0x02	; 2
    4dba:	66 e0       	ldi	r22, 0x06	; 6
    4dbc:	41 e0       	ldi	r20, 0x01	; 1
    4dbe:	0e 94 2a 08 	call	0x1054	; 0x1054 <DIO_SETPinDirection>
	DIO_SETPinValue(PORTC_ID,PIN6_ID,LOW);
    4dc2:	82 e0       	ldi	r24, 0x02	; 2
    4dc4:	66 e0       	ldi	r22, 0x06	; 6
    4dc6:	40 e0       	ldi	r20, 0x00	; 0
    4dc8:	0e 94 2a 09 	call	0x1254	; 0x1254 <DIO_SETPinValue>

/****************		Initialization		****************/
	/*	Enable GIE	*/
	GIE_VoidEnable();
    4dcc:	0e 94 0e 08 	call	0x101c	; 0x101c <GIE_VoidEnable>
		/*	LCD INIT	*/
	LCD_voidInit();
    4dd0:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <LCD_voidInit>
		/*	ADC INIT	*/
	ADC_VoidInit();
    4dd4:	0e 94 a2 0b 	call	0x1744	; 0x1744 <ADC_VoidInit>
	/*	UART INIT	*/
	USART_INIT(9600);
    4dd8:	80 e8       	ldi	r24, 0x80	; 128
    4dda:	95 e2       	ldi	r25, 0x25	; 37
    4ddc:	0e 94 3d 07 	call	0xe7a	; 0xe7a <USART_INIT>

/********************	Create tasks	***********************/
	xTaskCreate(soil_moisture_sensor,"Sensor1",100,NULL,2,NULL);
    4de0:	87 e1       	ldi	r24, 0x17	; 23
    4de2:	96 e0       	ldi	r25, 0x06	; 6
    4de4:	25 e6       	ldi	r18, 0x65	; 101
    4de6:	30 e0       	ldi	r19, 0x00	; 0
    4de8:	b9 01       	movw	r22, r18
    4dea:	44 e6       	ldi	r20, 0x64	; 100
    4dec:	50 e0       	ldi	r21, 0x00	; 0
    4dee:	20 e0       	ldi	r18, 0x00	; 0
    4df0:	30 e0       	ldi	r19, 0x00	; 0
    4df2:	02 e0       	ldi	r16, 0x02	; 2
    4df4:	ee 24       	eor	r14, r14
    4df6:	ff 24       	eor	r15, r15
    4df8:	cc 24       	eor	r12, r12
    4dfa:	dd 24       	eor	r13, r13
    4dfc:	aa 24       	eor	r10, r10
    4dfe:	bb 24       	eor	r11, r11
    4e00:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskGenericCreate>
	xTaskCreate(water_level_sensor,"Sensor2",100,NULL,2,NULL);
    4e04:	8d e3       	ldi	r24, 0x3D	; 61
    4e06:	96 e0       	ldi	r25, 0x06	; 6
    4e08:	2d e6       	ldi	r18, 0x6D	; 109
    4e0a:	30 e0       	ldi	r19, 0x00	; 0
    4e0c:	b9 01       	movw	r22, r18
    4e0e:	44 e6       	ldi	r20, 0x64	; 100
    4e10:	50 e0       	ldi	r21, 0x00	; 0
    4e12:	20 e0       	ldi	r18, 0x00	; 0
    4e14:	30 e0       	ldi	r19, 0x00	; 0
    4e16:	02 e0       	ldi	r16, 0x02	; 2
    4e18:	ee 24       	eor	r14, r14
    4e1a:	ff 24       	eor	r15, r15
    4e1c:	cc 24       	eor	r12, r12
    4e1e:	dd 24       	eor	r13, r13
    4e20:	aa 24       	eor	r10, r10
    4e22:	bb 24       	eor	r11, r11
    4e24:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskGenericCreate>
	xTaskCreate(Pump,"Motor",100,NULL,4,NULL);
    4e28:	87 ed       	ldi	r24, 0xD7	; 215
    4e2a:	96 e0       	ldi	r25, 0x06	; 6
    4e2c:	25 e7       	ldi	r18, 0x75	; 117
    4e2e:	30 e0       	ldi	r19, 0x00	; 0
    4e30:	b9 01       	movw	r22, r18
    4e32:	44 e6       	ldi	r20, 0x64	; 100
    4e34:	50 e0       	ldi	r21, 0x00	; 0
    4e36:	20 e0       	ldi	r18, 0x00	; 0
    4e38:	30 e0       	ldi	r19, 0x00	; 0
    4e3a:	04 e0       	ldi	r16, 0x04	; 4
    4e3c:	ee 24       	eor	r14, r14
    4e3e:	ff 24       	eor	r15, r15
    4e40:	cc 24       	eor	r12, r12
    4e42:	dd 24       	eor	r13, r13
    4e44:	aa 24       	eor	r10, r10
    4e46:	bb 24       	eor	r11, r11
    4e48:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskGenericCreate>
	xTaskCreate(Buzzer,"Buzzer",100,NULL,3,NULL);
    4e4c:	8a e0       	ldi	r24, 0x0A	; 10
    4e4e:	97 e0       	ldi	r25, 0x07	; 7
    4e50:	2b e7       	ldi	r18, 0x7B	; 123
    4e52:	30 e0       	ldi	r19, 0x00	; 0
    4e54:	b9 01       	movw	r22, r18
    4e56:	44 e6       	ldi	r20, 0x64	; 100
    4e58:	50 e0       	ldi	r21, 0x00	; 0
    4e5a:	20 e0       	ldi	r18, 0x00	; 0
    4e5c:	30 e0       	ldi	r19, 0x00	; 0
    4e5e:	03 e0       	ldi	r16, 0x03	; 3
    4e60:	ee 24       	eor	r14, r14
    4e62:	ff 24       	eor	r15, r15
    4e64:	cc 24       	eor	r12, r12
    4e66:	dd 24       	eor	r13, r13
    4e68:	aa 24       	eor	r10, r10
    4e6a:	bb 24       	eor	r11, r11
    4e6c:	0e 94 34 1e 	call	0x3c68	; 0x3c68 <xTaskGenericCreate>

/*******************	create semaphore	*******************/
	vSemaphoreCreateBinary(Sem);
    4e70:	81 e0       	ldi	r24, 0x01	; 1
    4e72:	60 e0       	ldi	r22, 0x00	; 0
    4e74:	0e 94 94 19 	call	0x3328	; 0x3328 <xQueueCreate>
    4e78:	90 93 0e 06 	sts	0x060E, r25
    4e7c:	80 93 0d 06 	sts	0x060D, r24
    4e80:	80 91 0d 06 	lds	r24, 0x060D
    4e84:	90 91 0e 06 	lds	r25, 0x060E
    4e88:	00 97       	sbiw	r24, 0x00	; 0
    4e8a:	59 f0       	breq	.+22     	; 0x4ea2 <main+0x164>
    4e8c:	80 91 0d 06 	lds	r24, 0x060D
    4e90:	90 91 0e 06 	lds	r25, 0x060E
    4e94:	60 e0       	ldi	r22, 0x00	; 0
    4e96:	70 e0       	ldi	r23, 0x00	; 0
    4e98:	40 e0       	ldi	r20, 0x00	; 0
    4e9a:	50 e0       	ldi	r21, 0x00	; 0
    4e9c:	20 e0       	ldi	r18, 0x00	; 0
    4e9e:	0e 94 5c 1a 	call	0x34b8	; 0x34b8 <xQueueGenericSend>

/***************	Display Strings in LCD		**************/
	/*	Display Strings in LCD */
	LCD_voidWriteString((u8*)"Humidity:");
    4ea2:	82 e8       	ldi	r24, 0x82	; 130
    4ea4:	90 e0       	ldi	r25, 0x00	; 0
    4ea6:	0e 94 60 11 	call	0x22c0	; 0x22c0 <LCD_voidWriteString>
	LCD_SetCursor(1,0);
    4eaa:	81 e0       	ldi	r24, 0x01	; 1
    4eac:	60 e0       	ldi	r22, 0x00	; 0
    4eae:	0e 94 a3 11 	call	0x2346	; 0x2346 <LCD_SetCursor>
	LCD_voidWriteString((u8*)"Water Level: ");
    4eb2:	8c e8       	ldi	r24, 0x8C	; 140
    4eb4:	90 e0       	ldi	r25, 0x00	; 0
    4eb6:	0e 94 60 11 	call	0x22c0	; 0x22c0 <LCD_voidWriteString>



	/*	RTOS Init	*/
	vTaskStartScheduler();
    4eba:	0e 94 8c 21 	call	0x4318	; 0x4318 <vTaskStartScheduler>
    4ebe:	ff cf       	rjmp	.-2      	; 0x4ebe <main+0x180>

00004ec0 <__udivmodhi4>:
    4ec0:	aa 1b       	sub	r26, r26
    4ec2:	bb 1b       	sub	r27, r27
    4ec4:	51 e1       	ldi	r21, 0x11	; 17
    4ec6:	07 c0       	rjmp	.+14     	; 0x4ed6 <__udivmodhi4_ep>

00004ec8 <__udivmodhi4_loop>:
    4ec8:	aa 1f       	adc	r26, r26
    4eca:	bb 1f       	adc	r27, r27
    4ecc:	a6 17       	cp	r26, r22
    4ece:	b7 07       	cpc	r27, r23
    4ed0:	10 f0       	brcs	.+4      	; 0x4ed6 <__udivmodhi4_ep>
    4ed2:	a6 1b       	sub	r26, r22
    4ed4:	b7 0b       	sbc	r27, r23

00004ed6 <__udivmodhi4_ep>:
    4ed6:	88 1f       	adc	r24, r24
    4ed8:	99 1f       	adc	r25, r25
    4eda:	5a 95       	dec	r21
    4edc:	a9 f7       	brne	.-22     	; 0x4ec8 <__udivmodhi4_loop>
    4ede:	80 95       	com	r24
    4ee0:	90 95       	com	r25
    4ee2:	bc 01       	movw	r22, r24
    4ee4:	cd 01       	movw	r24, r26
    4ee6:	08 95       	ret

00004ee8 <__udivmodsi4>:
    4ee8:	a1 e2       	ldi	r26, 0x21	; 33
    4eea:	1a 2e       	mov	r1, r26
    4eec:	aa 1b       	sub	r26, r26
    4eee:	bb 1b       	sub	r27, r27
    4ef0:	fd 01       	movw	r30, r26
    4ef2:	0d c0       	rjmp	.+26     	; 0x4f0e <__udivmodsi4_ep>

00004ef4 <__udivmodsi4_loop>:
    4ef4:	aa 1f       	adc	r26, r26
    4ef6:	bb 1f       	adc	r27, r27
    4ef8:	ee 1f       	adc	r30, r30
    4efa:	ff 1f       	adc	r31, r31
    4efc:	a2 17       	cp	r26, r18
    4efe:	b3 07       	cpc	r27, r19
    4f00:	e4 07       	cpc	r30, r20
    4f02:	f5 07       	cpc	r31, r21
    4f04:	20 f0       	brcs	.+8      	; 0x4f0e <__udivmodsi4_ep>
    4f06:	a2 1b       	sub	r26, r18
    4f08:	b3 0b       	sbc	r27, r19
    4f0a:	e4 0b       	sbc	r30, r20
    4f0c:	f5 0b       	sbc	r31, r21

00004f0e <__udivmodsi4_ep>:
    4f0e:	66 1f       	adc	r22, r22
    4f10:	77 1f       	adc	r23, r23
    4f12:	88 1f       	adc	r24, r24
    4f14:	99 1f       	adc	r25, r25
    4f16:	1a 94       	dec	r1
    4f18:	69 f7       	brne	.-38     	; 0x4ef4 <__udivmodsi4_loop>
    4f1a:	60 95       	com	r22
    4f1c:	70 95       	com	r23
    4f1e:	80 95       	com	r24
    4f20:	90 95       	com	r25
    4f22:	9b 01       	movw	r18, r22
    4f24:	ac 01       	movw	r20, r24
    4f26:	bd 01       	movw	r22, r26
    4f28:	cf 01       	movw	r24, r30
    4f2a:	08 95       	ret

00004f2c <__prologue_saves__>:
    4f2c:	2f 92       	push	r2
    4f2e:	3f 92       	push	r3
    4f30:	4f 92       	push	r4
    4f32:	5f 92       	push	r5
    4f34:	6f 92       	push	r6
    4f36:	7f 92       	push	r7
    4f38:	8f 92       	push	r8
    4f3a:	9f 92       	push	r9
    4f3c:	af 92       	push	r10
    4f3e:	bf 92       	push	r11
    4f40:	cf 92       	push	r12
    4f42:	df 92       	push	r13
    4f44:	ef 92       	push	r14
    4f46:	ff 92       	push	r15
    4f48:	0f 93       	push	r16
    4f4a:	1f 93       	push	r17
    4f4c:	cf 93       	push	r28
    4f4e:	df 93       	push	r29
    4f50:	cd b7       	in	r28, 0x3d	; 61
    4f52:	de b7       	in	r29, 0x3e	; 62
    4f54:	ca 1b       	sub	r28, r26
    4f56:	db 0b       	sbc	r29, r27
    4f58:	0f b6       	in	r0, 0x3f	; 63
    4f5a:	f8 94       	cli
    4f5c:	de bf       	out	0x3e, r29	; 62
    4f5e:	0f be       	out	0x3f, r0	; 63
    4f60:	cd bf       	out	0x3d, r28	; 61
    4f62:	09 94       	ijmp

00004f64 <__epilogue_restores__>:
    4f64:	2a 88       	ldd	r2, Y+18	; 0x12
    4f66:	39 88       	ldd	r3, Y+17	; 0x11
    4f68:	48 88       	ldd	r4, Y+16	; 0x10
    4f6a:	5f 84       	ldd	r5, Y+15	; 0x0f
    4f6c:	6e 84       	ldd	r6, Y+14	; 0x0e
    4f6e:	7d 84       	ldd	r7, Y+13	; 0x0d
    4f70:	8c 84       	ldd	r8, Y+12	; 0x0c
    4f72:	9b 84       	ldd	r9, Y+11	; 0x0b
    4f74:	aa 84       	ldd	r10, Y+10	; 0x0a
    4f76:	b9 84       	ldd	r11, Y+9	; 0x09
    4f78:	c8 84       	ldd	r12, Y+8	; 0x08
    4f7a:	df 80       	ldd	r13, Y+7	; 0x07
    4f7c:	ee 80       	ldd	r14, Y+6	; 0x06
    4f7e:	fd 80       	ldd	r15, Y+5	; 0x05
    4f80:	0c 81       	ldd	r16, Y+4	; 0x04
    4f82:	1b 81       	ldd	r17, Y+3	; 0x03
    4f84:	aa 81       	ldd	r26, Y+2	; 0x02
    4f86:	b9 81       	ldd	r27, Y+1	; 0x01
    4f88:	ce 0f       	add	r28, r30
    4f8a:	d1 1d       	adc	r29, r1
    4f8c:	0f b6       	in	r0, 0x3f	; 63
    4f8e:	f8 94       	cli
    4f90:	de bf       	out	0x3e, r29	; 62
    4f92:	0f be       	out	0x3f, r0	; 63
    4f94:	cd bf       	out	0x3d, r28	; 61
    4f96:	ed 01       	movw	r28, r26
    4f98:	08 95       	ret

00004f9a <memcpy>:
    4f9a:	fb 01       	movw	r30, r22
    4f9c:	dc 01       	movw	r26, r24
    4f9e:	02 c0       	rjmp	.+4      	; 0x4fa4 <memcpy+0xa>
    4fa0:	01 90       	ld	r0, Z+
    4fa2:	0d 92       	st	X+, r0
    4fa4:	41 50       	subi	r20, 0x01	; 1
    4fa6:	50 40       	sbci	r21, 0x00	; 0
    4fa8:	d8 f7       	brcc	.-10     	; 0x4fa0 <memcpy+0x6>
    4faa:	08 95       	ret

00004fac <memset>:
    4fac:	dc 01       	movw	r26, r24
    4fae:	01 c0       	rjmp	.+2      	; 0x4fb2 <memset+0x6>
    4fb0:	6d 93       	st	X+, r22
    4fb2:	41 50       	subi	r20, 0x01	; 1
    4fb4:	50 40       	sbci	r21, 0x00	; 0
    4fb6:	e0 f7       	brcc	.-8      	; 0x4fb0 <memset+0x4>
    4fb8:	08 95       	ret

00004fba <strncpy>:
    4fba:	fb 01       	movw	r30, r22
    4fbc:	dc 01       	movw	r26, r24
    4fbe:	41 50       	subi	r20, 0x01	; 1
    4fc0:	50 40       	sbci	r21, 0x00	; 0
    4fc2:	48 f0       	brcs	.+18     	; 0x4fd6 <strncpy+0x1c>
    4fc4:	01 90       	ld	r0, Z+
    4fc6:	0d 92       	st	X+, r0
    4fc8:	00 20       	and	r0, r0
    4fca:	c9 f7       	brne	.-14     	; 0x4fbe <strncpy+0x4>
    4fcc:	01 c0       	rjmp	.+2      	; 0x4fd0 <strncpy+0x16>
    4fce:	1d 92       	st	X+, r1
    4fd0:	41 50       	subi	r20, 0x01	; 1
    4fd2:	50 40       	sbci	r21, 0x00	; 0
    4fd4:	e0 f7       	brcc	.-8      	; 0x4fce <strncpy+0x14>
    4fd6:	08 95       	ret

00004fd8 <_exit>:
    4fd8:	f8 94       	cli

00004fda <__stop_program>:
    4fda:	ff cf       	rjmp	.-2      	; 0x4fda <__stop_program>
